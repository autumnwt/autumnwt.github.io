<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IDA工具使用</title>
      <link href="/2023/05/09/ida-gong-ju-shi-yong/"/>
      <url>/2023/05/09/ida-gong-ju-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="IDA工具使用"><a href="#IDA工具使用" class="headerlink" title="IDA工具使用"></a>IDA工具使用</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>a</code> ：将数据转换为字符串</p><p><code>f5</code>：一键反汇编</p><p><code>esc</code>：回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其他窗口按下esc，会关闭该窗口）</p><p><code>shift+f12</code>：可以打开string窗口，一键找出所有的字符串，右击setup，还能对窗口的属性进行设置</p><p><code>ctrl+w</code>：保存ida数据库</p><p><code>ctrl+s</code>：选择某个数据段，直接进行跳转</p><p><code>ctrl+鼠标滚轮</code>：能够调节流程视图的大小</p><p><code>x</code>：对着某个函数、变量按该快捷键，可以查看它的交叉引用</p><p><code>g</code>：直接跳转到某个地址</p><p><code>n</code>：更改变量的名称</p><p><code>y</code>：更改变量的类型</p><p><code>/ </code>：在反编译后伪代码的界面中写下注释</p><p><code>\</code>：在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多</p><p><code>；</code>：在反汇编后的界面中写下注释</p><p><code>ctrl+shift+w</code>：拍摄IDA快照</p><p><code>u</code>：undefine，取消定义函数、代码、数据的定义</p><p><code>H</code>：在数字上按下H键或者右键进行选择，可以将数字转化为十进制</p><p><code>B</code>：按下B键转换为二进制</p><p><code>c</code>: 将数据解析成汇编指令</p><p><code>Space</code>：视图转换</p><p><code>F2</code>：添加断点</p><p><code>F7</code>：单步步入</p><p><code>F8</code>：单步步过</p><hr><h3 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h3><h4 id="开启动调"><a href="#开启动调" class="headerlink" title="开启动调"></a>开启动调</h4><ul><li><p>选择use source level debugging：<img src="/2023/05/09/ida-gong-ju-shi-yong/1.jpg" style="zoom:100%;"></p></li><li><p>选择模式：<img src="/2023/05/09/ida-gong-ju-shi-yong/2.jpg" style="zoom:100%;"></p></li><li><p>设置断点</p></li><li><p>开始运行</p></li></ul><h4 id="更改寄存器内容"><a href="#更改寄存器内容" class="headerlink" title="更改寄存器内容"></a>更改寄存器内容</h4><ul><li>进入动调模式后在右上角点击需要修改的内容即可：</li></ul><p><img src="/2023/05/09/ida-gong-ju-shi-yong/3.jpg" style="zoom:100%;">、</p><h4 id="字节级别修改"><a href="#字节级别修改" class="headerlink" title="字节级别修改"></a>字节级别修改</h4><ul><li>进入动调模式后，右击想要修改的指令</li><li>选择<code>patching</code>-<code>change byte</code>即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编语言与逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
            <tag> 工具 </tag>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库数据控制实验</title>
      <link href="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/"/>
      <url>/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库实验：数据控制"><a href="#数据库实验：数据控制" class="headerlink" title="数据库实验：数据控制"></a>数据库实验：数据控制</h1><p>黄芃洋 2021212021 2021211801班</p><hr><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>熟悉通过SQL对数据库进行数据控制，包括安全性、完整性和数据库恢复</p><h2 id="实验工具"><a href="#实验工具" class="headerlink" title="实验工具"></a>实验工具</h2><p>SQL Server的交互查询工具</p><h2 id="实验数据库（初始）"><a href="#实验数据库（初始）" class="headerlink" title="实验数据库（初始）"></a>实验数据库（初始）</h2><ul><li>建立数据库</li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/1.jpg" style="zoom:30%;"><ul><li>在数据库中建立部门、员工、工资三个表</li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/6.jpg" style="zoom:40%;"><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="安全性实验部分"><a href="#安全性实验部分" class="headerlink" title="安全性实验部分:"></a>安全性实验部分:</h3><blockquote><p>授权与回收</p><p>另：注意SQL Server中登录名与用户的区别</p></blockquote><p><strong>1.在数据库中由DBA创建若干用户，权限全部选择为CONNECT（SQL Server中的db_accessadmin角色）</strong></p><ul><li>创建登录名，并且选择不强制实施密码策略，选择Company作为默认数据库</li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/2.jpg" style="zoom:40%;"><ul><li><p>按照此方法依次创建登录名user1~user4<img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/3.jpg" style="zoom:60%;"></p></li><li><p>在登录名下、Company数据库中创建用户，设置用户的schema并赋予数据库用户“db_accessadmin”权限</p></li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/4.jpg" style="zoom:40%;"><ul><li>按照此方法依次创建用户u1~u4<img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/5.jpg" style="zoom:60%;"></li></ul><p><strong>2.仿照教材4.2.4 [例1]~[例10]，在DBA与这些用户之间进行授权和回收，并查看效果（4用例）</strong></p><blockquote><p><strong>例一：</strong>把查询Staff表权限授给用户u1</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/7.jpg" style="zoom:40%;"><ul><li>使用用户u1进入数据库系统，查询Staff表，可以查询到正常结果</li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/8.jpg" style="zoom:40%;"><ul><li>我们重新返回管理员，将u1权限收回</li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/9.jpg" style="zoom:40%;"><ul><li>我们重新使用用户u1进入数据库系统，查询Staff表，系统提示u1无查询权限</li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/10.jpg" style="zoom:40%;"><blockquote><p><strong>例二：</strong>把查询Salary表和修改基础工资的权限授给用户u2</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/11.jpg" style="zoom:40%;"><ul><li>使用用户u2进入数据库系统，对Salary表的职员基础工资进行调整（由5000调整为5500），之后对Salary表进行查询，发现信息已被成功修改</li></ul><p>​                    <img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/12.jpg" style="zoom:40%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/13.jpg" style="zoom:40%;"></p><ul><li>我们重新返回管理员，用与例一相同方法将u2权限收回后，系统提示u2无查询与更改权限</li></ul><p>​      <img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/14.jpg" style="zoom:30%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/15.jpg" style="zoom:30%;"></p><blockquote><p><strong>例三：</strong>把对Department表的全部权限授予用户u3</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/16.jpg" style="zoom:40%;"><ul><li>使用用户u3进入数据库系统，对Department表执行添加元组操作，之后对Department表进行查询，发现信息已被成功插入添加</li></ul><p>​                                  <img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/17.jpg" style="zoom:40%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/18.jpg" style="zoom:40%;"></p><ul><li>我们重新返回管理员，用与例一相同方法将u3权限收回后，系统提示u3已无相关权限</li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/19.jpg" style="zoom:40%;"><blockquote><p><strong>例四：</strong>把对表Staff的INSERT权限授予u3用户，并允许他再将此权限授予其他用户；</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/20.jpg" style="zoom:40%;"><ul><li>使用用户u3进入数据库系统，对Staff表执行添加元组操作，之后使用管理员用户对Staff表进行查询，发现信息已被成功插入添加</li></ul><p>​                                <img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/21.jpg" style="zoom:40%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/22.jpg" style="zoom:40%;"></p><ul><li>使用用户u3进入数据库系统，通过u3再将此权限授予用户u4，之后使用u4用户对Staff表执行添加元组操作，发现信息已被成功插入添加</li></ul><p>​                          <img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/23.jpg" style="zoom:30%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/24.jpg" style="zoom:30%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/25.jpg" style="zoom:30%;"></p><ul><li>我们重新返回管理员，用与例一相同方法将u3权限级联CASCADE收回后，系统提示u3、u4已无相关权限</li></ul><p>​                       <img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/26.jpg" style="zoom:30%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/27.jpg" style="zoom:30%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/28.jpg" style="zoom:30%;"></p><hr><h3 id="完整性实验部分"><a href="#完整性实验部分" class="headerlink" title="完整性实验部分:"></a>完整性实验部分:</h3><blockquote><p>使用SQL对数据进行完整性控制，并用实验证实，当操作违反了完整性约束条件时，系统是如何处理的</p></blockquote><p><strong>1.实体完整性</strong></p><blockquote><p>建立客户表，令客户编号为主码</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/29.jpg" style="zoom:40%;"><blockquote><p>例一：向该表中尝试插入一个主码值为C03的元组（与表中原有的一个元组主码值一致），随后发现系统显示该尝试违反了主码约束，因此拒绝插入</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/30.jpg" style="zoom:40%;"><blockquote><p>例二：向该表中尝试插入一个主码值为NULL的元组，随后发现系统显示该尝试违反了主码约束，因此拒绝插入</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/31.jpg" style="zoom:40%;"><p><strong>2.参照完整性：</strong></p><blockquote><p>建立接洽表，令员工编号、客户编号为主码，二者分别参照引用Staff表的主码和Client表的主码</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/32.jpg" style="zoom:40%;"><blockquote><p><strong>例一：</strong>尝试在Serve中插入元组，随后发现系统显示该尝试违反了外码约束，因此拒绝插入</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/33.jpg" style="zoom:40%;"><blockquote><p><strong>例二：</strong>尝试在Serve中修改外码值，随后发现系统显示该尝试违反了外码约束，因此拒绝插入</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/34.jpg" style="zoom:40%;"><blockquote><p><strong>例三：</strong>尝试在Staff中删除元组，随后发现系统显示该尝试可能破坏参照完整性，因此拒绝删除</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/35.jpg" style="zoom:40%;"><blockquote><p><strong>例四：</strong>尝试在Staff中修改主码值，随后发现系统显示该尝试可能破坏参照完整性，因此拒绝修改</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/36.jpg" style="zoom:40%;"><p><strong>3.用户定义完整性</strong></p><blockquote><p>建立项目表，令项目编号为主码，并且要求项目名称唯一</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/37.jpg" style="zoom:40%;"><blockquote><p>例：向该表中尝试插入一个Project_Name值为A-UI-Design的元组（与表中原有的一个元组主码值一致），随后发现系统显示该尝试违反用户定义完整性，因此拒绝插入</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/38.jpg" style="zoom:40%;"><p><strong>4.CHECK短语</strong></p><blockquote><p>建立预算表，令项目编号为主码，并且要求预算低于50万</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/39.jpg" style="zoom:40%;"><blockquote><p>例：向该表中尝试插入一个Budget值为60万的元组，随后发现系统显示该尝试违反属性上的约束条件，因此拒绝插入</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/40.jpg" style="zoom:40%;"><p><strong>5.CONSTRAINT子句</strong></p><blockquote><p>建立立项申请表，令员工编号为主码，并且要求预算低于50万，且员工编号在1到50之间（包含1和50）</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/41.jpg" style="zoom:40%;"><blockquote><p>例：修改表Project_Application中的约束条件，要求预算低于30万</p></blockquote><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/42.jpg" style="zoom:40%;"><ul><li>向该表中尝试插入一个Request_Funding值为40万的元组，随后发现此时C2约束条件已经改成低于30万，因此系统显示该尝试违反约束条件，拒绝插入</li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/43.jpg" style="zoom:40%;"><hr><h3 id="备份与恢复实验部分"><a href="#备份与恢复实验部分" class="headerlink" title="备份与恢复实验部分:"></a>备份与恢复实验部分:</h3><blockquote><p>用Transact-SQL完成以下操作</p></blockquote><p><strong>1.创建一个备份设备</strong></p><ul><li>添加一个名为BackupDev的磁盘备份设备，其物理名称为E:\downloads\Microsoft SQL Server\backup\BackupC.bak</li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/44.jpg" style="zoom:40%;"><p><strong>2.完整备份实验数据库到备份设备</strong></p><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/45.jpg" style="zoom:40%;"><p><strong>3.向实验数据库中某个表插入若干条记录</strong></p><ul><li>向表Staff插入记录</li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/46.jpg" style="zoom:40%;"><p><strong>4.备份数据库事务日志到备份设备，并查看日志格式</strong></p><p><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/47.jpg" style="zoom:40%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/48.jpg" style="zoom:33%;"></p><p><strong>5.利用第2步所得的完整备份，恢复到插入记录前的状态</strong></p><ul><li>执行后查询Staff表，发现表已恢复到插入记录前的状态</li></ul><p>​                     <img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/49.jpg" style="zoom:30%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/50.jpg" style="zoom:30%;"></p><p><strong>6.利用第4步所得的事务日志，恢复到插入记录后的状态</strong></p><p><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/53.jpg" style="zoom:30%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/52.jpg" style="zoom:30%;"></p><hr><h3 id="触发器实验部分"><a href="#触发器实验部分" class="headerlink" title="触发器实验部分"></a>触发器实验部分</h3><blockquote><p>自行为实验数据库的某个表设计一个触发器，实现某种完整性控制，并验证效果</p></blockquote><p><strong>1.定义一个BEFORE行级触发器，为预算表Budget</strong></p><ul><li>定义完整性规则：预算低于40万元，如果超过40万元，自动改为39.9999万元。</li></ul><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/54.jpg" style="zoom:40%;"><p><strong>2.向budget表中添加一个41万预算的项目进行验证，查表后发现41万的预算被自动改成39.9999万，表明触发器正常工作</strong></p><p>​                                          <img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/55.jpg" style="zoom:30%;"><img src="/2023/05/03/shu-ju-ku-shu-ju-kong-zhi-shi-yan/56.jpg" style="zoom:30%;"></p><p>​                                                                     <strong>–至此，实验结束–</strong></p><hr><h3 id="问题及解决方案"><a href="#问题及解决方案" class="headerlink" title="问题及解决方案"></a>问题及解决方案</h3><p><strong>1.初次进行事务日志备份时系统显示‘当恢复模型为 simple 时,不允许使用backup log 语句’</strong></p><p><em>解决：恢复模式选择完整即可</em></p><p><strong>2.还原时系统提示无法获得对数据库的独占访问权</strong></p><p><em>解决：选择状态中的限制访问，将multi_user (多用户)换成 single_user(单用户)</em></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 . </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言初次尝试</title>
      <link href="/2023/04/08/hui-bian-yu-yan-chu-ci-chang-shi/"/>
      <url>/2023/04/08/hui-bian-yu-yan-chu-ci-chang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="作业-1：汇编语言"><a href="#作业-1：汇编语言" class="headerlink" title="作业-1：汇编语言"></a><strong>作业-1：汇编语言</strong></h2><p>黄芃洋 2021212021</p><hr><h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><blockquote><p><strong>问题-1</strong>：</p><p>   * 1.1 请结合程序上下文逻辑，分析当所实现的“排序算法”不能正确排序时，_check_flag 为零还是非零？ </p><p>   * 1.2 请分析 main函数的执行流程，画出其<strong>伪代码流程图</strong>；</p><p><strong>问题-2</strong>：请理解给定的<strong>do_swap</strong>汇编函数功能，写出等价的 C 语言函数代码；提示需注意数据类型，如长度、有无符号等（unsigned char ？无符号 1 Byte 长的变量？）。</p><p><strong>问题-3</strong>：<strong>请用汇编语言实现冒泡排序函数（需要有详尽的代码注释+运行结果截图）</strong>；提示会调用到已给定的<strong>do_swap</strong>汇编函数</p><p>（提示会自动对所实现的冒泡排序函数进行重复测试，无需自行输入字符串；请注意回答上方的<strong>问题 1.2</strong>）</p></blockquote><h5 id="以下是作答："><a href="#以下是作答：" class="headerlink" title="以下是作答："></a>以下是作答：</h5><hr><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题-1"></a>问题-1</h5><h6 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h6><p>当所实现的“排序算法”不能正确排序时，_check_flag 为零。我们可以用不同方法进行判断，分析如下：</p><ul><li><p>首先我们定位到_check_flag 的位置</p><img src="/2023/04/08/hui-bian-yu-yan-chu-ci-chang-shi/1.jpg" style="zoom:45%;"><p>第一句汇编指令将  _ check_flag 一字节数据值存入eax寄存器并进行无符号扩展；第二、三句汇编指令用于检查al寄存器中的值、也就是_check_flag是否为0,如果不为0，那么ZF将被清除、jne指令也就将跳转到标记为continue_test的位置</p><p>如果为0，那么就不跳转，继续执行接下来的指令，那么我们来看一下接下来的指令：</p><img src="/2023/04/08/hui-bian-yu-yan-chu-ci-chang-shi/2.jpg" style="zoom:45%;"><p>根据上下文关系以及初始化数据段（.data）中的内容，我们可以知道上面的这段指令代表排序错误，并会输出“Sorry but try it again!”等字样，因此可以判断此时实现的“排序算法”不能正确排序，_check_flag 为零。</p></li><li><p>当然我们也可以在标记为end_test_loop的位置判断出来，本段指令如下</p><img src="/2023/04/08/hui-bian-yu-yan-chu-ci-chang-shi/3.jpg" style="zoom:45%;"><p>第一句汇编指令将  _ check_flag 一字节数据值存入eax寄存器并进行无符号扩展；第二、三句汇编指令用于检查al寄存器中的值、也就是_ check_flag是否为0,如果为0，那么ZF将被设置、je指令也就将跳转到标记为end_main的位置，而如果跳转到标志为end_main处，则程序立刻停止，因此显然，为_check_flag为0时“排序算法”不是正确排序</p><p>同时我们来接着往下看如果_ check_flag非零的情况，根据上下文关系以及初始化数据段（.data）中的内容，我们可以知道上面的这段指令代表排序正确，并会输出“Well done!”等字样，因此可以判断此时实现的“排序算法”能正确排序。</p></li><li><p>当然，我们也可以直接看到在#Function-3# 对排序结果得正确性进行检查的函数中：</p><img src="/2023/04/08/hui-bian-yu-yan-chu-ci-chang-shi/4.jpg" style="zoom:45%;"><p>分析可知，当发现排序错误时，它会将 _ check_flag置零</p><p>综上反复论证，我们可以得出结论：<strong>当所实现的“排序算法”不能正确排序时，_check_flag 为零</strong></p></li></ul><h6 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h6><p>根据main函数的汇编指令可以得到其流程图如下：</p><img src="/2023/04/08/hui-bian-yu-yan-chu-ci-chang-shi/5.jpg" style="zoom:45%;"><hr><h5 id="问题-2"><a href="#问题-2" class="headerlink" title="问题-2"></a>问题-2</h5><p>为了写出等价的c语言代码，首先我们来逐条分析并注释一下给定的<strong>do_swap</strong>汇编函数：</p><pre class="line-numbers language-gas" data-language="gas"><code class="language-gas">do_swap:                                                            pushebp                movebp, espsubesp, 4moveax, DWORD PTR [ebp+8]                #把位于内存地址ebp+8的4字节大小的值移入eax寄存器movzxeax, BYTE PTR [eax]               #访问eax中存储的地址并将该地址中的一字节数据放入eax中并进行无符号位扩展，                                                此时eax中存储的是变量1的值movBYTE PTR [ebp-1], al                  #将变量1的值填入ebp-1的位置moveax, DWORD PTR [ebp+12]               #把位于内存地址ebp+12的四字节大小的值移入eax寄存器movzxedx, BYTE PTR [eax]               #访问eax中存储的地址并将该地址中的一字节数据放入edx中并进行无符号位扩展，                                                此时edx中存储的是变量2的值moveax, DWORD PTR [ebp+8]                #把位于内存地址ebp+8的四字节大小的值移入eax寄存器movBYTE PTR [eax], dl                    #访问eax中存储的地址并将该地址中的一字节数据替换成dl中的值，也就相当于将变                                                量2的值存入变量1的位置moveax, DWORD PTR [ebp+12]               #把位于内存地址ebp+12的四字节大小的值移入eax寄存器movzxedx, BYTE PTR [ebp-1]             #把位于ebp-1位置的一字节输入放入edx中进行无符号扩展，此时edx中存储的是变                                                量1的值movBYTE PTR [eax], dl                    #访问eax中存储的地址，并将该地址中一字节数据替换成dl中的值，也就相当于将变                                                量1的值存入变量2的位置leaveret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据上面的分析，我们能够写出对应的C语言代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void do_swap(unsigned char *a, unsigned char *b) {    unsigned char temp = *a;    *a = *b;    *b = temp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="问题-3"><a href="#问题-3" class="headerlink" title="问题-3"></a>问题-3</h5><p>为解决该问题，我们首先可以用C语言实现此功能，用以确定逻辑结构，下面是我先写出的C语言代码（并且还附上了do_swap函数的c代码实现，并配套了main函数用以调用和试验此函数）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">//bubble sort#include&lt;stdio.h&gt;void bubble( unsigned char *arr);void do_swap(unsigned char *a, unsigned char *b);int main(){    unsigned char arr[]={'p','T','v','K','c','g','W','D','F','h'};int i;bubble(arr);for(i=0;i&lt;10;i++){printf("%c",arr[i]);}}void bubble( unsigned char *arr){int j,k;for(j=0;j&lt;9;j++){for(k=0;k&lt;9-j;k++){if(arr[k]&lt;96){ //如果k大写 if(arr[k]&gt;arr[k+1])do_swap(&amp;arr[k],&amp;arr[k+1]);//k+1也是大写且比k小 else if(arr[k+1]&gt;96)do_swap(&amp;arr[k],&amp;arr[k+1]);//k+1是小写 else continue; //k+1是大写但是不比k小 } else{//k是小写     if(arr[k+1]&gt;96){//k+1也是小写         if(arr[k]&gt;arr[k+1])do_swap(&amp;arr[k],&amp;arr[k+1]);else continue;}else continue;    }}   } }void do_swap(unsigned char *a, unsigned char *b) {    unsigned char temp = *a;    *a = *b;    *b = temp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在确定了逻辑结构之后，使用汇编指令进行实现（我几乎为每一句指令都附上了注释）：</p><pre class="line-numbers language-gas" data-language="gas"><code class="language-gas">#Function-4# 冒泡排序函数do_bubble_sort:                          #*# 问题-3：请用汇编语言实现冒泡排序函数；                                         #          提示会调用到已给定的do_swap汇编函数pushebpmovebp, espsubesp, 16### ------------------------------------冒泡排序正文----------------------------------------开始mov     BYTE PTR[ebp-1], 0jmp     outerloopinitialize:                       mov       BYTE PTR[ebp-2], 0           #对k进行初始化jmp       innerloop                       #进入内循环           #-------------------------------------------------------------------judgment:                            movzx     edx, BYTE PTR[ebp-2]              #将k值移入edx中movzx     eax, byte ptr _char_list[edx]         #将arr[k]的值存入eaxadd       edx,1                       #k+1movzx     ebx, byte ptr _char_list[edx]#将arr[k+1]的值存入ebxcmp       al, 96                        #将arr[k]和小写比较ja        k_lower                              #如果arr[k]是小写，则跳转到k_lowerk_capital:cmp       al,bl                               #比较arr[k]和arr[k+1]ja        swap                                #如果k&gt;k+1 跳转swapcmp       bl,96                               #将arr[k+1]和小写比较ja        swap                                #k+1是小写 跳转swap                                                                              jmp       no_swap                             #其余跳转到 no_swapk_lower:cmp       bl,96                               #判断arr[k+1]是否为小写jle       no_swap                             #如果bl是大写则跳转到no_swapcmp       al,bl                               #是小写的话就来判断arr[k]和arr[k+1]的大小ja        swap                                #k+1&lt;k 跳转swap                                                                       jmp       no_swap                             #其余跳转到 no_swap#-------------------------------------------------------------------swap:lea    eax,byte ptr _char_list[edx]           #将存储k+1的地址放入eax中push   eaxsub    edx,1                                 #klea    eax,byte ptr _char_list[edx]           #将存储k的地址放入eax中push   eaxcall   do_swapjmp   kaddno_swap:jmp  kaddkadd:movzx     edx, BYTE PTR[ebp-2]                 #将k值移入edx中add       edx,1                                #k值+1mov       BYTE PTR[ebp-2],dl                 #将新k值重新存入ebp-2位置jmp       innerloop                           #跳转到内循环的入口 #-------------------------------------------------------------------innerloop:                        mov     eax, 9movzx   edx, BYTE PTR[ebp-2]                  #将k值移入edx中     movzx   ebx, BYTE PTR[ebp-1]                  #将j值移入edx中  sub     eax, ebx                            #9-j的值存入eax中cmp     eax, edx                            #对比9-j和kja      judgment                              #9-j&gt;k就跳转                                               #否则就进行j++movzx     ecx, BYTE PTR[ebp-1]                 #将j值移入ecx中       add       ecx,1                                #j值+1mov      BYTE PTR[ebp-1],cl                       #将新j值重新存入ebp-1位置                                               #并回到外循环outerloop:   movzx   ecx, BYTE PTR[ebp-1]                  #将j值移入ecx中         cmp     ecx, 8                              #判断j值与8的关系jle     initialize                      #若j小于等于8就进入内循环准备初始化### ------------------------------------冒泡排序正文----------------------------------------结束end_bubble_sort:leaveret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>放入给到的程序中能得到如下的运行结果：</p><img src="/2023/04/08/hui-bian-yu-yan-chu-ci-chang-shi/6.jpg" style="zoom:45%;"><p>可知功能已经实现，汇编指令无误</p>]]></content>
      
      
      <categories>
          
          <category> 汇编语言与逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 汇编语言 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性规划</title>
      <link href="/2023/03/27/xian-xing-gui-hua/"/>
      <url>/2023/03/27/xian-xing-gui-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="线性规划模型"><a href="#线性规划模型" class="headerlink" title="线性规划模型"></a>线性规划模型</h2><p>题目要求：</p><blockquote><p>某工厂需要利用三种原材料（分别记为1、2、3）混合调配出三种不同的产品（甲、乙、丙）。具体材料要求及产品利润如下表所示。请建立数学模型，为该厂安排生产规划，使其利润最大。</p><table><thead><tr><th>产品名称</th><th>规格要求</th><th>单价</th></tr></thead><tbody><tr><td>甲</td><td>原材料1不少于50%，原材料2不超过25%</td><td>50</td></tr><tr><td>乙</td><td>原材料1不少于25%，原材料2不超过50%</td><td>35</td></tr><tr><td>丙</td><td>不限</td><td>25</td></tr></tbody></table><table><thead><tr><th>原材料名称</th><th>每天最多供应量</th><th>单价</th></tr></thead><tbody><tr><td>1</td><td>100</td><td>65</td></tr><tr><td>2</td><td>100</td><td>25</td></tr><tr><td>3</td><td>60</td><td>35</td></tr></tbody></table></blockquote><h4 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h4><p>设变量$x_{ij}$：产品$i$中的原材料$j$的含量，其中$i$为产品名称(<strong>1</strong>对应<strong>甲</strong>，以此类推)，$j$为原材料名称</p><h4 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h4><p>该问题要求求解利润最大时的生产规划安排，其中利润=收入-成本，我们利用线性规划模型进行求解：</p><ul><li><p>目标函数：</p><p>$max_z=50(x_{11}+x_{12}+x_{13})+35(x_{21}+x_{22}+x_{23})+25(x_{31}+x_{32}+x_{33})-65(x_{11}+x_{21}+x_{31})-25(x_{12}+x_{22}+x_{32})-35(x_{13}+x_{23}+x_{33})$</p><blockquote><p>其中：</p><p>$50(x_{11}+x_{12}+x_{13})+35(x_{21}+x_{22}+x_{23})+20(x_{31}+x_{32}+x_{33})$ 为总收入</p><p>$65(x_{11}+x_{21}+x_{31})+25(x_{12}+x_{22}+x_{32})+35(x_{13}+x_{23}+x_{33})$为总成本</p></blockquote></li><li><p>约束条件：</p><p>$  x_{11}≥0.5(x_{11}+x_{12}+x_{13})$</p><blockquote><p>对于产品甲，原材料1不少于50%</p><p>$ x_{12}+x_{13}-x_{11}≤0$</p></blockquote><p>$ x_{12}≤0.25(x_{11}+x_{12}+x_{13})$</p><blockquote><p>对于产品甲，原材料2不超过25%</p><p>$3x_{12}-x_{11}-x_{13}≤0$</p></blockquote><p>$x_{21}≥0.25(x_{21}+x_{22}+x_{23})$</p><blockquote><p>对于产品乙，原材料1不少于25%</p><p> $x_{22}+x_{23}-3x_{21}≤0$</p></blockquote><p>$ x_{22}≤0.5(x_{21}+x_{22}+x_{23})$</p><blockquote><p>对于产品乙，原材料2不超过50%</p><p> $x_{22}-x_{21}-x_{23}≤0$</p></blockquote><p>$x_{11}+x_{21}+x_{31}≤100$</p><blockquote><p>对于原料1，每天最多供应量为100</p></blockquote><p>$x_{12}+x_{22}+x_{32}≤100$</p><blockquote><p>对于原料2，每天最多供应量为100</p></blockquote><p>$x_{13}+x_{23}+x_{33}≤60$</p><blockquote><p>对于原料3，每天最多供应量为60</p></blockquote><p> $x_{ij}≥0，(i,j=1,2,3)$</p></li><li><p>模型求解</p><p>我们将公式简化成Matlab代码</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">C=[15 -25 -15 30 -10 0 40 0 10];A=[-1 1 1 0 0 0 0 0 0;-1 3 -1 0 0 0 0 0 0;0 0 0 -3 1 1 0 0 0;0 0 0 -1 1 -1 0 0 0;1 0 0 1 0 0 1 0 0;0 1 0 0 1 0 0 1 0;0 0 1 0 0 1 0 0 1];b=[0 0 0 0 100 100 60];Aeq= [];beq= [];LB= zeros(9,1);UB= [];[x,fval]= linprog(C,A,b,Aeq,beq,LB,UB);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="模型结果"><a href="#模型结果" class="headerlink" title="模型结果"></a>模型结果</h4><p>运行后结果如下：</p><img src="/2023/03/27/xian-xing-gui-hua/1.jpg" style="zoom:45%;"><p>其中x输出值：<img src="/2023/03/27/xian-xing-gui-hua/2.jpg" style="zoom:45%;">fval输出值为：<img src="/2023/03/27/xian-xing-gui-hua/3.jpg" style="zoom:45%;"></p><p><strong>因此可得出结果：当生产安排为只生产甲产品且按照原材料1量100、原材料2量50、原材料3量50的规格进行制作时总利润最大，此时总利润为500</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> 线性规划 </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性规划</title>
      <link href="/2023/03/27/xian-xing-gui-hua-1/"/>
      <url>/2023/03/27/xian-xing-gui-hua-1/</url>
      
        <content type="html"><![CDATA[<h2 id="线性规划模型作业"><a href="#线性规划模型作业" class="headerlink" title="线性规划模型作业"></a>线性规划模型作业</h2><p>黄芃洋  2021211801班 2021212021</p><h4 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h4><p>设变量$x_{ij}$：产品$i$中的原材料$j$的含量，其中$i$为产品名称(<strong>1</strong>对应<strong>甲</strong>，以此类推)，$j$为原材料名称</p><h4 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h4><p>该问题要求求解利润最大时的生产规划安排，其中利润=收入-成本，我们利用线性规划模型进行求解：</p><ul><li><p>目标函数：</p><p>$max_z=50(x_{11}+x_{12}+x_{13})+35(x_{21}+x_{22}+x_{23})+20(x_{31}+x_{32}+x_{33})-65(x_{11}+x_{21}+x_{31})-25(x_{12}+x_{22}+x_{32})-35(x_{13}+x_{23}+x_{33})$</p><blockquote><p>其中：</p><p>$50(x_{11}+x_{12}+x_{13})+35(x_{21}+x_{22}+x_{23})+20(x_{31}+x_{32}+x_{33})$ 为总收入$65(x_{11}+x_{21}+x_{31})+25(x_{12}+x_{22}+x_{32})+35(x_{13}+x_{23}+x_{33})$为总成本</p></blockquote></li><li><p>约束条件：</p><p>$  x_{11}≥0.5(x_{11}+x_{12}+x_{13})$</p><blockquote><p>对于产品甲，原材料1不少于50%   $ x_{12}+x_{13}-x_{11}≤0$</p></blockquote></li></ul><p>$ x_{12}≤0.25(x_{11}+x_{12}+x_{13})$</p><blockquote><p>对于产品甲，原材料2不超过25%   $3x_{12}-x_{11}-x_{13}≤0$</p></blockquote><p>  $x_{21}≥0.25(x_{21}+x_{22}+x_{23})$</p><blockquote><p>对于产品乙，原材料1不少于25%   $x_{22}+x_{23}-3x_{21}≤0$</p></blockquote><p>  $ x_{22}≤0.5(x_{21}+x_{22}+x_{23})$</p><blockquote><p>对于产品乙，原材料2不超过50%   $x_{22}-x_{21}-x_{23}≤0$</p></blockquote><p>  $x_{11}+x_{21}+x_{31}≤100$</p><blockquote><p>对于原料1，每天最多供应量为100</p></blockquote><p>  $x_{12}+x_{22}+x_{32}≤100$</p><blockquote><p>对于原料2，每天最多供应量为100</p></blockquote><p>  $x_{13}+x_{23}+x_{33}≤60$</p><blockquote><p>对于原料3，每天最多供应量为60</p></blockquote><p>   $x_{ij}≥0，(i,j=1,2,3)$</p><ul><li><p>模型求解</p><p>我们将公式简化成Matlab代码</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">C=[15 -25 -15 30 -10 0 45 5 15];A=[-1 1 1 0 0 0 0 0 0;-1 3 -1 0 0 0 0 0 0;0 0 0 -3 1 1 0 0 0;0 0 0 -1 1 -1 0 0 0;1 0 0 1 0 0 1 0 0;0 1 0 0 1 0 0 1 0;0 0 1 0 0 1 0 0 1];b=[0 0 0 0 100 100 60];Aeq= [];beq= [];LB= zeros(9,1);UB= [];[x,fval]= linprog(C,A,b,Aeq,beq,LB,UB);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="模型结果"><a href="#模型结果" class="headerlink" title="模型结果"></a>模型结果</h4><p>运行后结果如下：</p><p>其中x输出值：<img src="/2023/03/27/xian-xing-gui-hua-1/2.jpg" style="zoom:45%;">fval输出值为：<img src="/2023/03/27/xian-xing-gui-hua-1/3.jpg" style="zoom:45%;"></p><p><strong>因此可得出结果：当生产安排为只生产甲产品且按照原材料1量100、原材料2量50、原材料3量50的规格进行制作时总利润最大，此时总利润为500</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编第一次作业</title>
      <link href="/2023/03/24/hui-bian-di-yi-ci-zuo-ye/"/>
      <url>/2023/03/24/hui-bian-di-yi-ci-zuo-ye/</url>
      
        <content type="html"><![CDATA[<p>过程中遇到的一些问题：</p><p>1.汇编中的movzx和普通的mov有什么区别</p><blockquote><p><code>movzx</code> 指令与普通的 <code>mov</code> 指令有所不同。<code>mov</code> 操作符要求源操作数和目标操作数的大小相同，而 <code>movzx</code> 则要求源操作数的位数小于目标操作数，且目标不能为立即数<a href="https://bing.com/search?q=%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84movzx%E5%92%8C%E6%99%AE%E9%80%9A%E7%9A%84mov%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">1</a><a href="https://www.cnblogs.com/whzym111/p/6364234.html">。这意味着 <code>movzx</code> 可以将较小的源操作数扩展到较大的目标操作数中，而高位会用0来扩展填充</a><a href="https://www.cnblogs.com/whzym111/p/6364234.html">2</a>。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DES密钥编排算法</title>
      <link href="/2023/03/20/des-mi-yao-bian-pai-suan-fa/"/>
      <url>/2023/03/20/des-mi-yao-bian-pai-suan-fa/</url>
      
        <content type="html"><![CDATA[<h4 id="第二题-题目要求"><a href="#第二题-题目要求" class="headerlink" title="第二题-题目要求"></a>第二题-题目要求</h4><blockquote><p>如果16轮使用的子密钥K16＝K1，K15＝K2，…，K9＝K8,</p><p>则加密所用的子密钥与解密所用的子密钥相同,</p><p>对一个明文X加密两次,得到的还是明文X.</p><p>弱密钥的定义：若k使得加密函数与解密函数一致，则称k为弱密钥.</p><p>证明下列密钥为弱密钥（偶校验：就是让原有数据序列中（包括你要加上的一位）1的个数为偶数）：</p><ol><li><p>0x00000000000000       2) 0x1E1E1E1E 0F0F0F0F</p></li><li><p>0x E1E1E1E1F0F0F0F0   4) 0xFFFFFFFFFFFFFF</p></li></ol></blockquote><ul><li><p>0x00000000000000</p><p>由于该密钥的所有位均为0，因此在经过PC-1、左右两部分的循环左亦或是PC-2后，生成的16个子密钥每一位依然为0，因此显然$k_1=k_2=…k_{16}$，因此可以得出结论，<strong>该密钥为弱密钥</strong></p></li><li><p>0x1E1E1E1E 0F0F0F0F</p><p>我们将其进行二进制转换后可以得到64位密钥：0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1</p><p>我们可以利用代码将64位密钥进行PC-1置换，python代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#PC-1# 获取用户输入的数字串arr = input("请输入一串数字，以空格分隔：")arr = arr.split()# 将数字串转换为整数列表arr = [int(x) for x in arr]# 定义规定的顺序order =(57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4)# 按照规定顺序对数字列表进行重排new_arr = [arr[i-1] for i in order]# 输出重排后的数字列表print(new_arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以得到56位密钥：0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1</p><p>我们不难发现前28位密钥都为0，后28位密钥都为1，因此无论如何对前后两段密钥如何循环左移，其左右两部分都保持不变：$C_i=00000…0$,$D_i=11111…1$</p><p>随后我们进行PC-2置换，由于PC-2替换表的替换方式在16轮中保持不变，因此可知$k_1=k_2=…k_{16}$，因此可以得出结论，<strong>该密钥为弱密钥</strong></p></li><li><p>0x E1E1E1E1F0F0F0F0</p><p>我们将其进行二进制转换后可以得到64位密钥：1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0</p><p>我们同样里用代码将其进行PC-1转换可得到56位密钥：1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</p><p>我们不难发现前28位密钥都为1，后28位密钥都为0，因此无论如何对前后两段密钥如何循环左移，其左右两部分都保持不变：$C_i=11111…1$,$D_i=00000…0$</p><p>随后我们进行PC-2置换，由于PC-2替换表的替换方式在16轮中保持不变，因此可知$k_1=k_2=…k_{16}$，因此可以得出结论，<strong>该密钥为弱密钥</strong></p></li><li><p>0xFFFFFFFFFFFFFF</p></li></ul><p>  由于该密钥的所有位均为1，因此其在经过PC-1、左右两部分的循环左亦或是PC-2后，生成的16个子密钥每一位依然为0，因此显然$k_1=k_2=…k_{16}$，因此可以得出结论，<strong>该密钥为弱密钥</strong></p><h4 id="第三题-题目要求"><a href="#第三题-题目要求" class="headerlink" title="第三题-题目要求"></a>第三题-题目要求</h4><blockquote><p>DES的密钥编排：</p><p> 1）统计连续两轮的子密钥有多少密钥比特不相同？</p><p>  2）统计连续两轮的子密钥是否覆盖初始密钥的56比特？ </p></blockquote><ul><li><p><strong>首先我们来统计连续两轮子密钥有多少密钥比特不同</strong>，我们利用PPT中给到的DES密钥编排64转48直接选取表可以编写一个省略生成过程的简易DES密钥编排生成代码，其python代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import randomdef compare_lists(list1, list2):    """比较两个列表中同一位置上不同元素的个数"""    count = 0    for i in range(len(list1)):        if list1[i] != list2[i]:            count += 1    return count#DES密钥编排算法生成子密钥直接轮表table1 = [10,51,34,60,49,17,33,57,2,9,19,42,3,35,26,25,44,58,59,1,36,27,18,41,22,28,39,54,37,4,47,30,5,53,23,29,61,21,38,63,15,20,45,14,13,62,55,31]table2 = [2,43,26,52,41,9,25,49,59,1,11,34,60,27,18,17,36,50,51,58,57,19,10,33,14,20,31,46,29,63,39,22,28,45,15,21,53,13,30,55,7,12,37,6,5,54,47,23]table3 = [51,27,10,36,25,58,9,33,43,50,60,18,44,11,2,1,49,34,35,42,41,3,59,17,61,4,15,30,13,47,23,6,12,29,62,5,37,28,14,39,54,63,21,53,20,38,31,7]table4 = [35,11,59,49,9,42,58,17,27,34,44,2,57,60,51,50,33,18,19,26,25,52,43,1,45,55,62,14,28,31,7,53,63,13,46,20,21,12,61,23,38,47,5,37,4,22,15,54]table5 = [19,60,43,33,58,26,42,1,11,18,57,51,41,44,35,34,17,2,3,10,9,36,27,50,29,39,46,61,12,15,54,37,47,28,30,4,5,63,45,7,22,31,20,21,55,6,62,38]table6 = [3,44,27,17,42,10,26,50,60,2,41,35,25,57,19,18,1,51,52,59,58,49,11,34,13,23,30,45,63,62,38,21,31,12,14,55,20,47,29,54,6,15,4,5,39,53,46,22]table7 = [52,57,11,1,26,59,10,34,44,51,25,19,9,41,3,2,50,35,36,43,42,33,60,18,28,7,14,29,47,46,22,5,15,63,61,39,4,31,13,38,53,62,55,20,23,37,30,6]table8 = [36,41,60,50,10,43,59,18,57,35,9,3,58,25,52,51,34,19,49,27,26,17,44,2,12,54,61,13,31,30,6,20,62,47,45,23,55,15,28,22,37,46,39,4,7,21,14,53]table9 = [57,33,52,42,2,35,51,10,49,27,1,60,50,17,44,43,26,11,41,19,18,9,36,59,4,46,53,55,23,22,61,12,54,39,37,15,47,7,20,14,29,38,31,63,62,13,6,45]table10= [41,17,36,26,51,19,35,59,33,11,50,44,34,1,57,27,10,60,25,3,2,58,49,43,55,30,37,20,7,6,45,63,38,23,21,62,31,34,4,61,13,22,15,47,46,28,53,29]table11= [25,1,49,10,35,3,19,43,17,60,34,57,18,50,41,11,59,44,9,52,51,42,33,27,39,14,21,4,54,53,29,47,22,7,5,46,15,38,55,45,28,6,62,31,30,12,37,13]table12= [9,50,33,59,19,52,3,27,1,44,18,41,2,34,25,60,43,57,58,36,35,26,17,11,23,61,5,55,38,37,13,31,6,54,20,30,62,22,39,29,12,53,46,15,14,63,21,28]table13= [58,34,17,43,3,36,52,11,50,57,2,35,51,18,9,44,27,41,42,49,19,10,1,60,7,45,20,39,22,21,28,15,53,38,4,14,46,6,23,13,63,37,30,62,61,47,5,12]table14= [42,18,1,27,52,49,36,60,34,41,51,9,35,2,58,57,11,25,26,33,3,59,50,44,54,29,4,23,6,5,12,62,37,22,55,61,30,53,7,28,47,21,14,46,45,31,20,63]table15= [26,2,50,11,36,33,49,44,18,25,35,58,19,51,42,41,60,9,10,17,52,43,34,57,38,13,55,7,53,20,63,46,21,6,39,45,14,37,54,12,31,5,61,30,29,15,4,47]table16= [18,59,42,3,57,25,41,36,10,17,27,50,11,43,34,33,52,1,2,9,44,35,26,49,30,5,47,62,45,12,55,38,13,61,31,37,6,29,46,4,23,28,53,22,21,7,63,39]#1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64#arr = input("请输入一串数字，以空格分隔：")#arr = arr.split()# 将数字串转换为整数列表#arr = [int(x) for x in arr]# 随机生成一个只包含0和1的64位列表arr= [random.randint(0, 1) for _ in range(64)]print("本次随机密钥密钥：",arr)print("以下为16轮子密钥：")arr1 =arrnew_arr1 = [arr1[i-1] for i in table1]print(new_arr1)arr2 =arrnew_arr2 = [arr2[i-1] for i in table2]print(new_arr2)count1 = compare_lists(new_arr1, new_arr2)print(f"连续两轮的子密钥有{count1}密钥比特不相同")arr3 =arrnew_arr3 = [arr3[i-1] for i in table3]print(new_arr3)count2 = compare_lists(new_arr2, new_arr3)print(f"连续两轮的子密钥有{count2}密钥比特不相同")arr4 =arrnew_arr4 = [arr4[i-1] for i in table4]print(new_arr4)count3 = compare_lists(new_arr3, new_arr4)print(f"连续两轮的子密钥有{count3}密钥比特不相同")arr5 =arrnew_arr5 = [arr5[i-1] for i in table5]print(new_arr5)count4 = compare_lists(new_arr4, new_arr5)print(f"连续两轮的子密钥有{count4}密钥比特不相同")arr6 =arrnew_arr6 = [arr6[i-1] for i in table6]print(new_arr6)count5 = compare_lists(new_arr5, new_arr6)print(f"连续两轮的子密钥有{count5}密钥比特不相同")arr7 =arrnew_arr7 = [arr7[i-1] for i in table7]print(new_arr7)count6 = compare_lists(new_arr6, new_arr7)print(f"连续两轮的子密钥有{count6}密钥比特不相同")arr8 =arrnew_arr8= [arr8[i-1] for i in table8]print(new_arr8)count7 = compare_lists(new_arr7, new_arr8)print(f"连续两轮的子密钥有{count7}密钥比特不相同")arr9 =arrnew_arr9 = [arr9[i-1] for i in table9]print(new_arr9)count8 = compare_lists(new_arr8, new_arr9)print(f"连续两轮的子密钥有{count8}密钥比特不相同")arr10 =arrnew_arr10 = [arr10[i-1] for i in table10]print(new_arr10)count9 = compare_lists(new_arr9, new_arr10)print(f"连续两轮的子密钥有{count9}密钥比特不相同")arr11 =arrnew_arr11 = [arr11[i-1] for i in table11]print(new_arr11)count10 = compare_lists(new_arr10, new_arr11)print(f"连续两轮的子密钥有{count10}密钥比特不相同")arr12 =arrnew_arr12 = [arr12[i-1] for i in table12]print(new_arr12)count11 = compare_lists(new_arr11, new_arr12)print(f"连续两轮的子密钥有{count11}密钥比特不相同")arr13 =arrnew_arr13 = [arr13[i-1] for i in table13]print(new_arr13)count12 = compare_lists(new_arr12, new_arr13)print(f"连续两轮的子密钥有{count12}密钥比特不相同")arr14 =arrnew_arr14 = [arr14[i-1] for i in table14]print(new_arr14)count13 = compare_lists(new_arr13, new_arr14)print(f"连续两轮的子密钥有{count13}密钥比特不相同")arr15 =arrnew_arr15 = [arr15[i-1] for i in table15]print(new_arr15)count14 = compare_lists(new_arr14, new_arr15)print(f"连续两轮的子密钥有{count14}密钥比特不相同")arr16 =arrnew_arr16 = [arr16[i-1] for i in table16]print(new_arr16)count15 = compare_lists(new_arr15, new_arr16)print(f"连续两轮的子密钥有{count15}密钥比特不相同")aver = (count1+count2+count3+count4+count5+count6+count7+count8+count9+count10+count11+count12+count13+count14+count15)/15print(f"平均连续两轮的子密钥有{aver}密钥比特不相同")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这段代码，我们可以将随机生成的64 bit密钥在输出其16个子密钥的同时计算连续两轮的子密钥的密钥比特差异值的平均值，以下为一个输出实例：</p><blockquote><p>本次随机密钥密钥： [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]<br>以下为16轮子密钥：<br>[1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0]<br>[1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0]<br>连续两轮的子密钥有26密钥比特不相同<br>[0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0]<br>连续两轮的子密钥有25密钥比特不相同<br>[0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0]<br>连续两轮的子密钥有24密钥比特不相同<br>[0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0]<br>连续两轮的子密钥有25密钥比特不相同<br>[0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1]<br>连续两轮的子密钥有25密钥比特不相同<br>[0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1]<br>连续两轮的子密钥有27密钥比特不相同<br>[1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]<br>连续两轮的子密钥有27密钥比特不相同<br>[0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1]<br>连续两轮的子密钥有26密钥比特不相同<br>[1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0]<br>连续两轮的子密钥有25密钥比特不相同<br>[0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1]<br>连续两轮的子密钥有27密钥比特不相同<br>[1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0]<br>连续两轮的子密钥有25密钥比特不相同<br>[1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1]<br>连续两轮的子密钥有25密钥比特不相同<br>[1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1]<br>连续两轮的子密钥有26密钥比特不相同<br>[0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0]<br>连续两轮的子密钥有25密钥比特不相同<br>[1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0]<br>连续两轮的子密钥有25密钥比特不相同<br>平均连续两轮的子密钥有==25.533333333333335==密钥比特不相同</p></blockquote><p><strong>我们在此基础上添加循环，进行十万次实验，统计出连续两轮的子密钥的密钥比特差异值的平均值为23.990703333333055</strong></p><p>因此我们大致能够得出这样的结论：连续两轮的子密钥大约有多少23~24位密钥比特不相同</p></li><li><p><strong>接下来我们来统计连续两轮的子密钥是否覆盖初始密钥的56比特</strong>， 首先我们来确定子密钥覆盖初始密钥的定义：当连续两轮的子密钥中包含了初始密钥中的全部或大部分信息时，我们称之为“子密钥覆盖初始密钥”</p><p>那我们将上面的子密钥生成代码稍作改动，统计连续两轮的子密钥对于初始密钥的56比特的覆盖率</p><p><strong>同样经过十万次计算，我们能够得到平均连续两轮子密钥能够覆盖20.8861251 bit位</strong></p><p>因此我们可以大致得到这样的结论：连续两轮的子密钥还不能覆盖初始密钥的56比特</p></li></ul><p>另外：附上DES密钥编排的完整过程代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt; int subSecretKey[17][48];//16轮的子密钥1-16int leftSecretKey[28]={1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};//进行第一轮置换后的左边秘密钥int rightSecretKey[28]={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};//进行第一轮置换后的右边秘密钥int subLeftSecretKey[24];int subRightSecretKey[24];int s,i,m;//为了数组表示方便，将置换选择2中的位置全部减小1int LP[24] ={13,16,10,23,0,4,2,27,14,5,20,9,22,18,11,3,25,7,15,6,26,19,12,1};//主函数int RP[24] ={40,51,30,36,46,54,29,39,50,44,32,47,43,48,38,55,33,52,45,41,49,35,28,31};int main(){int i,j,t;//16轮的子密钥生成for(i=1; i&lt;=16;i++){if(i==1|| i==2 ||i==9 ||i==16){//循环左移一位int tempLeft = leftSecretKey[0];  int tempRight = rightSecretKey[0];for(j=0; j&lt;27; j++){leftSecretKey[j] = leftSecretKey[j+1];rightSecretKey[j]= rightSecretKey[j+1];}leftSecretKey[27] = tempLeft;rightSecretKey[27] = tempRight;}else {//循环左移两位int tempLeft1 = leftSecretKey[0],tempLeft2 = leftSecretKey[1];        int tempRight1 = rightSecretKey[0],        tempRight2 = rightSecretKey[1];for(j=0; j&lt;26; j++){leftSecretKey[j] = leftSecretKey[j+2];rightSecretKey[j]= rightSecretKey[j+2];}leftSecretKey[26]= tempLeft1;leftSecretKey[27]= tempLeft2;rightSecretKey[26]= tempRight1;rightSecretKey[27]= tempRight2;}//置换，形成subLeftSecretKey[24]，subRightSecretKey[24];for(j=0; j&lt;24; j++){t=LP[j];subLeftSecretKey[j] = leftSecretKey[t];} printf("\n"); for(j=0; j&lt;24; j++){t=RP[j];//注意，由于开始分了两个数组输入，所以这里要减去前面的28位，才是正确的赋值subRightSecretKey[j] = rightSecretKey[t-28];}//输出第i轮的子密钥printf("第%d轮密钥为：",i);for(s=0; s&lt;48; s++){if(s%4==0)printf(" ");if(s&lt;24){subSecretKey[i][s] = subLeftSecretKey[s];printf("%d",subSecretKey[i][s]);}else{subSecretKey[i][s] = subRightSecretKey[s-24];printf("%d",subSecretKey[i][s]);}}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 现代密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代密码学 </tag>
            
            <tag> c语言 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系数据库</title>
      <link href="/2023/03/14/guan-xi-shu-ju-ku/"/>
      <url>/2023/03/14/guan-xi-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h3><hr><blockquote><p><strong>单一的数据结构：关系</strong></p><p>现实世界的实体以及实体间的各种联系均用关系来表示</p><p><strong>逻辑结构：二维表</strong></p><p>从用户角度，关系模型中数据的逻辑结构是一张二维表</p><p><em>建立在集合代数的基础上</em></p></blockquote><ul><li><p><strong>域（Domain）</strong>：一组具有相同数据类型的值的集合</p><ul><li>整数</li><li>实数</li><li>介于某取值范围的整数</li><li>指定长度的字符串集合</li><li>…</li></ul></li><li><p><strong>笛卡尔积（Cartesian Product）</strong>:给定一组域$D_1,D_2,…D_n$，<u>这些域中可以有相同的</u></p><p>$D_1,D_2,…D_n$的笛卡尔积为：<br>$D_1×D_2×..×D_n= ${$(d_1,d_2,…,d_n)|d_i\in D_i,i=1,2,…,n$} </p><p>所有域的所有取值的一个组合</p><blockquote><p>给定两个集合 $A$ 和 $B$，其笛卡尔积 $A \times B$ 定义为由所有有序对 $(a, b)$ 组成的集合，其中 $a \in A$，$b \in B$。也就是说，$A \times B$ 包含所有形如 $(a, b)$ 的有序对，其中 $a$ 是 $A$ 中的元素，$b$ 是 $B$ 中的元素。</p><p>例如，如果 $A = {1, 2}$，$B = {3, 4}$，则 $A \times B$ 包含以下有序对：$(1, 3)$，$(1, 4)$，$(2, 3)$ 和 $(2, 4)$。</p></blockquote><p><em><strong>不能重复</strong></em></p><ul><li><p>元组（Tuple）：</p><p>笛卡尔积中每一个元素$(d_1,d_2,…,d_n)$叫作一个n元组（n-tuple）或简称元组(Tuple)</p><blockquote><p>(张清玫，计算机专业，李勇)、(张清玫，计算机专业，刘晨)等都是元组 </p></blockquote></li><li><p>分量（Component）：</p><p>笛卡尔积元素$(d_1,d_2,…,d_n)$中的每一个值$d_i$叫作一个分量</p><blockquote><p>张清玫、计算机专业、李勇、刘晨等都是分量 </p></blockquote></li><li><p>基数（Cardinal number）：</p><p>若$D_i(i＝1，2，…，n)$为有限集，其基数为$m_i(i＝1,2,…,n)$，则$D_1×D_2×..×D_n$的基数$M$为</p><p>$M=\prod_{i=1}^n{m_i} $</p></li></ul><blockquote><p>例：设</p><p>$D_1$为教师集合（T）= {t1，t2}</p><p>$D_2$为专业集合（S）= {s1，s2 ，s3}      </p><p>$D_3$为研究生集合（P）= {p1，p2}</p><p>则$D_1×D_2×D_3$是个三元组集合，元组个数为$2\times3\times2$，是所有可能的（教师，专业，研究生）元组集合</p><img src="/2023/03/14/guan-xi-shu-ju-ku/1.jpg" style="zoom:60%;"></blockquote></li><li><p><strong>关系（Relation）</strong>:</p><p>$D_1，D_2，…，D_n$的笛卡尔积的某个<strong>子集</strong>才有实际含义，例如上面所示的笛卡尔积，只有取出有实际意义的元组来构造关系</p><ul><li><p>关系</p><p>$D_1×D_2×..×D_n$的子集叫作在域$D_1，D_2，…，D_n$上的关系，表示为</p><p>$R（D1，D2，…，Dn）$</p><ul><li>$R$：关系名</li><li>$n$：关系的目或度（Degree）</li></ul></li><li><p>元组</p><p>关系中的每个元素是关系中的元组，通常用t表示</p></li><li><p>单元关系与二元关系</p></li><li><p>当n=1时，称该关系为单元关系（Unary relation）或一元关系</p></li><li><p>当n=2时，称该关系为二元关系（Binary relation）</p></li><li><p>关系的表示</p><p>关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域</p><img src="/2023/03/14/guan-xi-shu-ju-ku/2.jpg" style="zoom:60%;"></li><li><p>属性</p><p>关系中不同列可以对应相同的域</p><p>为了加以区分，必须对每列起一个名字，称为属性（Attribute）</p><p>n目关系必有n个属性</p></li><li><p>码</p><ul><li><p>候选码（Candidate key）</p><p>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码</p><p>简单的情况：候选码只包含一个属性</p></li><li><p>全码（All-key）</p><p>最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</p></li><li><p>主码</p><p>若一个关系有多个候选码，则选定其中一个为主码（Primary key）</p></li><li><p>主属性</p><p>候选码的诸属性称为主属性（Prime attribute）不包含在任何侯选码中的属性称为非主属性（ Non-Prime attribute）或非码属性（Non-key attribute）</p></li></ul><blockquote><p>例：哪些属性是候选码、主码、主/非主属性？（假设学生没有重名）</p><p>学生（**<u>学号</u><strong>，</strong>姓名**，性别，班号）</p><p>选课（**<u>学号</u><strong>，</strong><u>课程号</u>**，成绩）</p></blockquote></li><li><p>三类关系</p><ul><li><p>基本关系（基本表或基表）</p><p>实际存在的表，是实际存储数据的逻辑表示</p></li><li><p>查询表</p><p>查询结果对应的表</p></li><li><p>视图表</p><p>由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</p></li><li><p>基本关系的性质</p></li></ul></li><li><p>基本关系的性质</p><ul><li>列是同质的（Homogeneous）</li><li>不同的列可出自同一个域，用属性名区分</li><li>列的顺序无所谓，列的次序可以任意交换</li><li>任意两个元组的候选码不能相同</li><li>行的顺序无所谓，行的次序可以任意交换</li><li>分量必须取原子值</li></ul><img src="/2023/03/14/guan-xi-shu-ju-ku/3.jpg" style="zoom:60%;"></li></ul></li><li><p><strong>关系模式</strong>：</p><p>是<strong>型</strong>，是对关系的静态、稳定描述，包括：</p><ul><li>元组集合的结构</li><li>元组语义以及完整性约束条件</li><li>属性间的数据依赖关系集合</li></ul><p><em>关系模式可以形式化地表示为</em>：$R（U，D，DOM，F）$</p><ul><li>$R$         关系名</li><li>$U$         组成该关系的属性名集合</li><li>$D  $         属性组$U$中属性所来自的域</li><li>$DOM$ 属性向域的映象集合</li><li>$F$         属性间的数据依赖关系集合</li></ul><blockquote><p>例:  </p><p>导师和研究生出自同一个域——人，取不同的属性名，并在模式中定义属性向域的映象：  </p><p>DOM（SUPERVISOR）= PERSON，DOM（POSTGRADUATE）= PERSON</p></blockquote><p><em>关系模式通常可以简记为</em> :$R (U) $   或   $ R (A_1，A_2，…，A_n)$</p><ul><li>$R$: 关系名</li><li>$A_1，A_2，…，A_n $ : 属性名</li></ul><blockquote><p>注：</p><p>域名及属性向域的映象常常直接说明为<strong>属性的类型、长度</strong></p><p>例如：学生（学号，姓名，性别，班号）</p></blockquote></li><li><p><strong>关系数据库的型与值</strong></p><ul><li><p>关系数据库的型：关系数据库模式，对关系数据库的描述，包括</p><ul><li>若干域的定义</li><li>在这些域上定义的若干关系模式</li></ul></li><li><p>关系数据库的值: 关系模式在某一时刻对应的关系的集合，简称为关系数据库</p><blockquote><p>例如选课数据库的模式：</p><p>学生（学号，姓名，性别，班号）</p><p>选课（学号，课程号，成绩）</p><p>课程（课程号，课程名，学分）</p></blockquote></li></ul></li></ul><hr><h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><hr><ul><li><strong>基本关系操作</strong><ul><li>常用的关系操作<ul><li>查询：选择、投影、连接、除、并、交、差</li><li>数据更新：插入、删除、修改</li><li>查询的表达能力是其中最主要的部分</li><li>选择、投影、并、差、笛卡尔基是5种基本操作</li></ul></li><li>关系操作的特点<ul><li>集合操作方式：操作的对象和结果都是集合，<em><strong>一次一集合</strong></em>的方式</li><li>高度非过程化：只要指出“做什么”，不需要描述“怎么做”</li></ul></li></ul></li><li><strong>关系数据库语言的分类</strong><ul><li>关系代数语言<ul><li>用对关系的运算来表达查询要求</li><li>代表：ISBL</li></ul></li><li>关系演算语言：用谓词来表达查询要求<ul><li>域关系演算语言 <ul><li>谓词变元的基本对象是域变量</li><li>代表：QBE</li></ul></li><li>元组关系演算语言<ul><li>谓词变元的基本对象是元组变量</li><li>代表：APLHA, QUEL</li></ul></li></ul></li><li>关系代数和关系演算是相互等价的</li><li>具有关系代数和关系演算双重特点的语言<ul><li>代表：SQL（Structured Query Language）</li></ul></li></ul></li></ul><hr><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><hr><ul><li><p><strong>概述</strong></p><ul><li><p>什么是关系代数？</p><ul><li>关系数据库的一种抽象的查询语言，用对关系的运算来表达查询。</li><li>关系代数<ul><li>运算对象：关系</li><li>运算符：关系运算符</li></ul></li><li>代数的要素：运算对象、运算符。<ul><li>运算符连接运算对象和/或表达式形成表达式</li></ul></li></ul></li><li><p>为什么要学关系代数？</p><ul><li>已不用作商用RDBMS的查询语言，但SQL语言以关系代数作为核心</li><li>RDBMS处理查询时，首先将SQL查询翻译成关系代数或相似的内部表示</li></ul><img src="/2023/03/14/guan-xi-shu-ju-ku/4.jpg" style="zoom:60%;"></li></ul></li><li><p><strong>传统的集合运算</strong></p><ul><li><p>并</p><ul><li><p>R和S</p><ul><li>具有相同的目n（即两个关系都有n个属性）</li><li>相应的属性取自同一个域</li></ul></li><li><p>R∪S </p><ul><li><p>仍为n目关系，由属于R或属于S的元组组成</p><p>$R∪S =$ { $t|t \in R ∨ t \in S $}</p></li></ul></li></ul><img src="/2023/03/14/guan-xi-shu-ju-ku/5.jpg" style="zoom:60%;"></li><li><p>交</p><ul><li><p>R和S</p><ul><li>具有相同的目n</li><li>相应的属性取自同一个域</li></ul></li><li><p>R∩S</p><ul><li><p>仍为n目关系，由既属于R又属于S的元组组成</p><p>$R∩S =$ { $t|t \in R ∧ t \in S $}</p></li></ul></li></ul><img src="/2023/03/14/guan-xi-shu-ju-ku/6.jpg" style="zoom:60%;"></li><li><p>差</p><ul><li><p>R和S</p><ul><li>具有相同的目n</li><li>相应的属性取自同一个域</li></ul></li><li><p>R - S </p><ul><li><p>仍为n目关系，由属于R而不属于S的所有元组组成</p><p>$R-S =$ { $t|t \in R ∧ t \notin S $}</p></li></ul></li></ul><img src="/2023/03/14/guan-xi-shu-ju-ku/7.jpg" style="zoom:60%;"></li><li><p>笛卡尔积</p><ul><li><p>严格地讲应该是广义的笛卡尔积</p></li><li><p>R: n目关系，k1个元组</p></li><li><p>S: m目关系，k2个元组</p></li><li><p>R×S </p><ul><li>列：（n+m）列元组的集合<ul><li>元组的前n列是关系R的一个元组</li><li>后m列是关系S的一个元组</li></ul></li><li>行：k1×k2个元组<ul><li>$R\times S =$ { $t_rt_s|t_r \in R ∧ t_s \in S $}</li></ul></li></ul><img src="/2023/03/14/guan-xi-shu-ju-ku/8.jpg" style="zoom:60%;"></li></ul></li></ul></li><li><p><strong>专门的关系运算</strong></p><ul><li><p>选择运算</p><ul><li><p>在关系R中选择满足给定条件的<strong>元组</strong></p><p>$\sigma_{F(R)}$$=${$t | t \in R ^{F(t)} = 真$}</p></li><li><p>F是选择的条件，$\forall t\in R$，F(t)要么为真，要么为假</p><ul><li>F的形式：由逻辑运算符$( \vee,\wedge,\neg)$连接关系表达式而成</li></ul></li><li><p>关系表达式：$X \theta Y$</p></li><li><p>X，Y是属性名、常量、或简单函数</p></li><li><p>$\theta$是比较算符，$\theta \in${$\leq,\geq,\neq,=,&gt;,&lt;  $}</p></li></ul><blockquote><p>例如：</p><img src="/2023/03/14/guan-xi-shu-ju-ku/9.jpg" style="zoom:30%;"><p>再如：</p><p>找年龄不小于20的男学生</p><img src="/2023/03/14/guan-xi-shu-ju-ku/10.jpg" style="zoom:30%;"><p>又如：</p><p>查找信息系（IS系）的全体学生</p><img src="/2023/03/14/guan-xi-shu-ju-ku/11.jpg" style="zoom:30%;"></blockquote></li><li><p>投影</p><p>从关系R中取若干列组成新的关系（<strong>从列的角度</strong>）</p><p>$\Pi^{A(R)} = ${ $t[A]  | t\in R $} $, A\subseteq R$</p><p>其中A为R的属性列</p><p><u><em>投影的结果中要去掉相同的行</em></u></p><blockquote><p>例如：</p><img src="/2023/03/14/guan-xi-shu-ju-ku/12.jpg" style="zoom:30%;"></blockquote></li><li><p>选择与投影的对比</p><ul><li><p>选择运算是从关系R中选取使逻辑表达式F为真的元组，是从行的角度进行的运算</p><img src="/2023/03/14/guan-xi-shu-ju-ku/13.jpg" style="zoom:60%;"></li><li><p>投影操作主要是从列的角度进行运算</p><img src="/2023/03/14/guan-xi-shu-ju-ku/14.jpg" style="zoom:60%;"></li></ul><blockquote><p>例如：找95001号学生所选修的课程号$\Pi_{Cno}(\sigma_{Sno=95001}(SC))$</p><img src="/2023/03/14/guan-xi-shu-ju-ku/15.jpg" style="zoom:60%;"></blockquote></li><li><p>连接</p><p>连接操作是从两个关系的广义<strong>笛卡尔积</strong>中选择属性间满足一定条件的<strong>元组</strong>。通常写为：</p><p>$R \Join S <em>{A\theta B}= \sigma</em>{R.A\theta S.B}(R\times S)$</p><p>A,B为R和S上度数相等且可比的属性列，$\theta$为比较运算符</p><blockquote><p>例如：</p><img src="/2023/03/14/guan-xi-shu-ju-ku/16.jpg" style="zoom:30%;"></blockquote><ul><li><p>θ为“＝”的连接运算称为<strong>等值连接</strong> ：</p><p>等值连接的含义：从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组，即等值连接为：</p><p>$R \Join S _{A= B}=${ $   t_rt_s      | t_r \in R ∧ t_s \in S ∧ t_r[A] = t_s[B] $}  </p></li><li><p>若R和S具有相同的属性组（来自相同的域，表示相同的含义），且连接的运算符θ为“=”，并且在连接的结果中<strong>去掉重复的属性组</strong>，这种连接称为<strong>自然连接</strong>:</p><p>记为：</p><p>$R \Join S$   (当R与S无相同属性时，$R \Join S$ ＝$ R×S$)</p></li></ul><img src="/2023/03/14/guan-xi-shu-ju-ku/17.jpg" style="zoom:30%;"><ul><li><p>外连接</p><p>如果把舍弃的元组也保存在结果关系中，而在其他属性上填空值(Null)，这种连接就叫做外连接（OUTER JOIN）。</p></li><li><p>左外连接</p><p>如果只把左边关系R中要舍弃的元组保留就叫做左外连接(LEFT OUTER JOIN或LEFT JOIN)</p></li><li><p>右外连接</p><p>如果只把右边关系S中要舍弃的元组保留就叫做右外连接(RIGHT OUTER JOIN或RIGHT JOIN)</p><img src="/2023/03/14/guan-xi-shu-ju-ku/18.jpg" style="zoom:60%;"><blockquote><p>一般的连接操作是从行的角度进行运算。</p><p>   ​    <img src="/2023/03/14/guan-xi-shu-ju-ku/19.jpg" style="zoom:60%;"></p><p>自然连接还需要<strong>取消重复列</strong>，所以是同时从行和列的角度进行运算。 </p></blockquote><p><u><em>同样是对两个关系进行合并操作，连接运算和集合交/并运算有何区别？</em></u></p><blockquote><p>连接运算是基于两个关系之间的共同属性进行操作的。连接运算将两个关系中满足某种条件的元组组合起来形成一个新的关系。连接运算常用的有内连接、外连接、自然连接等。连接运算的结果是两个关系的交集，但是只包含那些满足连接条件的元组。连接运算的目的是为了寻找关系之间的联系，以便进行数据的查询和分析。</p><p>集合交/并运算是将两个关系中的元组进行组合，形成一个新的关系。集合交/并运算的结果是两个关系的交集或并集。集合运算中的交集操作得到的结果是两个关系中共同元素的集合，而并集操作得到的结果是两个关系中所有元素的集合。集合运算的目的是为了去除重复元素或者将多个数据源合并成一个数据源，以便进行数据分析或处理。</p></blockquote><p> <strong>一些方法：</strong></p><p> ==单表第一步先选择，第二步再投影==</p><p> ==多表先选再连后投影==</p></li></ul></li><li><p>象集</p><p>关系R(X , Z), X, Z是属性组，x是X上的取值，定义x在R中的象集为</p><p>$Z_X${ $   t_{[Z] }    | t \in R ∧ t_{[X]} =X $}  </p><p>从R中选出在X上取值为x的元组，去掉X上的分量，只留Z上的分量</p><img src="/2023/03/14/guan-xi-shu-ju-ku/20.jpg" style="zoom:60%;"></li><li><p>除运算</p><p>给定关系R（X，Y）和S（Y，Z），其中X，Y，Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的值域。</p><p>R与S的除运算得到一个新的关系P（X），P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。记做：</p><p>$R \div S =${ $   t_r[X]      | t_r \in R ∧ \Pi_Y(S)\subseteq Y_X $}  </p><blockquote><p>例：<img src="/2023/03/14/guan-xi-shu-ju-ku/21.jpg" style="zoom:60%;"></p></blockquote><blockquote><p>例: 查询选修了全部课程的学生号码和姓名</p><img src="/2023/03/14/guan-xi-shu-ju-ku/22.jpg" style="zoom:60%;"></blockquote><blockquote><p>例：查询至少选修1号课程和3号课程的学生号码</p><img src="/2023/03/14/guan-xi-shu-ju-ku/23.jpg" style="zoom:60%;"></blockquote></li><li><p>重命名运算</p><p>关系代数运算的结果没有可供引用的名字，使得复杂的查询显得非常冗长</p><p>用小写希腊字母$\rho$表示的命名运算可对关系更名，或赋予关系代数运算结果一个名字：</p><p>对给定的关系代数表达式E，表达式$\rho_ x(E)$返回表达式E的结果，并把名字x赋给了它。</p><p>假设关系代数表达式E是n元的，则表达式：$\rho_ {x(A_1,A_2,…,A_n)}(E)$</p><p>返回表达式E的结果，并赋给它名字x，同时将E的各属性更名为$A_1,A_2,…,A_n$</p><blockquote><p>例：</p><img src="/2023/03/14/guan-xi-shu-ju-ku/24.jpg" style="zoom:60%;"><p>1.查询至少出现在两款PC中的硬盘容量</p><p>$\Pi_{PC1.hd}(\rho_{PC1}(PC) \Join <em>{PC1.hd=PC2.hd\wedge PC1.model\neq PC2.model }\rho</em>{PC2}(PC) )$</p><p>注释：</p><ol><li>$\rho_{PC1}(PC)$: 对关系PC 进行重命名操作，将其重命名为PC1</li><li>$\rho_{PC2}(PC)$: 对关系PC 进行重命名操作，将其重命名为PC2</li><li>$PC1 \Join_{PC1.hd=PC2.hd\wedge PC1.model\neq PC2.model} PC2$: 对重命名后的PC1和PC2进行自然连接操作，连接条件为PC1.hd等于PC2.hd并且PC1.model不等于PC2.model</li><li>$\Pi_{PC1.hd}(\cdot)$：对连接结果进行投影操作，只保留PC1.hd属性</li></ol><p>因此，最终的关系代数表达式表示的是：从关系PC中选择两个不同型号但硬盘容量相同的计算机，仅保留它们的硬盘容量属性，并且重命名为PC1.hd</p><p>2.查询至少生产两款不同速度PC的制造商</p><p>$\Pi_{R1.maker}(\rho_{R1}(Product \Join PC) \Join <em>{R1.speed\neq R2.speed\wedge R1.maker= R2.maker }\rho</em>{R2}(Product \Join PC) )$</p><p>注释：</p><ol><li>$\rho_{R1}(Product \Join PC)$: 将关系Product和PC进行自然连接操作，并将结果重命名为R1。</li><li>$\rho_{R2}(Product \Join PC)$: 将关系Product和PC进行自然连接操作，并将结果重命名为R2。</li><li>$R1 \Join_{R1.speed\neq R2.speed\wedge R1.maker= R2.maker} R2$: 对重命名后的R1和R2进行自然连接操作，连接条件为R1.speed不等于R2.speed并且R1.maker等于R2.maker。</li><li>$\Pi_{R1.maker}(\cdot)$: 对连接结果进行投影操作，只保留R1.maker属性。</li></ol><p>因此，最终的关系代数表达式表示的是：从关系Product和PC中选择制造商相同，但是速度不同的产品，仅保留它们的制造商属性，并将结果重命名为R1.maker。</p></blockquote></li></ul></li></ul><hr><h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><hr><ul><li><p><strong>关系的三类完整性约束</strong></p><ul><li><p>实体完整性和参照完整性：</p><p>关系模型必须满足的完整性约束条件     </p><p>称为关系的两个<strong>不变性</strong>，应该由关系系统自动支持</p></li><li><p>用户定义的完整性：   </p><p>应用领域需要遵循的约束条件，体现了具体领域中的语义约束</p></li></ul></li><li><p><strong>实体完整性</strong></p><p>若属性A是基本关系R的主属性，则属性A不能取空值</p><blockquote><p>例如：</p><p>SAP(SUPERVISOR，SPECIALITY，POSTGRADUATE)</p><p>POSTGRADUATE：</p><p>主码（假设研究生不会重名）</p><p>不能取空值</p></blockquote><p> 实体完整性规则是针对基本关系而言的</p><ul><li>一个基本表通常对应现实世界的一个实体集。</li><li>现实世界中的实体是可区分的，即它们具有某种唯一性标识。</li><li>关系模型中以主码作为唯一性标识。</li><li>主码中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第2点相矛盾，因此这个规则称为实体完整性</li></ul></li><li><p><strong>参照完整性</strong></p><ul><li><p>关系间的引用</p><p>在关系模型中实体及实体间的联系都是用关系来描述的，因此可能存在着关系与关系间的引用</p><blockquote><p>例1：</p><p>学生实体、专业实体</p><p>学生（<em><strong>学号</strong></em>，姓名，性别，专业号，年龄）　专业（<em><strong>专业号</strong></em>，专业名）</p><p>注：<em><strong>主码</strong></em></p><p>学生关系引用了专业关系的主码“专业号”。 </p><p>学生关系中的“专业号”值必须是确实存在的专业的专业号 ，即专业关系中有该专业的记录。</p><p>例2：</p><p>学生、课程、学生与课程之间的多对多联系</p><p>学生（<strong>学号</strong>，姓名，性别，专业号，年龄）     </p><p>课程（<strong>课程号</strong>，课程名，学分）     </p><p>选修（<strong>学号</strong>，<strong>课程号</strong>，成绩）</p><p>例3：</p><p>学生实体及其内部的一对多联系  </p><p>学生（学号，姓名，性别，专业号，年龄，班长）</p><p>“学号”是主码，“班长”是外码，它引用了本关系的“学号”</p><p> “班长” 必须是确实存在的学生的学号 </p></blockquote></li><li><p>外码</p><p>设F是基本关系R的一个或一组属性，但不是关系R的码。</p><p>如果F与基本关系S的主码$K_s$相对应，则称F是基本关系R的外码</p><p>基本关系R称为参照关系（Referencing  Relation）</p><p>基本关系S称为被参照关系（Referenced Relation）或目标关系（Target Relation）</p><blockquote><p>例1：学生关系的“专业号”与专业关系的主码“专业号”相对应</p><p>“专业号”属性是学生关系的外码</p><p>专业关系是被参照关系，学生关系为参照关系 </p><img src="/2023/03/14/guan-xi-shu-ju-ku/25.jpg" style="zoom:60%;"> <p>例2：选修关系的“学号” 与学生关系的主码“学号”相对应 </p><p>选修关系的“课程号”与课程关系的主码“课程号”相对应</p><p>“学号”和“课程号”是选修关系的外码</p><p>学生关系和课程关系均为被参照关系选</p><p>修关系为参照关系 </p><img src="/2023/03/14/guan-xi-shu-ju-ku/26.jpg" style="zoom:60%;"> <p>例3：“班长”与本身的主码“学号”相对应</p><p>“班长”是外码</p><p>学生关系既是参照关系也是被参照关系 </p><img src="/2023/03/14/guan-xi-shu-ju-ku/27.jpg" style="zoom:43%;"></blockquote><p>关系R和S不一定是不同的关系</p><p>目标关系S的主码Ks 和参照关系的外码F必须定义在同一个（或一组）域上</p><p>外码并不一定要与相应的主码同名</p><p>当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别</p></li><li><p>参照完整性规则</p><p>若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：</p><ul><li>或者取空值（F的每个属性值均为空值）</li><li>或者等于S中某个元组的主码值</li></ul><blockquote><p>例1：学生关系中每个元组的“专业号”属性只取两类值：</p><p>空值，表示尚未给该学生分配专业</p><p>非空值，这时该值必须是专业关系中某个元组的“专业号”值，表示该学生不可能分配一个不存在的专业</p><p>例2：选修（学号，课程号，成绩）        </p><p> “学号”和“课程号”可能的取值 ：</p><p>选修关系中的主属性，不能取空值</p><p>只能取相应被参照关系中已经存在的主码值</p><p>例3：学生（学号，姓名，性别，专业号，年龄，班长）         </p><p>“班长”属性值可以取两类值：</p><p>（1）空值，表示该学生所在班级尚未选出班长</p><p>（2）非空值，该值必须是本关系中某个元组的学号值</p></blockquote></li><li><p>用户定义的完整性</p><ul><li><p>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</p></li><li><p>关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不要由应用程序承担这一功能</p></li></ul><blockquote><p>例子：</p><p>课程(课程号，课程名，学分)</p><p>“课程号”属性必须取唯一值</p><p>非主属性“课程名”也不能取空值</p><p>“学分”属性只能取值{1，2，3，4，5}</p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/2023/03/13/ying-yong-ceng/"/>
      <url>/2023/03/13/ying-yong-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><hr><h4 id="客户-x2F-服务器（c-x2F-s）模型"><a href="#客户-x2F-服务器（c-x2F-s）模型" class="headerlink" title="客户/服务器（c/s）模型"></a>客户/服务器（c/s）模型</h4><img src="/2023/03/13/ying-yong-ceng/1.jpg" style="zoom:67%;"><ul><li><strong>服务器</strong>：提供计算服务的设备<ul><li>永久提供服务</li><li>永久性访问地址、域名</li></ul></li><li><strong>客户机</strong>：请求计算服务的主机<ul><li>与服务器通信，使用服务器提供服务</li><li>间接性接入网络</li><li>可能使用动态IP地址</li><li>不与其他客户机直接通信</li></ul></li></ul><p><strong>应用</strong>：web、文件传输FTP、远程登录、电子邮件</p><hr><h4 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h4><img src="/2023/03/13/ying-yong-ceng/2.jpg" style="zoom:67%;"><ul><li><p>不存在永远在线的服务器</p></li><li><p>每个主机既可以<strong>提供服务</strong>，也可以<strong>请求服务</strong></p></li><li><p>任意端系统/节点之间可以<strong>直接通讯</strong></p></li><li><p>节点间歇性接入网络</p></li><li><p>节点可能改变IP地址</p></li><li><p>可扩展性好</p></li><li><p>网络健壮性强</p></li></ul><hr><h3 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h3><img src="/2023/03/13/ying-yong-ceng/3.jpg" style="zoom:37%;"><hr><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><blockquote><p>例如：<strong><a href="http://www.cskaoyan.com/">www.cskaoyan.com</a></strong></p><ul><li>www：三级域名</li><li>cskaoyan：二级域名</li><li>com：顶级域名</li></ul></blockquote><img src="/2023/03/13/ying-yong-ceng/4.jpg" style="zoom:37%;"><ul><li><strong>顶级域名</strong>：<ul><li>国家顶级域名：cn、uk、us</li><li>通用顶级域名：com、net、org、gov、int</li><li>基础结构域名/返向域名：arpa</li></ul></li><li><strong>二级域名</strong>：<ul><li>类别域名：ac、com、edu、gov、mil、net</li><li>行政区域名：用于我国各省、自治区、直辖市：bj、js</li><li>注册域名：cctv、cskaoyan</li></ul></li><li><strong>三级域名</strong>、<strong>四级域名</strong>…</li></ul><hr><h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><ul><li><strong>根域名服务器</strong></li><li><strong>顶级域名服务器</strong>：管理该顶级域名服务器注册的所有二级域名</li><li><strong>权限域名服务器</strong>：负责一个区的域名服务器</li><li><strong>本地域名服务器</strong>：当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超递增背包算法</title>
      <link href="/2023/03/11/chao-di-zeng-bei-bao-suan-fa/"/>
      <url>/2023/03/11/chao-di-zeng-bei-bao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><blockquote><p> 超递增背包问题：<br>设$A=(a_1,a_2…,a_3)$是由$n$个不同的正整数构成的$n$元组，且 $a_j&gt;\sum_{j=1}^{j-1}{a_i} (j=2,…,n)$<br>$S$是另一已知的正整数。<br>求$A$的子集$A$’，使 $\sum_{a_i \in A’}{a_i}=S$</p></blockquote><ul><li><p>求解算法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXN 100int n,S;int a[MAXN],sum[MAXN];int ans[MAXN],top;void algorithm(int i,int tot) {    if(tot&gt;S)return;     if(i==n) {        if(tot==S){             printf("找到结果:");            for (int j = 0; j &lt; top; j++) {                printf("%d ", ans[j]);            }            printf("\n");        }        return;    } if (tot==S) {     printf("找到结果:");    for(int j=0;j&lt;top;j++){        printf("%d ",ans[j]);    }    printf("\n");    return;}    ans[top++]=a[i];     algorithm(i+1,tot+a[i]);    top--;    algorithm(i+1,tot);}int main(){    printf("请输入A元素个数:");    scanf("%d", &amp;n);    printf("请输入S:");    scanf("%d", &amp;S);    printf("请输入A中元素:\n");    for (int i=0;i&lt;n;i++) {        scanf("%d",&amp;a[i]);    }    sum[0]=a[0];    for(int i=1;i&lt;n;i++) {        sum[i]=sum[i-1]+a[i];    }    printf("找到结果:\n");    algorithm(0, 0);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>计算复杂度为$O(2^n)$</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 现代密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代密码学 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>维吉尼亚密码的惟密文攻击</title>
      <link href="/2023/03/08/wei-ji-ni-ya-mi-ma-de-wei-mi-wen-gong-ji/"/>
      <url>/2023/03/08/wei-ji-ni-ya-mi-ma-de-wei-mi-wen-gong-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><blockquote><p>已知下列密文是通过维吉尼亚密码加密得来的，试求其明文。</p><p>Per zlrracm, vxmcs r qipqlczhs. Qs fcv rihw sxxhblrxh sm nkidhvzphw. Ixxvn qsn, lysh sifecs uuijrrfyg, mk xj suvc kd ss wbrzrrz uqh jpp zyw qv ylgn osfz fin isi bpgyoj, fg dm zdqzap, cl sifecsqks cdfy iu xyxey iu tipp zcni dt. Sin lj nt rfy jszcxhi jik iyfixky iysmh hzuwwwxpk izayv; mw lv olhkfxeu nr gitrhy d afgcr qkiit vjyucsdum bdw kwvcjssiilbcwc kd wwhg e ads, ohg ewuffx fscavuy; ljnt rfy jszcx hi vemt kvy hrmxichpiei rbx giwtrhzxxlgv duqhvbzqm, wlvc ns uui xdzba ws ypmsnr hf xk hijikwvf.</p></blockquote><p>由于密钥未知，我们采用惟密文攻击。解密方式为重合指数法确定分组m，再利用拟重合指数法得到每个单表密钥。</p><p>鉴于计算过程过于繁琐，我采用C语言代码辅助计算。</p><ul><li>首先，我将密文整理成无空格、均小写的格式，方便计算。</li></ul><blockquote><p>perzlrracmvxmcsrqipqlczhsqsfcvrihwsxxhblrxhsmnkidhvzphwixxvnqsnlyshsifecsuuijrrfygmkxjsuvckdsswbrzrrzuqhjppzywqvylgnosfzfinisibpgyojfgdmzdqzapclsifecsqkscdfyiuxyxeyiutippzcnidtSinljntrfyjszcxhijikiyfixkyiysmhhzuwwwxpkizayvmwlvolhkfxeunrgitrhydafgcrqkiitvjyucsdumbdwkwvcjssiilbcwckdwwhgeadsohgewufffscavuyljntrfyjszcxhivemtkvyhrmxichpieirbxgiwtrhzxxlgvduqhvbzqmwlvcnsuuixdzbawsypmsnrhfxkhijikwvf</p></blockquote><ul><li>接下来进行文本的重合指数运算部分，推测出m分组数。以下为代码实现：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">//文本的重合指数运算部分 #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; //分组 char* apart(char text[],int lines,int point){ char newtext[1000]="";int length=strlen(text);int num=0;for(int i=0;i&lt;length;i++){if(i%lines==0){newtext[num]=text[i+point];num++;}}newtext[num]='\0';//printf("%s  ",newtext);return newtext;}int main(){char mess[1000]="";char *text[300];int lines=1; printf("请输入文本内容:\n");scanf("%[^\n]", mess);for(lines;lines&lt;30;lines++){double averCI=0;printf("当分组m为%d时:\n",lines);for (int i=0;i&lt;lines;i++){          text[i] = (char *)malloc(1000 * sizeof(char));           strcpy(text[i],apart(mess,lines,i));        }    for(int j=0;j&lt;lines;j++){      int length=strlen(text[j]);      double CI=0;          for (int p=97;p&lt;123;p++){            int count = 0;            for (int q=0;q&lt;length;q++){              if(text[j][q]==p){                    count++;              }            }              if(count&gt;1){                CI+=(double(count)/length)*((double(count)-1)/(length-1));              }          }          averCI+=CI;          if(j!=lines-1)printf("%lf ",CI);          else printf("%lf\n",CI);    }       printf("当m为%d时平均CI为%lf\n",lines,averCI/lines);} } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 我将代码得出的<strong>结果</strong>、<strong>截图</strong>与<strong>结论</strong>放在下方：</p><blockquote><p><em><strong>结果：</strong></em></p><p>请输入文本内容:<br>perzlrracmvxmcsrqipqlczhsqsfcvrihwsxxhblrxhsmnkidhvzphwixxvnqsnlyshsifecsuuijrrfygmkxjsuvckdsswbrzrrzuqhjppzywqvylgnosfzfinisibpgyojfgdmzdqzapclsifecsqkscdfyiuxyxeyiutippzcnidtSinljntrfyjszcxhijikiyfixkyiysmhhzuwwwxpkizayvmwlvolhkfxeunrgitrhydafgcrqkiitvjyucsdumbdwkwvcjssiilbcwckdwwhgeadsohgewufffscavuyljntrfyjszcxhivemtkvyhrmxichpieirbxgiwtrhzxxlgvduqhvbzqmwlvcnsuuixdzbawsypmsnrhfxkhijikwvf<br>当分组m为1时:<br>0.042934<br>当m为1时平均CI为0.042934<br>当分组m为2时:<br>0.038641 0.047654<br>当m为2时平均CI为0.043147<br>当分组m为3时:<br>0.040481 0.039107 0.046271<br>当m为3时平均CI为0.041953<br>当分组m为4时:<br>0.040816 0.048237 0.036819 0.042920<br>当m为4时平均CI为0.042198<br>当分组m为5时:<br>0.037975 0.035054 0.048036 0.044142 0.040293<br>当m为5时平均CI为0.041100<br>当分组m为6时:<br>0.039627 0.043823 0.034033 0.043357 0.035096 0.053846<br>当m为6时平均CI为0.041630<br>当分组m为7时:<br>0.043860 0.049499 0.050649 0.053896 0.050000 0.051948 0.055844<br>当m为7时平均CI为0.050814<br>当分组m为8时:<br>0.043265 0.044082 0.035714 0.039966 0.034864 0.057823 0.038265 0.042517<br>当m为8时平均CI为0.042062<br>当分组m为9时:<br>0.038055 0.031712 0.048626 0.033827 0.035941 0.043340 0.034884 0.042082 0.042082<br>当m为9时平均CI为0.038950<br>当分组m为10时:<br>0.028205 0.035897 0.035897 0.046154 0.051282 0.040486 0.028340 0.066127 0.037787 0.028340<br>当m为10时平均CI为0.039852<br>当分组m为11时:<br>0.030159 0.038095 0.057143 0.025397 0.034921 0.036508 0.039683 0.036508 0.041270 0.058824 0.040336<br>当m为11时平均CI为0.039895<br>当分组m为12时:<br>0.045455 0.034091 0.035985 0.034091 0.041667 0.053030 0.034091 0.047348 0.026515 0.041667 0.022177 0.050403<br>当m为12时平均CI为0.038877<br>当分组m为13时:<br>0.040860 0.049462 0.040860 0.049462 0.071264 0.043678 0.043678 0.027586 0.068966 0.034483 0.043678 0.048276  0.041379<br>当m为13时平均CI为0.046433<br>当分组m为14时:<br>0.027094 0.071429 0.034392 0.063492 0.050265 0.047619 0.050265 0.055556 0.039683 0.076720 0.039683 0.037037 0.042328 0.084656<br>当m为14时平均CI为0.051444<br>当分组m为15时:<br>0.022792 0.022792 0.051282 0.037037 0.036923 0.021538 0.046154 0.027692 0.040000 0.043077 0.040000 0.040000 0.055385 0.043077 0.049231<br>当m为15时平均CI为0.038465<br>当分组m为16时:<br>0.053333 0.033333 0.036667 0.023333 0.040000 0.043333 0.043333 0.036667 0.046667 0.046667 0.028986 0.065217 0.050725 0.105072 0.025362 0.032609<br>当m为16时平均CI为0.044457<br>当分组m为17时:<br>0.072464 0.025362 0.028986 0.027668 0.055336 0.055336 0.039526 0.027668 0.051383 0.051383 0.043478 0.043478 0.055336 0.059289 0.023715 0.031621 0.043478<br>当m为17时平均CI为0.043265<br>当分组m为18时:<br>0.051948 0.038961 0.030303 0.030303 0.038961 0.043290 0.043290 0.047619 0.030303 0.038961 0.025974 0.060606 0.030303 0.043290 0.030303 0.030303 0.042857 0.038095<br>当m为18时平均CI为0.038648<br>当分组m为19时:<br>0.019048 0.052381 0.057143 0.061905 0.038095 0.042857 0.052381 0.052381 0.028571 0.080952 0.033333 0.028571 0.076190 0.033333 0.042105 0.026316 0.052632 0.031579 0.047368<br>当m为19时平均CI为0.045113<br>当分组m为20时:<br>0.021053 0.015789 0.021053 0.036842 0.057895 0.031579 0.015789 0.026316 0.042105 0.021053 0.026316 0.042105 0.047368 0.042105 0.046784 0.040936 0.017544 0.093567 0.029240 0.017544<br>当m为20时平均CI为0.034649<br>当分组m为21时:<br>0.046784 0.029240 0.035088 0.035088 0.023392 0.076023 0.070175 0.052632 0.040936 0.052632 0.040936 0.052632 0.046784 0.023392 0.052632 0.070175 0.032680 0.039216 0.078431 0.058824 0.078431<br>当m为21时平均CI为0.049339<br>当分组m为22时:<br>0.019608 0.032680 0.052288 0.032680 0.039216 0.032680 0.052288 0.045752 0.045752 0.091503 0.058824 0.026144 0.045752 0.078431 0.019608 0.039216 0.026144 0.045752 0.026144 0.032680 0.029412 0.044118<br>当m为22时平均CI为0.041667<br>当分组m为23时:<br>0.039216 0.052288 0.032680 0.080882 0.029412 0.036765 0.066176 0.066176 0.044118 0.051471 0.044118 0.058824 0.014706 0.007353 0.044118 0.036765 0.073529 0.044118 0.044118 0.066176 0.029412 0.029412 0.022059<br>当m为23时平均CI为0.044082<br>当分组m为24时:<br>0.095588 0.036765 0.029412 0.051471 0.044118 0.073529 0.036765 0.044118 0.022059 0.029412 0.033333 0.050000 0.058333 0.041667 0.016667 0.041667 0.058333 0.025000 0.033333 0.066667 0.016667 0.033333 0.025000 0.041667<br>当m为24时平均CI为0.041871<br>当分组m为25时:<br>0.058333 0.008333 0.041667 0.050000 0.050000 0.033333 0.025000 0.041667 0.025000 0.058333 0.041667 0.041667 0.033333 0.025000 0.041667 0.058333 0.050000 0.116667 0.033333 0.009524 0.019048 0.076190 0.028571 0.028571 0.038095<br>当m为25时平均CI为0.041333<br>当分组m为26时:<br>0.025000 0.025000 0.041667 0.041667 0.038095 0.085714 0.066667 0.038095 0.038095 0.028571 0.019048 0.019048 0.076190 0.047619 0.047619 0.028571 0.057143 0.152381 0.028571 0.019048 0.019048 0.123810 0.028571 0.076190 0.057143 0.009524<br>当m为26时平均CI为0.047619<br>当分组m为27时:<br>0.028571 0.038095 0.028571 0.038095 0.057143 0.038095 0.028571 0.028571 0.038095 0.028571 0.028571 0.047619 0.028571 0.028571 0.047619 0.038095 0.054945 0.065934 0.032967 0.032967 0.054945 0.021978 0.021978 0.087912 0.010989 0.065934 0.043956<br>当m为27时平均CI为0.039479<br>当分组m为28时:<br>0.028571 0.047619 0.010989 0.043956 0.032967 0.054945 0.054945 0.076923 0.043956 0.109890 0.076923 0.032967 0.032967 0.032967 0.021978 0.098901 0.021978 0.054945 0.032967 0.021978 0.032967 0.054945 0.021978 0.065934 0.054945 0.032967 0.032967 0.109890<br>当m为28时平均CI为0.047855<br>当分组m为29时:<br>0.043956 0.021978 0.021978 0.032967 0.021978 0.054945 0.021978 0.032967 0.065934 0.021978 0.043956 0.032967 0.032967 0.043956 0.043956 0.054945 0.065934 0.025641 0.051282 0.038462 0.038462 0.012821 0.038462 0.076923 0.000000 0.025641 0.038462 0.038462 0.064103<br>当m为29时平均CI为0.038209</p></blockquote><p><img src="/2023/03/08/wei-ji-ni-ya-mi-ma-de-wei-mi-wen-gong-ji/1.jpg"></p><p><em><strong>结论：</strong></em>通过结果分析我们可以得到，当m为7与7的倍数时，所得的CI与平均CI高于m取其他值时的情况。因此我们推测：<strong>m=7</strong></p><ul><li>接着，我来进行文本的拟重合指数运算部分 ，推测出每个单标密钥的移位量。以下为代码实现：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">//文本的拟重合指数运算部分 #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; //分组char* apart(char text[],int lines,int point){ char newtext[1000]="";int length=strlen(text);int num=0;for(int i=0;i&lt;length;i++){if(i%lines==0){newtext[num]=text[i+point];num++;}}newtext[num]='\0';printf("%s  ",newtext);return newtext;} int main(){char mess[1000]="";char *text[300];double frequencyP[30][26]={0};double corr[26]={0};//通常文本字母概率来自百度百科，单位为% int frequencyQ[26]={8.167,1.492,2.782,4.253,12.702,2.228,2.015,6.094,6.966,0.153,0.772,4.025,2.406,6.749,7.507,1.929,0.095,5.987,6.327,9.056,2.758,0.978,2.360,0.150,1.974,0.074};int lines=0; printf("请输入文本内容:\n");scanf("%[^\n]", mess);printf("请输入所预测的m长度:\n");scanf("%d",&amp;lines);printf("已分组如下:\n");for(int i=0;i&lt;lines;i++){      text[i] = (char *)malloc(1000 * sizeof(char));       strcpy(text[i],apart(mess,lines,i));    }    printf("\n");        for(int j=0;j&lt;lines;j++){     int length=strlen(text[j]);          for (int p=97;p&lt;123;p++){            int count = 0;            for (int q=0;q&lt;length;q++){              if(text[j][q]==p){                    count++;              }            }              if(count&gt;0){                frequencyP[j][p-97]=(count*1.0)/length;              }          }          printf("第%d段的字母频率如下:\n",j+1);          for(int o=0;o&lt;26;o++){          printf("%lf ",frequencyP[j][o]);  }  printf("\n");  printf("\n");}    for(int ro=0;ro&lt;lines;ro++){    printf("进行第%d段的相关值卷积计算:\n",ro+1);    for(int le=0;le&lt;26;le++){    printf("进行左移%d位的计算:",le);        for(int ele=0;ele&lt;26;ele++){    corr[le]+=0.01*frequencyQ[ele]*frequencyP[ro][(ele+le)%26];} printf("correlation=%lf;\n",corr[le]);    } printf(".....................................................\n");     corr[26]={0};} } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我将代码得出的<strong>结果</strong>与<strong>结论</strong>放在下方：</p><blockquote><p><em><strong>结果：</strong></em></p><p>请输入文本内容:<br>perzlrracmvxmcsrqipqlczhsqsfcvrihwsxxhblrxhsmnkidhvzphwixxvnqsnlyshsifecsuuijrrfygmkxjsuvckdsswbrzrrzuqhjppzywqvylgnosfzfinisibpgyojfgdmzdqzapclsifecsqkscdfyiuxyxeyiutippzcnidtSinljntrfyjszcxhijikiyfixkyiysmhhzuwwwxpkizayvmwlvolhkfxeunrgitrhydafgcrqkiitvjyucsdumbdwkwvcjssiilbcwckdwwhgeadsohgewufffscavuyljntrfyjszcxhivemtkvyhrmxichpieirbxgiwtrhzxxlgvduqhvbzqmwlvcnsuuixdzbawsypmsnrhfxkhijikwvf<br>请输入所预测的m长度:<br>7<br>已分组如下:<br>pasccxhhxlerxdrpyzbgaedxpttciiuilxtgtdwidduvrxkirrvznzmkv  ecrzvxsvxycrjsrplfpdpcfepSrxyywzvercvuvlwsfufhvcbhdqsbshf  rmqhrhmzvssfsszzgigmcsyyzifhfswaouhrjmcbwofyyiyhxzumuani  zvisibnpnhuyuwuynnyzlqiicnyiimwylnyqybjchhfljvhpgxqwuwrj  lxpqhlkhqsugvbqwoiodskuunljjxhxvhrdkudswggsjseriixhlishi  rmqswriwsiimcrhqssjqisxtijsikhpmkgaicwsceecnzmmewlvvxyfk  rclfsxdinfjkkzjvfifzfcyidnzkyzkwfifiskikawatctxitgbcdpxw<br>第1段的字母频率如下:<br>0.035088 0.017544 0.052632 0.087719 0.035088 0.000000 0.035088 0.035088 0.087719 0.000000 0.035088 0.035088 0.017544 0.017544 0.000000 0.052632 0.000000 0.087719 0.017544 0.070175 0.035088 0.052632 0.017544 0.105263 0.017544 0.052632</p><p>第2段的字母频率如下:<br>0.000000 0.035088 0.087719 0.035088 0.052632 0.087719 0.000000 0.052632 0.000000 0.017544 0.000000 0.035088 0.000000 0.000000 0.000000 0.070175 0.017544 0.087719 0.087719 0.000000 0.035088 0.105263 0.035088 0.052632 0.052632 0.035088</p><p>第3段的字母频率如下:<br>0.035714 0.017857 0.035714 0.000000 0.000000 0.071429 0.035714 0.089286 0.071429 0.017857 0.000000 0.000000 0.089286 0.017857 0.035714 0.000000 0.017857 0.053571 0.107143 0.000000 0.053571 0.017857 0.035714 0.017857 0.089286 0.089286</p><p>第4段的字母频率如下:<br>0.000000 0.035714 0.035714 0.000000 0.000000 0.017857 0.017857 0.071429 0.107143 0.053571 0.000000 0.053571 0.017857 0.107143 0.000000 0.035714 0.053571 0.017857 0.017857 0.000000 0.071429 0.035714 0.071429 0.017857 0.125000 0.035714</p><p>第5段的字母频率如下:<br>0.000000 0.017857 0.000000 0.053571 0.017857 0.000000 0.053571 0.107143 0.089286 0.053571 0.053571 0.071429 0.000000 0.017857 0.035714 0.017857 0.053571 0.035714 0.107143 0.000000 0.071429 0.035714 0.035714 0.071429 0.000000 0.000000</p><p>第6段的字母频率如下:<br>0.017857 0.000000 0.071429 0.000000 0.053571 0.017857 0.017857 0.035714 0.125000 0.035714 0.053571 0.017857 0.089286 0.017857 0.000000 0.017857 0.053571 0.053571 0.125000 0.017857 0.000000 0.035714 0.071429 0.035714 0.017857 0.017857</p><p>第7段的字母频率如下:<br>0.035714 0.017857 0.071429 0.053571 0.000000 0.125000 0.017857 0.000000 0.125000 0.035714 0.107143 0.017857 0.000000 0.035714 0.000000 0.017857 0.000000 0.017857 0.035714 0.053571 0.000000 0.017857 0.053571 0.053571 0.035714 0.071429</p><p>进行第1段的相关值卷积计算:<br>进行左移0位的计算:correlation=0.036140;<br>进行左移1位的计算:correlation=0.028421;<br>进行左移2位的计算:correlation=0.030702;<br>进行左移3位的计算:correlation=0.036140;<br>进行左移4位的计算:correlation=0.043333;<br>进行左移5位的计算:correlation=0.027193;<br>进行左移6位的计算:correlation=0.035439;<br>进行左移7位的计算:correlation=0.030526;<br>进行左移8位的计算:correlation=0.032105;<br>进行左移9位的计算:correlation=0.030877;<br>进行左移10位的计算:correlation=0.036316;<br>进行左移11位的计算:correlation=0.036316;<br>进行左移12位的计算:correlation=0.031754;<br>进行左移13位的计算:correlation=0.031579;<br>进行左移14位的计算:correlation=0.028772;<br>==进行左移15位的计算:correlation=0.048246;==<br>进行左移16位的计算:correlation=0.034561;<br>进行左移17位的计算:correlation=0.038421;<br>进行左移18位的计算:correlation=0.027368;<br>进行左移19位的计算:correlation=0.039474;<br>进行左移20位的计算:correlation=0.029474;<br>进行左移21位的计算:correlation=0.036140;<br>进行左移22位的计算:correlation=0.030175;<br>进行左移23位的计算:correlation=0.033158;<br>进行左移24位的计算:correlation=0.030175;<br>进行左移25位的计算:correlation=0.037193;<br>……………………………………………..<br>进行第2段的相关值卷积计算:<br>进行左移0位的计算:correlation=0.064561;<br>进行左移1位的计算:correlation=0.063684;<br>进行左移2位的计算:correlation=0.064386;<br>进行左移3位的计算:correlation=0.072807;<br>进行左移4位的计算:correlation=0.081579;<br>进行左移5位的计算:correlation=0.057544;<br>进行左移6位的计算:correlation=0.057368;<br>进行左移7位的计算:correlation=0.063860;<br>进行左移8位的计算:correlation=0.056667;<br>进行左移9位的计算:correlation=0.063509;<br>进行左移10位的计算:correlation=0.072281;<br>进行左移11位的计算:correlation=0.077193;<br>进行左移12位的计算:correlation=0.060702;<br>进行左移13位的计算:correlation=0.070175;<br>进行左移14位的计算:correlation=0.072105;<br>进行左移15位的计算:correlation=0.080526;<br>进行左移16位的计算:correlation=0.065965;<br>==进行左移17位的计算:correlation=0.083333;==<br>进行左移18位的计算:correlation=0.060175;<br>进行左移19位的计算:correlation=0.065439;<br>进行左移20位的计算:correlation=0.060351;<br>进行左移21位的计算:correlation=0.065789;<br>进行左移22位的计算:correlation=0.055965;<br>进行左移23位的计算:correlation=0.065088;<br>进行左移24位的计算:correlation=0.071754;<br>进行左移25位的计算:correlation=0.071754;<br>……………………………………………..<br>进行第3段的相关值卷积计算:<br>进行左移0位的计算:correlation=0.097240;<br>进行左移1位的计算:correlation=0.099934;<br>进行左移2位的计算:correlation=0.089565;<br>进行左移3位的计算:correlation=0.104771;<br>==进行左移4位的计算:correlation=0.119436;==<br>进行左移5位的计算:correlation=0.098615;<br>进行左移6位的计算:correlation=0.092190;<br>进行左移7位的计算:correlation=0.099574;<br>进行左移8位的计算:correlation=0.089524;<br>进行左移9位的计算:correlation=0.090830;<br>进行左移10位的计算:correlation=0.103174;<br>进行左移11位的计算:correlation=0.106657;<br>进行左移12位的计算:correlation=0.096416;<br>进行左移13位的计算:correlation=0.104283;<br>==进行左移14位的计算:correlation=0.118534;==<br>进行左移15位的计算:correlation=0.108741;<br>进行左移16位的计算:correlation=0.098643;<br>进行左移17位的计算:correlation=0.116548;<br>进行左移18位的计算:correlation=0.095711;<br>进行左移19位的计算:correlation=0.096153;<br>进行左移20位的计算:correlation=0.105887;<br>进行左移21位的计算:correlation=0.104004;<br>进行左移22位的计算:correlation=0.081858;<br>进行左移23位的计算:correlation=0.086516;<br>进行左移24位的计算:correlation=0.108540;<br>进行左移25位的计算:correlation=0.111219;<br>……………………………………………..<br>进行第4段的相关值卷积计算:<br>进行左移0位的计算:correlation=0.125097;<br>进行左移1位的计算:correlation=0.131363;<br>进行左移2位的计算:correlation=0.123850;<br>进行左移3位的计算:correlation=0.139771;<br>进行左移4位的计算:correlation=0.156400;<br>进行左移5位的计算:correlation=0.142544;<br>进行左移6位的计算:correlation=0.125226;<br>进行左移7位的计算:correlation=0.136003;<br>进行左移8位的计算:correlation=0.125060;<br>进行左移9位的计算:correlation=0.131544;<br>进行左移10位的计算:correlation=0.130674;<br>进行左移11位的计算:correlation=0.137372;<br>进行左移12位的计算:correlation=0.121595;<br>进行左移13位的计算:correlation=0.138925;<br>进行左移14位的计算:correlation=0.147462;<br>进行左移15位的计算:correlation=0.141598;<br>进行左移16位的计算:correlation=0.140251;<br>进行左移17位的计算:correlation=0.151726;<br>进行左移18位的计算:correlation=0.124997;<br>进行左移19位的计算:correlation=0.123296;<br>==进行左移20位的计算:correlation=0.162137;==<br>进行左移21位的计算:correlation=0.140789;<br>进行左移22位的计算:correlation=0.112572;<br>进行左移23位的计算:correlation=0.112945;<br>进行左移24位的计算:correlation=0.143540;<br>进行左移25位的计算:correlation=0.137826;<br>……………………………………………..<br>进行第5段的相关值卷积计算:<br>进行左移0位的计算:correlation=0.159383;<br>进行左移1位的计算:correlation=0.164577;<br>进行左移2位的计算:correlation=0.156350;<br>==进行左移3位的计算:correlation=0.188700;==<br>==进行左移4位的计算:correlation=0.202115;==<br>进行左移5位的计算:correlation=0.175758;<br>进行左移6位的计算:correlation=0.158261;<br>进行左移7位的计算:correlation=0.173681;<br>进行左移8位的计算:correlation=0.151310;<br>进行左移9位的计算:correlation=0.160294;<br>进行左移10位的计算:correlation=0.165138;<br>进行左移11位的计算:correlation=0.165586;<br>进行左移12位的计算:correlation=0.146952;<br>进行左移13位的计算:correlation=0.166961;<br>==进行左移14位的计算:correlation=0.188891;==<br>进行左移15位的计算:correlation=0.181241;<br>进行左移16位的计算:correlation=0.183465;<br>进行左移17位的计算:correlation=0.182083;<br>进行左移18位的计算:correlation=0.163033;<br>进行左移19位的计算:correlation=0.156153;<br>==进行左移20位的计算:correlation=0.195172;==<br>进行左移21位的计算:correlation=0.168289;<br>进行左移22位的计算:correlation=0.143108;<br>进行左移23位的计算:correlation=0.144552;<br>进行左移24位的计算:correlation=0.167826;<br>进行左移25位的计算:correlation=0.175683;<br>……………………………………………..<br>进行第6段的相关值卷积计算:<br>进行左移0位的计算:correlation=0.196169;<br>进行左移1位的计算:correlation=0.194934;<br>进行左移2位的计算:correlation=0.186707;<br>进行左移3位的计算:correlation=0.220307;<br>==进行左移4位的计算:correlation=0.256222;==<br>进行左移5位的计算:correlation=0.214865;<br>进行左移6位的计算:correlation=0.186476;<br>进行左移7位的计算:correlation=0.198324;<br>进行左移8位的计算:correlation=0.191667;<br>进行左移9位的计算:correlation=0.192259;<br>进行左移10位的计算:correlation=0.197638;<br>进行左移11位的计算:correlation=0.197014;<br>进行左移12位的计算:correlation=0.178380;<br>进行左移13位的计算:correlation=0.192140;<br>进行左移14位的计算:correlation=0.229784;<br>进行左移15位的计算:correlation=0.219633;<br>进行左移16位的计算:correlation=0.217572;<br>进行左移17位的计算:correlation=0.218155;<br>进行左移18位的计算:correlation=0.199104;<br>进行左移19位的计算:correlation=0.187581;<br>进行左移20位的计算:correlation=0.228029;<br>进行左移21位的计算:correlation=0.199182;<br>进行左移22位的计算:correlation=0.173108;<br>进行左移23位的计算:correlation=0.173123;<br>进行左移24位的计算:correlation=0.203719;<br>进行左移25位的计算:correlation=0.212469;<br>……………………………………………..<br>进行第7段的相关值卷积计算:<br>进行左移0位的计算:correlation=0.225454;<br>进行左移1位的计算:correlation=0.232256;<br>进行左移2位的计算:correlation=0.220279;<br>进行左移3位的计算:correlation=0.249057;<br>==进行左移4位的计算:correlation=0.292650;==<br>进行左移5位的计算:correlation=0.256651;<br>进行左移6位的计算:correlation=0.225404;<br>进行左移7位的计算:correlation=0.224753;<br>进行左移8位的计算:correlation=0.223095;<br>进行左移9位的计算:correlation=0.222794;<br>进行左移10位的计算:correlation=0.231209;<br>进行左移11位的计算:correlation=0.227372;<br>进行左移12位的计算:correlation=0.211416;<br>进行左移13位的计算:correlation=0.217318;<br>进行左移14位的计算:correlation=0.262462;<br>进行左移15位的计算:correlation=0.259455;<br>进行左移16位的计算:correlation=0.246858;<br>==进行左移17位的计算:correlation=0.263869;==<br>进行左移18位的计算:correlation=0.238568;<br>进行左移19位的计算:correlation=0.218653;<br>进行左移20位的计算:correlation=0.262137;<br>进行左移21位的计算:correlation=0.235968;<br>进行左移22位的计算:correlation=0.207215;<br>进行左移23位的计算:correlation=0.208838;<br>进行左移24位的计算:correlation=0.235683;<br>进行左移25位的计算:correlation=0.245147;<br>……………………………………………..</p></blockquote><p><em><strong>结论：</strong></em>通过结果分析我们可以得到：</p><ul><li><p><strong>第1段</strong>进行相关值计算后:<br>进行左移15位(a-p)的计算结果(0.048246)值明显最大</p></li><li><p><strong>第2段</strong>进行相关值计算后:<br>进行左移17位(a-r)的计算结果(0.083333)值明显最大</p></li><li><p><strong>第3段</strong>进行相关值计算后:<br>进行左移4位(a-e)的计算结果(0.119436)值最大</p><p>其次为左移14位(a-o)的计算结果(0.118534)值与之接近</p></li><li><p><strong>第4段</strong>进行相关值计算后:<br>进行左移20位(a-u)的计算结果(0.162137)值最大</p></li><li><p><strong>第5段</strong>进行相关值计算后:</p><p>发现近似较多</p><p>进行左移4位(a-e)的计算结果(0.202115)值最大</p><p>其次为左移20位(a-u)的计算结果(0.195172)值与之接近</p><p>其次为左移14位(a-o)的计算结果(0.188891)值与之接近</p><p>其次为左移3位(a-d)的计算结果(0.188700)值与之接近</p></li><li><p><strong>第6段</strong>进行相关值计算后:<br>进行左移4位(a-e)的计算结果(0.256222)值最大</p></li><li><p><strong>第7段</strong>进行相关值计算后:</p><p>进行左移4位(a-e)的计算结果(0.292650)值最大</p><p>其次为左移17位(a-r)的计算结果(0.263869)值与之接近</p></li><li><p>最后，我们按照顺序依次将移位量代入进行比对，发现以下移位方式符合正常单词拼写：</p><blockquote><p><strong>第1段</strong>左移15位(a-p)</p><p><strong>第2段</strong>左移17位(a-r)</p><p><strong>第3段</strong>左移14位(a-o)</p><p><strong>第4段</strong>左移20位(a-u)</p><p><strong>第5段</strong>左移3位(a-d)</p><p><strong>第6段</strong>左移4位(a-e)</p><p><strong>第7段</strong>左移17位(a-r)</p></blockquote></li></ul><p>最终解密后为：</p><p>And finally, build a community. No one does big things by themselves. Right now, when people are scared, it is easy to be cynical and say let me just look out for myself, or my family, or people who look or think or pray like me. But if we are going to get through these difficult times; if we are going to create a world where everybody has the opportunity to find a job, and afford college; if we are going to save the environment and defeat future pandemics, then we are going to have to do it together.</p>]]></content>
      
      
      <categories>
          
          <category> 现代密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代密码学 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿射密码与单表代换的代码实现</title>
      <link href="/2023/03/06/fang-she-mi-ma-yu-dan-biao-dai-huan-de-dai-ma-shi-xian/"/>
      <url>/2023/03/06/fang-she-mi-ma-yu-dan-biao-dai-huan-de-dai-ma-shi-xian/</url>
      
        <content type="html"><![CDATA[<h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><blockquote><p>试设计实现仿射密码和单表代换密码：给出密钥生成（随机选择小于26的数、选择和26互素的密钥；以及生成0-25上的一个随机置换）、加解密的伪代码</p></blockquote><h5 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">//仿射密码#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;//密钥生成int gcd(int a, int b) {    int temp;    while (b != 0) {        temp = a % b;        a = b;        b = temp;    }    return a;}int keygenerationA(){int a;    srand((unsigned)time(NULL));    a = rand()%26;    while(gcd(a,26)!=1)a = rand()%26;    printf("a=%d\n", a);    return a;} int keygenerationB(){int b;    srand((unsigned)time(NULL)+1);    b = rand()%26;    printf("b=%d\n", b);    return b;}//加密int encrypt(int a,int b,int p){int c;c=(a*p+b)%26;char d = (char)c+97;    printf("%c\n", d);    return c;} //解密int mod_inverse(int x) {    for(int i=0;i&lt;26;i++){    if((x*i)%26==1){    return i;    break;}}   }int decrypt(int a,int b,int c){int p;a=mod_inverse(a);p=((c-b)*a)%26;if(p&lt;0){        p+=26;    }char d = (char)p+97;    printf("%c\n", d);} //主函数 int main(){char text[100]="";int end[100];int a;int b;printf("生成密钥：\n");a=keygenerationA();b=keygenerationB();printf("请输入明文\n");scanf("%[^\n]",text);int l= strlen(text);printf("以下为密文\n");for(int i=0;i&lt;l;i++){ int p=text[i]-97; end[i]=encrypt(a,b,p);} printf("以下为明文\n");for(int i=0;i&lt;l;i++){ int c=end[i]; decrypt(a,b,c);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="单表代换密码"><a href="#单表代换密码" class="headerlink" title="单表代换密码"></a>单表代换密码</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">//单表代换#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;//密钥生成 void keygeneration(int *k){int num;int t[26]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25};for(int i=0;i&lt;26;i++){      srand((unsigned)time(NULL)+i);      num=rand()%(26-i);      k[i]=t[num];            for(int j=num;j&lt;25-i;j++){      t[j]=t[j+1];  }}printf("a b c d e f g h i j k l m n o p q r s t u v w x y z\n");for(int l=0;l&lt;26;l++){printf("%c ",k[l]+65);}    printf("\n");}//加密int encrypt(int *k,int a){int c;c=k[a];char d = (char)c+65;    printf("%c\n", d);    return c;} //解密int decrypt(int *k,int a){for(int i=0;i&lt;26;i++){if(k[i]==a){printf("%c\n",i+97);}} }  //主函数int main(){char text[100]="";int end[100];int k[26];printf("生成密钥：\n");keygeneration(k);printf("请输入明文\n");scanf("%[^\n]",text);int l= strlen(text);printf("以下为密文\n");for(int i=0;i&lt;l;i++){int p=text[i]-97; end[i]=encrypt(k,p);}printf("以下为明文\n");for(int i=0;i&lt;l;i++){ int c=end[i]; decrypt(k,c);} } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 现代密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代密码学 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制编辑作业报告</title>
      <link href="/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/"/>
      <url>/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="二进制编辑作业报告"><a href="#二进制编辑作业报告" class="headerlink" title="二进制编辑作业报告"></a>二进制编辑作业报告</h2><blockquote><p>要求：修改exe文件</p><p>修改前：<img src="/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/1.jpg" style="zoom:60%;"></p><p>修改后：<img src="/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/2.jpg" style="zoom:60%;"></p></blockquote><p>操作过程如下：</p><p>1.我们打开exe可执行文件后，发现powershell中文显示乱码，猜测由编码方式出入导致</p><img src="/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/4.jpg" style="zoom:30%;"><p>因此查询当前编码，发现当前编码方式为GB2312</p><img src="/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/3.jpg" style="zoom:60%;"><p>将系统更改为utf-8后恢复正常</p><img src="/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/5.jpg" style="zoom:36%;"><p>2.将可执行文件放入010editor，定位到第一次”Hello World”字符处，同时我们也能得到对应的十六进制编码</p><img src="/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/6.jpg" style="zoom:36%;"><p>3.我们不难推测出”你好世界”对应的字符乱码及其对应的十六进制编码</p><img src="/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/7.jpg" style="zoom:36%;"><p>4.我们将第二次”Hello World”字符对应的十六进制编码替换成”你好世界”对应的十六进制编码</p><img src="/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/8.jpg" style="zoom:36%;"><p>5.我们将修改后的文件另存为新的可执行文件，运行后即可得到修改后结果</p><img src="/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/9.jpg" style="zoom:36%;"><p>另外：在第3步中我们通过题干获取了”你好世界！”对应的十六进制编码，同样我们也可以利用老师给到的编码转换工具获取”你好世界！”对应的十六进制编码，之后按照步骤依次进行即可</p><img src="/2023/03/05/er-jin-zhi-bian-ji-zuo-ye-bao-gao/10.jpg" style="zoom:36%;">]]></content>
      
      
      <categories>
          
          <category> 汇编语言与逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2023/03/03/hui-bian-yu-yan/"/>
      <url>/2023/03/03/hui-bian-yu-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><h3 id="CPU简介"><a href="#CPU简介" class="headerlink" title="CPU简介"></a>CPU简介</h3><h4 id="CPU的基本组成部件"><a href="#CPU的基本组成部件" class="headerlink" title="CPU的基本组成部件"></a>CPU的基本组成部件</h4><ul><li><p><strong>时钟</strong></p><p>机器指令的最小执行时间就是一个时钟周期</p><p>CPU的主频即为时钟频率，对CPU的整体性能具有直接影响</p><ul><li><p><strong>时钟周期</strong> </p><p>时钟频率的倒数，是计算机中最小的时间单位</p></li><li><p><strong>CPU周期</strong></p><p>一条指令执行过程中被划分为若干阶段，每个阶段完成所需时间（需要确认）</p></li><li><p><strong>指令周期</strong></p><p>是指计算机执行一条指令所需要的时间，通常包括指令取指、指令译码、指令执行和结果写回等几个步骤。</p><blockquote><p><strong>三者的区别</strong></p><p>CPU周期指的是执行一条指令所需的时间，包括取指周期、指令译码周期、执行周期、访存周期和写回周期。这些周期的长度取决于CPU的设计，不同的CPU可能有不同的周期长度。</p><p>指令周期指的是执行一条指令所需的若干个CPU周期。一条指令可能需要多个CPU周期才能完成，因此指令周期可以看作是CPU周期的集合。</p><p>时钟周期指的是CPU内部时钟的一个周期，通常用来同步CPU内部各个部件的操作。CPU周期和指令周期都是以时钟周期为基础计算的，因此时钟周期可以看作是最基本的计时单位。</p><p>总的来说，CPU周期是指执行指令所需的时间，指令周期是执行一条指令所需的多个CPU周期的集合，而时钟周期是CPU内部时钟的一个周期，用于同步各个部件的操作。</p></blockquote></li></ul></li><li><p><strong>算数逻辑单元</strong></p><p>即ALU</p></li><li><p><strong>控制单元</strong> </p><p>即CU，是CPU的指挥中心</p><ul><li>指令寄存器IR</li><li>指令译码器ID</li><li>指令控制器OC</li><li>指令指针寄存器EIP：程序不能直接访问EIP</li></ul></li><li><p><strong>存储单元</strong></p></li><li><p><strong>寄存器</strong></p><ul><li><p>八个通用寄存器</p><p>EAX、EBX、ECX、EDX、EDI、ESI、ESP、EBP</p></li><li><p>一个指令指针寄存器EIP</p><p>EIP始终指向下一条待执行指令的地址</p></li><li><p>一个CPU状态寄存器EFLAGS</p></li><li><p>六个段寄存器</p></li></ul></li><li><p><strong>总线</strong></p><ul><li><p>地址总线</p></li><li><p>数据总线</p></li><li><p>控制总线</p></li></ul></li></ul><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>是中央处理器内部的组成部分，可用来暂存指令、数据和地址</p><h4 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h4><p>十六个基本寄存器如下：</p><ul><li><p><strong>通用寄存器（8个）</strong></p><p>32位CPU通用寄存器：EAX、EBX、ECX、EDX、EDI、ESI、ESP、EBP</p><p>可以用于传送和暂存以下数据</p><ul><li>==逻辑和算数运算的操作数==</li><li>用于地址运算的操作数</li><li>内存指针</li></ul><p><strong>EAX</strong>:累加寄存器，是操作数和结果数据的累加器</p><p><strong>EBX</strong>:基址寄存器，指向DS段中数据的指针</p><p><strong>ECX</strong>:计数寄存器，是字符串和循环操作的计数器</p><p><strong>EDX</strong>:数据寄存器，I/O指针</p><blockquote><p>为了实现与16位CPU的向下兼容（即对低十六位数据的存取）</p><p>这些低十六位寄存器分别命名为<strong>AX</strong>、<strong>BX</strong>、<strong>CX</strong>、<strong>DX</strong></p><p>对低16位数据的存取，不会影响高16位的数据</p><p>为了兼容8086CPU的上一代CPU中8位寄存器，同样AX、BX、CX、DX这四个16位寄存器又可分为两个独立使用的8位寄存器来用：</p><p>AX可分为AH和AL</p><p>BX可分为BH和BL</p><p>CX可分为CH和CL</p><p>DX可分为DH和DL</p><p><em>==AX又可分为高8位的AH寄存器和低8位的AL寄存器，每个寄存器都有自己的名称，可独立存取，程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/双字/字节的信息==</em></p><img src="/2023/03/03/hui-bian-yu-yan/1.jpg" style="zoom:67%;"><p>指针寄存器EBP、ESP和变址寄存器ESI、EDI</p><p>有类似的低16位寄存器BP、SP、SI、DI</p><p>但是它们不可分割成8位寄存器</p></blockquote><p>==<em>以上四个寄存器主要用于算数、逻辑运算（ADD\SUB\XOR\OR等）指令中，常用来保存常量与变量的值</em>==</p><p><u>指针寄存器</u>：</p><p><strong>ESP</strong>:栈顶指针寄存器，用于存放当前堆栈的栈顶地址，专门用做堆栈指针</p><p><strong>EBP</strong>:栈底指针寄存器，表示栈区域的基地址，永远指向当前函数栈的栈底位置</p><p><em>==上述两个寄存器，不可以作为一般通用寄存器使用==</em></p><p><u>变址寄存器</u>：<br><strong>ESI</strong>:字符串操作源指针，源变址寄存器</p><p><strong>ED</strong>I:字符串操作目的指针，目的变址寄存器<br>==<em>ESI和EDI与特定的串操作指令（MOVS/LODS/STOS）一起使用，在字符串操作的时候用的比较多</em><br><em>变址寄存器存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为通过多种方式访问存储单元提供便利</em>==</p></li><li><p><strong>一个指令指针寄存器EIP</strong></p><p>EIP始终指向下一条待执行指令的地址</p><p><u>在16位系统中</u>：</p><ul><li>保存着CPU下一条将要执行指令的偏移量(offset)，这个<br>偏移量是相对于目前正在运行的代码段寄存器CS而言的</li><li>偏移量加上当前代码段的基地址，就形成了下一条指令<br>的地址</li></ul><p><u>在32位系统中</u>：</p><ul><li>它的大小为32位，是由原来的16位IP寄存器扩展而来</li><li>往往直接保存CPU下一条将要执行指令的地址</li></ul><blockquote><p>程序运行时，CPU会读取EIP中一条指令的地址，将指令传送到指令缓冲区后，EIP的值自动增加<br>CPU每次执行完一条指令，就会通过EIP寄存器读取并执行下一条指令<br>不能直接修改EIP的值，只能通过其他指令间接修改</p><ul><li>这些特定指令包括JMP、JC、CALL、RET</li><li>可以通过中断或异常来修改EIP的值</li></ul></blockquote></li><li><p><strong>一个CPU状态寄存器EFLAGS</strong></p><p><u>主要有3种作用：</u></p><ul><li>用来存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ul><p><u>在IA-32中标志寄存器的名称为<strong>EFLAGS</strong></u></p><ul><li><p>大小为4个字节， 共有32个位元，每一位都有专门的含义，记录特定的信息，每位的值为1或0，代表<br>On/Off或True/False</p></li><li><p>包含一组状态标志、一个控制标志和一组系统标志</p></li><li><p>一些标志可以使用专用指令直接修改，但是没有指令可以将整个寄存器进行检查或修改</p><img src="/2023/03/03/hui-bian-yu-yan/2.jpg" style="zoom:67%;"></li></ul><p>EFLAGS寄存器的32位标志可以分为4类：<br>– 系统标志(位8，9，14，16，17，18，19，20，21)和<br>IOPL(I/O Privilege Level)字段(位12，13)<br> 控制操作系统或执行操作，应用程序不能修改以上标志位<br>– 方向标志(DF，位10)：控制串操作指令的处理方向<br>DF=0，从低地址到高地址<br>DF=1，从高地址到低地址<br>– 状态标志(位0，2，4，6，7和11)：表示算数指令的运<br>算结果，如ADD、SUB、MUL和DIV指令<br>和应用程序运行状态密切相关，需掌握<br>– 预留标志位（位1，3，5，15，22-31）<br>DO NOT USE</p></li><li><p><strong>六个段寄存器</strong></p></li><li></li><li></li></ul><h3 id="X86指令集"><a href="#X86指令集" class="headerlink" title="X86指令集"></a>X86指令集</h3><h4 id="一条汇编指令的标准格式"><a href="#一条汇编指令的标准格式" class="headerlink" title="一条汇编指令的标准格式"></a>一条汇编指令的标准格式</h4><img src="/2023/03/03/hui-bian-yu-yan/3.jpg" style="zoom:36%;"><blockquote><p>汇编代码是由两部分组成：操作码+操作数</p><ul><li>操作码在相应的机器指令体系中有相关的表示</li><li>根据指令的功能，可以将大部分汇编语句分成如下几类：<ul><li>数据传送指令</li><li>算数运算指令/逻辑运算/移位指令/浮点数运算指令</li><li>串操作指令</li><li>控制转移指令</li><li>处理器控制指令</li></ul></li></ul></blockquote><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4>]]></content>
      
      
      <categories>
          
          <category> 汇编语言与逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库绪论</title>
      <link href="/2023/02/27/shu-ju-ku-xu-lun/"/>
      <url>/2023/02/27/shu-ju-ku-xu-lun/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库系统概念"><a href="#数据库系统概念" class="headerlink" title="数据库系统概念"></a>数据库系统概念</h2><h3 id="四个基本概念"><a href="#四个基本概念" class="headerlink" title="四个基本概念"></a>四个基本概念</h3><p><strong>数据</strong>、<strong>数据库</strong>、<strong>数据库管理系统</strong>、<strong>数据库系统</strong>是与数据库技术密切相关的四个基本概念。</p><ul><li><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>描述事物的符号记录称之为数据，他可以是文字、图像等等，不光拘泥于数字。</p><p><u>数据的含义</u>称为数据的<strong>语义</strong>，数据与其语义密不可分。</p></li><li><h4 id="数据库（DataBase）"><a href="#数据库（DataBase）" class="headerlink" title="数据库（DataBase）"></a>数据库（DataBase）</h4><p>存放数据的仓库。是长期储存在计算机内的、有组织可共享的大量数据的集合。</p><p>数据库数据的特点包括：</p><ul><li><strong>永久存储</strong></li><li><strong>有组织</strong></li><li><strong>可共享</strong></li></ul></li><li><h4 id="数据库管理系统（DataBase-Management-System）"><a href="#数据库管理系统（DataBase-Management-System）" class="headerlink" title="数据库管理系统（DataBase Management System）"></a>数据库管理系统（DataBase Management System）</h4><p>一个系统软件，能够实现科学组织和存储数据、高效获取和维护数据，位于用户与操作系统之间。</p><p>与操作系统一样是计算机的基础软件，其功能包括：</p><ul><li><p><strong>数据定义功能</strong></p><p>系统提供数据定义语言（DDL），可以方便对数据对象的组成与结构进行定义。</p></li><li><p><strong>数据组织、存储和管理</strong></p></li><li><p><strong>数据操纵</strong></p><p>提供数据操纵语言（DML），及其编译程序操纵数据实现对数据库的基本操作（查询、插入、删除和修改）。</p></li><li><p><strong>数据库事物管理和运行管理</strong></p></li><li><p><strong>数据库的建立和维护</strong></p></li><li><p><strong>其他功能</strong></p><p>包括数据库管理系统与网络中其他软件系统的通信功能、一个数据库管理系统与另一个数据库管理系统或文件系统的数据转换功能等等。</p></li></ul></li><li><h4 id="数据库系统（DataBase-System）"><a href="#数据库系统（DataBase-System）" class="headerlink" title="数据库系统（DataBase System）"></a>数据库系统（DataBase System）</h4><p>由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统。</p><blockquote><p>下图为数据库系统以及引入数据库后计算机系统的层次结构</p></blockquote><img src="/2023/02/27/shu-ju-ku-xu-lun/1.jpg" style="zoom:67%;"><p><u>==人们常常把数据库系统简称为数据库==</u></p></li></ul><h3 id="数据管理技术的产生和发展"><a href="#数据管理技术的产生和发展" class="headerlink" title="数据管理技术的产生和发展"></a>数据管理技术的产生和发展</h3><p>数据管理技术经历三个阶段，分别为：<strong>人工管理</strong>、<strong>文件系统</strong>、<strong>数据库系统</strong>。</p><ul><li><h4 id="人工管理"><a href="#人工管理" class="headerlink" title="人工管理"></a>人工管理</h4><p>二十世纪五十年代中期以前，计算机用于科学计算，其特点为：</p><ul><li>数据不保存</li><li>应用程序管理数据</li><li>数据不共享</li><li>数据不具有独立性</li></ul></li><li><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>二十世纪五十年代后期到六十年代中期，拥有磁盘等加持，软件方面已经有专门的数据管理系统，其特点为：</p><ul><li>数据可以长期保存</li><li>由文件系统管理数据</li><li>数据共享性差、冗余度大</li><li>数据独立性差</li></ul></li><li><h4 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h4><p>二十世纪六十年代后期以来，计算机管理的对象规模越来越大，应用范围越来越广泛，出现数据库管理系统，==<u>从文件系统到数据库系统标志着数据管理技术的飞跃</u>==。</p></li></ul><blockquote><p>以下为数据管理三阶段的比较</p></blockquote><img src="/2023/02/27/shu-ju-ku-xu-lun/2.jpg" style="zoom:67%;"><h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><ul><li><h4 id="数据结构化"><a href="#数据结构化" class="headerlink" title="数据结构化"></a>数据结构化</h4><p>数据库系统实现整体数据的结构化，是数据库系统与文件系统的本质区别。</p><p><u>==也就是说，数据库中的数据不再仅仅针对某一个用用，二十面向整个组织或企业；不仅数据内部是结构化的，整体也是结构化的，数据之间是具有联系的。==</u></p></li><li><h4 id="数据的共享性高，冗余度低，易扩充"><a href="#数据的共享性高，冗余度低，易扩充" class="headerlink" title="数据的共享性高，冗余度低，易扩充"></a>数据的共享性高，冗余度低，易扩充</h4><p>数据共享可以大大减少数据冗余，节约存储空间。数据共享还能够避免数据之间的不相容性与不一致性。</p><p><u>==同时数据库系统弹性大、易于扩充。==</u></p><img src="/2023/02/27/shu-ju-ku-xu-lun/3.jpg" style="zoom:42%;"></li><li><h4 id="数据独立性高"><a href="#数据独立性高" class="headerlink" title="数据独立性高"></a>数据独立性高</h4><p>包括<strong>物理独立性</strong>与<strong>逻辑独立性</strong>。</p><p><strong>物理独立性</strong>指的是用户的应用程序与数据库中的数据的物理存储相互独立。当数据的物理存储改变了，应用程序不用改变。</p><p><strong>逻辑独立性</strong>指的是用户的应用程序与数据库中的逻辑结构相互独立。数据的逻辑结构改变了，用户程序也可以不变。</p></li><li><h4 id="数据由DBMS统一管理和控制组织和操作"><a href="#数据由DBMS统一管理和控制组织和操作" class="headerlink" title="数据由DBMS统一管理和控制组织和操作"></a>数据由DBMS统一管理和控制组织和操作</h4><p>==<u>数据库的共享是并发的共享，为此需要避免用户间相互干扰的隐患。</u>==</p><p>另外，数据库中数据的正确与一致也要得到保障，为此有以下几方面的数据控制功能：</p><ul><li><p>数据的安全性保护</p></li><li><p>数据的完整性保护</p></li><li><p>并发控制</p></li><li><p>数据库恢复</p></li></ul></li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><strong>它是对现实世界数据的抽象、是数据库系统的核心和基础。</strong>我们说数据模型必须满足三个方面的要求，分别为：<strong>能比较真实地模拟现实世界</strong>、<strong>容易为人所理解</strong>、<strong>便于在计算机上实现</strong>。</p><ul><li><h4 id="两大类数据模型"><a href="#两大类数据模型" class="headerlink" title="两大类数据模型"></a>两大类数据模型</h4><p>两大类数据模型分属不同层次</p><ul><li><p><strong>概念模型</strong></p><p>也称为信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。</p></li><li><p><strong>逻辑模型和物理模型</strong></p><p>计算机系统的观点对数据建模，用于DBMS的实现。</p><blockquote><p><strong>逻辑模型</strong>主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。</p></blockquote><blockquote><p><strong>物理模型</strong>是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</p></blockquote></li></ul></li><li><h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><ul><li><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5></li><li><p>用于信息世界的建模</p></li><li><p>是现实世界到机器世界的一个中间层次</p></li><li><p>是数据库设计的有力工具</p></li><li><p>数据库设计人员和用户之间进行交流的语言</p></li><li><h5 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h5><ul><li>较强的语义表达能力</li><li>能够方便、直接地表达应用中的各种语义知识</li><li>简单、清晰、易于用户理解</li></ul></li></ul><blockquote><p>现实世界有哪些最基本的概念？</p><ul><li><p>实体（Entity） 客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。</p></li><li><p>属性（Attribute） 实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。</p></li><li><p>码（Key） 唯一标识实体的属性集称为码。</p></li><li><p>域（Domain） 属性的取值范围称为该属性的域。</p></li><li><p>实体型（Entity Type） 用实体名及其属性名集合来抽象和刻画同类实体称为实体型</p><p>例子：学生（学号、姓名、性别、出生年月）</p></li><li><p>实体集（Entity Set） 同一类型实体的集合称为实体集</p><img src="/2023/02/27/shu-ju-ku-xu-lun/4.jpg" style="zoom:51%;"></li><li><p><strong>联系</strong>（Relationship）  、</p><p> 现实世界：事物内部以及事物之间的联系</p><p> 信息世界：实体内部的联系和实体之间的联系</p></li></ul></blockquote><ul><li><h5 id="两个实体型之间的联系"><a href="#两个实体型之间的联系" class="headerlink" title="两个实体型之间的联系"></a>两个实体型之间的联系</h5><ul><li><p>一对一联系</p><p>例子：一个班级只有一个正班长、一个班长只在一个班中任职等。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/5.jpg" style="zoom:42%;"><p><strong>定义</strong>：如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1:1 。</p></li><li><p>一对多联系</p><p>例子：一个班级中有若干名学生、每个学生只在一个班级中学习等。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/6.jpg" style="zoom:42%;"><p><strong>定义</strong>：如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1:n 。</p></li><li><p>多对多联系</p><p>例子：一门课程同时有若干个学生选修、一个学生可以同时选修多门课程等。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/7.jpg" style="zoom:42%;"><p><strong>定义</strong>：如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之联系，则称实体集A与实体B具有多对多联系，记为m:n 。</p></li></ul><p><strong>将三种类型的联系总结即为：</strong></p><img src="/2023/02/27/shu-ju-ku-xu-lun/8.jpg" style="zoom:42%;"></li><li><h5 id="两个以上实体类型之间的联系"><a href="#两个以上实体类型之间的联系" class="headerlink" title="两个以上实体类型之间的联系"></a>两个以上实体类型之间的联系</h5><ul><li><p>两个以上实体型之间<strong>一对多联系</strong></p><p>例子：课程、教师与参考书三个实体型每一个教师可以讲授若干门课程、每门课程可以使用若干本参考书等。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/9.jpg" style="zoom:42%;"><p><strong>定义</strong>：若实体型E1，E2，…，En存在联系，对于实体型Ej（j=1，2，…，i-1，i+1，…，n）中的给定实体，最多只和Ei中的一个实体相联系，则我们说Ei与E1，E2，…，Ei-1，Ei+1，…，En之间的联系是一对多的。</p></li><li><p>两个以上实体型间<strong>一对一联系</strong>/两个以上实体型间<strong>多对多联系</strong></p><p>例子：一个供应商可以供给多个项目多种零件每个项目可以使用多个供应商供应的零件每种零件可由不同供应商供给。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/10.jpg" style="zoom:42%;"></li><li><p>同一实体集内的<strong>各实体之间的关系</strong></p><p>例子（<strong>一对多</strong>）：职工实体型内部具有领导与被领导的联系某一职工（干部）“领导”若干名职工一个职工仅被另外一个职工直接领导这是一对多的联系。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/11.jpg" style="zoom:42%;"></li></ul></li></ul></li><li><h4 id="概念模型的一种表示方法"><a href="#概念模型的一种表示方法" class="headerlink" title="概念模型的一种表示方法"></a>概念模型的一种表示方法</h4></li></ul><p>  实体-联系方法，该方法用<strong>E-R图</strong>来描述现实世界的概念模型，E-R方法也称为E-R模型。</p><ul><li><h5 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h5><ul><li><p>实体型</p><p>用矩形表示，矩形框内写明实体名<img src="/2023/02/27/shu-ju-ku-xu-lun/12.jpg" style="zoom:42%;"></p></li><li><p>属性</p><p>用椭圆形表示，并用无向边将其与相应的实体连接起来<img src="/2023/02/27/shu-ju-ku-xu-lun/13.jpg" style="zoom:42%;"></p></li><li><p>联系</p><p>联系本身用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n或m:n）。</p></li></ul></li><li><h5 id="联系的属性："><a href="#联系的属性：" class="headerlink" title="联系的属性："></a>联系的属性：</h5><p>联系本身也是一种实体型，也可以有属性。<img src="/2023/02/27/shu-ju-ku-xu-lun/14.jpg" style="zoom:42%;"></p><p>如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来 。</p><blockquote><p><strong>例子</strong>：用E-R图表示某个工厂物资管理的概念模型实体仓库： 仓库号、面积、电话号码零件 ：零件号、名称、规格、单价、描述供应商：供应商号、姓名、地址、电话号码、帐号项目：项目号、预算、开工日期职工：职工号、姓名、年龄、职称。</p><p>实体之间的联系如下： 一个仓库可以存放多种零件，一种零件可以存放在多个仓库中。用库存量来表示某种零件在某个仓库中的数量一个仓库有多个职工当仓库保管员，一个职工只能在一个仓库工作职工之间具有领导-被领导关系。即仓库主任领导若干保管员。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/15.jpg" style="zoom:42%;"></blockquote><p>练习（画ER图）：某工厂生产若干种产品，每种产品由不同零件组成，有的零件可用在不同的产品上。这些零件由不同的原料制成，不同零件所用的原料可以相同。这些零件按所属的不同产品分别放在不同的仓库中，原料按照类别放在相应的仓库中。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/16.jpg" style="zoom:42%;"></li><li><h4 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h4><blockquote><p>现实世界-&gt;概念模型：数据库设计人员完成</p><p>概念模型-&gt;逻辑模型：数据库设计人员完成</p><p>逻辑模型-&gt;物理模型：由DBMS完成</p></blockquote><p>数据模型是严格定义的一组概念的集合。通常由<strong>数据结构</strong>、<strong>数据操作</strong>和<strong>数据的完整性约束条件</strong>三部分组成。</p><ul><li><p><strong>数据结构</strong></p><p>描述数据库的组成对象，以及对象之间的联系。</p><p>描述的内容：</p><ul><li>与数据类型、内容、性质有关的对象</li><li>与数据之间联系有关的对象</li></ul><p>==<u>数据结构是对系统静态特性的描述</u>==。</p></li><li><p><strong>数据操作</strong></p><p>对数据库中各种对象(型)的实例(值)允许执行的操作及有关的操作规则。</p><p>数据操作的类型：</p><ul><li>查询</li><li>更新(包括插入、删除、修改)</li></ul><p>数据模型对操作的定义：</p><ul><li>操作的确切含义</li><li>操作符号操作规则（如优先级）</li><li>实现操作的语言</li></ul><p>==<u>数据操作是对系统动态特性的描述</u>==。</p></li><li><p><strong>数据的完整性约束条件</strong></p><p>一组完整性规则的集合。</p><p><strong>完整性规则：</strong></p><p>给定的数据模型中数据及其联系所具有的制约和储存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</p><p><strong>数据模型对完整性约束条件的定义：</strong></p><ul><li><p>必须遵守的基本的通用的完整性约束条件。</p><p>例如，关系模型中，任何关系必须满足实体完整性和参照完整性两个条件。</p></li><li><p>反映具体应用所涉及的特定的约束条件。</p><p>例子：学校数据库中规定博士学生的年龄必须小于45岁</p><p>例子：银行的系统中规定帐号的余额不能小于1元</p></li></ul></li></ul></li><li><h4 id="最常用的数据模型"><a href="#最常用的数据模型" class="headerlink" title="最常用的数据模型"></a>最常用的数据模型</h4><ul><li><p>格式化模型</p><ul><li>层次模型</li><li>网状模型</li></ul></li><li><p>关系模型</p></li><li><p>面向对象模型</p></li><li><p>对象关系模型</p></li></ul></li><li><h4 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h4><p>是数据库系统中最早出现的数据模型，用<strong>树形结构</strong>来表示各类实体以及实体间的联系。</p><p>满足下面两个条件的基本层次联系的集合称为层次模型：</p><ul><li><p>有且只有一个结点没有双亲结点，这个结点称为根结点</p></li><li><p>根以外的其它结点有且只有一个双亲结点</p></li><li><p>层次模型中的几个术语：根结点，双亲结点，兄弟结点，叶结点</p><img src="/2023/02/27/shu-ju-ku-xu-lun/17.jpg" style="zoom:42%;"></li></ul></li><li><h4 id="层次数据模型的数据结构"><a href="#层次数据模型的数据结构" class="headerlink" title="层次数据模型的数据结构"></a>层次数据模型的数据结构</h4><ul><li><p><strong>表示方法：</strong></p><ul><li><p>实体型：用记录类型描述，每个结点表示一个记录类型（实体）</p></li><li><p>属性：用字段描述，每个记录类型可包含若干个字段</p></li><li><p>联系：用结点之间的连线表示记录类型（实体）之间的一对多的父子联系</p><img src="/2023/02/27/shu-ju-ku-xu-lun/18.jpg" style="zoom:42%;"></li></ul></li><li><p><strong>用JSON表示的层次数据模型</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">'[{"系号": "D02", "系名": "计算机", "系址": "信息楼", "教研室": [{"教研室号": "R01", "教研室名": "数据库", "教师": [{"教工号": "E2101", "姓名": "王大明", "研究方向": "数据库"}, {"教工号": "E1709", "姓名": "冯灵", "研究方向": "数据仓库"}, {"教工号": "E3501", "姓名": "孟勇", "研究方向": "并行数据库"}]}, {"教研室号": "R01", "教研室名": "信息系统", "教师": []}, {"教研室号": "R03", "教研室名": "网络", "教师": [{"教工号": "E1101", "姓名": "陈芝", "研究方向": "网络安全"}, {"教工号": "E3102", "姓名": "张豪", "研究方向": "网络管理"}]}], "学生": [{"学号": "63871", "姓名": "文继容", "GPA": "A"}, {"学号": "S63874", "姓名": "刘华", "GPA": "C"}, {"学号": "S63876", "姓名": "张孝", "GPA": "A"}]}]'for dept in d:    for group in dept['教研室']:        for teacher in group['教师']:            if teacher['教工号'] == 'E1709':                print(teacher)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>多对多联系在层次模型中的表示</strong></p><ul><li><p>用层次模型间接表示多对多联系</p></li><li><p>方法：</p><p>将多对多联系分解成一对多联系</p></li><li><p>分解方法：</p><ul><li><p>冗余结点法</p><p>通过增设两个冗余结点将上图中的多对多联系转换成两个一对多联系（b）。</p></li><li><p>虚拟结点法</p><p>即将冗余结点法中新增的结点用其指针代替（c）。</p><blockquote><p>例子：学生选课数据库</p></blockquote><blockquote><img src="/2023/02/27/shu-ju-ku-xu-lun/19.jpg" style="zoom:42%;"></blockquote></li></ul></li></ul></li></ul></li><li><h4 id="层次模型的数据操纵与完整性约束"><a href="#层次模型的数据操纵与完整性约束" class="headerlink" title="层次模型的数据操纵与完整性约束"></a>层次模型的数据操纵与完整性约束</h4><p><strong>层次模型的数据操纵:</strong></p><ul><li>查询</li><li>插入</li><li>删除</li><li>更新</li></ul><p><strong>层次模型的完整性约束条件:</strong></p><ul><li>无相应的双亲结点值就不能插入子女结点值</li><li>如果删除双亲结点值，则相应的子女结点值也被同时删除</li></ul></li><li><h4 id="层次数据模型的存储结构"><a href="#层次数据模型的存储结构" class="headerlink" title="层次数据模型的存储结构"></a>层次数据模型的存储结构</h4><ul><li><p><strong>邻接法</strong></p><p>按照层次树前序遍历的顺序把所有记录值依次邻接存放，即通过物理空间的位置相邻来实现层次顺序。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/20.jpg" style="zoom:42%;"></li><li><p><strong>链接法</strong></p><ul><li><p>用指引来反映数据之间的层次联系</p></li><li><p>子女－兄弟链接法</p><p>每个记录设两类指针，分别指向最左边的子女（每个记录型对应一个）和最近的兄弟。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/21.jpg" style="zoom:42%;"></li><li><p>层次序列链接法</p><p>按树的前序穿越顺序链接各记录值。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/22.jpg" style="zoom:42%;"></li></ul></li></ul></li><li><h4 id="层次模型的优缺点"><a href="#层次模型的优缺点" class="headerlink" title="层次模型的优缺点"></a>层次模型的优缺点</h4><p><strong>优点：</strong></p><ul><li>层次模型的数据结构比较简单清晰</li><li>查询效率高，性能优于关系模型，不低于网状模型</li><li>层次数据模型提供了良好的完整性支持</li></ul><p><strong>缺点：</strong></p><ul><li>多对多联系表示不自然</li><li>对插入和删除操作的限制多，应用程序的编写比较复杂</li><li>查询子女结点必须通过双亲结点</li></ul></li><li><h4 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h4><p>网状数据库系统采用网状模型作为数据的组织方式，典型代表是DBTG系统。</p><p>满足下面两个条件的基本层次联系的集合：</p><ul><li><p>允许一个以上的结点无双亲</p></li><li><p>一个结点可以有多于一个的双亲</p><p>允许两个结点之间有多种联系（复合联系）</p></li></ul><p><u>==网状模型可以更直接地去描述现实世界，层次模型实际上是网状模型的一个特例==</u></p><img src="/2023/02/27/shu-ju-ku-xu-lun/23.jpg" style="zoom:42%;"><p><strong>多对多联系在网状模型中的表示</strong>：</p><p>用网状模型间接表示多对多联系</p><ul><li><p>方法：将多对多联系直接分解成一对多联系</p></li><li><p>例如：一个学生可以选修若干门课程，某一课程可以被多个学生选修，学生与课程之间是多对多联系     引进一个学生选课的联结记录，由3个数据项组成：学号、课程号、成绩</p><p>表示某个学生选修某一门课程及其成绩。</p><img src="/2023/02/27/shu-ju-ku-xu-lun/24.jpg" style="zoom:42%;"><p>网状数据库系统（如DBTG）对数据操纵加了一些限制，提供了一定的完整性约束</p><ul><li><p>码：唯一标识记录的数据项的集合</p></li><li><p>支持双亲记录和子女记录之间某些约束条件</p><p>有些子女记录要求双亲记录存在才能插入，双亲记录删除时也连同删除。例如学生选课记录。 </p></li><li><p>关键：实现记录之间的联系</p></li><li><p>常用方法：单向链接、双向链接、环状链接、向首链接</p></li></ul>  <img src="/2023/02/27/shu-ju-ku-xu-lun/25.jpg" style="zoom:42%;"></li></ul></li><li><h4 id="网状数据模型的优缺点"><a href="#网状数据模型的优缺点" class="headerlink" title="网状数据模型的优缺点"></a>网状数据模型的优缺点</h4><ul><li><p>优点能更为直接地描述现实世界，如一个结点可以有多个双亲具有良好的性能，存取效率较高</p></li><li><p>缺点结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握DDL、DML语言复杂，用户不容易使用记录类型联系变动后涉及链接指针的调整，扩充和维护都比较复杂 。</p></li></ul></li><li><h4 id="格式化模型的共同缺点"><a href="#格式化模型的共同缺点" class="headerlink" title="格式化模型的共同缺点"></a>格式化模型的共同缺点</h4><ul><li><p>记录之间的联系是通过存取路径实现的，应用程序在访问数据时必须选择适当的存取路径，用户必须了解系统结构的细节，加重了编写应用程序的负担。</p></li><li><p>不支持集合处理，未提供一次处理多个记录的功能。</p></li></ul></li><li><h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>最重要的一种数据模型，采用关系模型作为数据的组织方式。</p><p><em><strong>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</strong></em></p><img src="/2023/02/27/shu-ju-ku-xu-lun/26.jpg" style="zoom:42%;"></li><li><h4 id="关系数据模型的数据结构"><a href="#关系数据模型的数据结构" class="headerlink" title="关系数据模型的数据结构"></a>关系数据模型的数据结构</h4><ul><li><p>关系（Relation）：一个关系对应通常说的一张表</p></li><li><p>元组（Tuple）：表中的一行即为一个元组</p></li><li><p>属性（Attribute）：表中的一列即为一个属性，给每一个属性起一个名称即属性名</p></li><li><p>主码（Key）：表中的某个属性组，它可以唯一确定一个元组</p></li><li><p>域（Domain）：属性的取值范围。分量元组中的一个属性值</p></li><li><p>关系模式：对关系的描述</p><p>关系名（属性1，属性2，…，属性n）</p><p>学生（学号，姓名，年龄，性别，系，年级）</p><img src="/2023/02/27/shu-ju-ku-xu-lun/27.jpg" style="zoom:42%;"><img src="/2023/02/27/shu-ju-ku-xu-lun/28.jpg" style="zoom:42%;"><img src="/2023/02/27/shu-ju-ku-xu-lun/29.jpg" style="zoom:42%;"><img src="/2023/02/27/shu-ju-ku-xu-lun/30.jpg" style="zoom:42%;"></li></ul></li><li><h4 id="关系数据模型的操纵与完整性约束"><a href="#关系数据模型的操纵与完整性约束" class="headerlink" title="关系数据模型的操纵与完整性约束"></a>关系数据模型的操纵与完整性约束</h4><p>数据操作是<strong>集合</strong>操作，操作对象和结果都是关系</p><ul><li>查询</li><li>插入</li><li>删除</li><li>更新</li></ul><p>关系的完整性约束条件</p><ul><li><p>实体完整性</p></li><li><p>参照完整性</p></li><li><p>用户定义的完整性</p></li></ul><p><u>==关系必须是规范化的：每一个分量必须是一个不可分的数据项，不允许表中还有表。==</u></p></li><li><h4 id="关系数据模型的存储结构"><a href="#关系数据模型的存储结构" class="headerlink" title="关系数据模型的存储结构"></a>关系数据模型的存储结构</h4><ul><li><p>实体及实体间的联系都用表来表示</p></li><li><p>表以文件形式存储</p><ul><li><p>有的DBMS一个表对应一个操作系统文件</p></li><li><p>有的DBMS自己设计文件结构</p></li></ul></li></ul></li><li><h4 id="关系数据模型的优缺点"><a href="#关系数据模型的优缺点" class="headerlink" title="关系数据模型的优缺点"></a>关系数据模型的优缺点</h4><ul><li><p>优点</p><ul><li><p>建立在严格的数学概念的基础上</p></li><li><p>可以描述一对一、一对多和多对多的联系</p></li><li><p>概念单一</p><p>实体和各类联系都用关系来表示</p><p>对数据的检索结果也是关系</p></li><li><p>存取路径对用户透明</p><p>用户只要指出“干什么”，不必详细说明“怎么干”</p><p>具有更高的数据独立性，更好的安全保密性</p><p>简化了程序员的工作和数据库开发建立的工作</p></li></ul></li><li><p>缺点</p><ul><li><p>存取路径对用户透明导致查询效率往往不如非关系数据模型</p></li><li><p>为提高性能，必须对用户的查询请求进行优化增加了开发DBMS的难度</p></li></ul></li></ul></li><li><h4 id="E-R图转关系模式"><a href="#E-R图转关系模式" class="headerlink" title="E-R图转关系模式"></a>E-R图转关系模式</h4><ul><li><p><strong>1：N</strong></p><img src="/2023/02/27/shu-ju-ku-xu-lun/31.jpg" style="zoom:21%;"></li><li><p><strong>M:N</strong></p><img src="/2023/02/27/shu-ju-ku-xu-lun/32.jpg" style="zoom:21%;"></li></ul></li></ul><h3 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h3><ul><li><p>从数据库最终<strong>用户角度</strong>看，数据库系统的结构分为:</p><ul><li><p><strong>单用户结构</strong></p><p>整个数据库系统(应用程序、DBMS、数据)装在一台计算机上，为一个用户独占，不同机器之间不能共享数据</p></li><li><p><strong>主从式结构</strong></p><p>一个主机带多个终端的多用户结构</p><ul><li>数据库系统，包括应用程序、DBMS、数据，都集中存放在<strong>主机</strong>上，所有处理任务都由主机来完成</li><li>各个用户通过主机的终端并发地存取数据库，共享数据资源</li></ul><p><strong>优点</strong>：易于管理、控制与维护</p><p><strong>缺点</strong>：</p><ul><li>当终端用户数目增加到一定程度后，主机的任务会过分繁重，成为瓶颈，从而使系统性能下降。</li><li>系统的可靠性依赖主机,当主机出现故障时，整个系统都不能使用。</li></ul></li><li><p><strong>分布式结构</strong></p><p>数据库中的数据在==逻辑上是一个整体==，但==物理地分布==在计算机网络的不同结点上。网络中的每个结点都可以独立处理本地数据库中的数据，执行局部应用同时也可以同时存取和处理多个异地数据库中的数据，执行全局应用</p><p><strong>优点</strong>：适应了地理上分散的公司、团体和组织对于数据库应用的需求</p><p><strong>缺点</strong>：</p><ul><li>数据的分布存放给数据的处理、管理与维护带来困难。</li><li>当用户需要经常访问远程数据时，系统效率会明显地受到网络传输的制约。</li></ul></li><li><p><strong>客户／服务器</strong></p><p>把DBMS功能和应用分开</p><ul><li>网络中某个（些）结点上的计算机专门用于执行DBMS功能，称为数据库服务器，简称服务器</li><li>其他结点上的计算机安装DBMS的外围应用开发工具，用户的应用系统，称为客户机</li></ul><p><u><em>集中的服务器结构</em>：</u></p><p>一台数据库服务器，多台客户机</p><p><u><em>分布的服务器结构</em>：</u></p><ul><li><p>在网络中有多台数据库服务器</p></li><li><p>分布的服务器结构是客户／服务器与分布式数据库的结合</p></li><li><p>数据库更加开放</p><p>客户与服务器一般都能在多种不同的硬件和软件平台上运行</p><p>可以使用不同厂商的数据库应用开发工具</p></li><li><p>易于扩展和共享</p></li></ul><p><strong>客户／服务器结构缺点：</strong></p><p>“胖客户”问题：</p><ul><li>系统安装复杂，工作量大。 </li><li>应用维护困难，难于保密，造成安全性差。</li><li>相同的应用程序要重复安装在每一台客户机上，从系统总体来看，大大浪费了系统资源。   </li><li>系统规模达到数百数千台客户机，它们的硬件配置、操作系统又常常不同，要为每一个客户机安装应用程序和相应的工具模块，其安装维护代价便不可接受了。</li></ul></li><li><p><strong>浏览器／应用服务器／数据库服务器多层结构等</strong></p><ul><li>客户端：<ul><li>浏览器软件</li><li>浏览器的界面统一，广大用户容易掌握</li><li>大大减少了培训时间与费用。</li></ul></li><li>服务器端分为两部分：<ul><li>Web服务器、应用服务器数据库服务器等</li><li>大大减少了系统开发和维护代价,能够支持数万甚至更多的用户</li></ul></li></ul></li></ul></li><li><p>从数据库<strong>管理系统角度</strong>看，数据库系统通常采用<strong>三级模式结构</strong>，是<strong>数据库系统内部</strong>的系统结构 </p><p><strong>型</strong>和<strong>值</strong>的概念：</p><ul><li><p>型：对某一类数据的结构和属性的说明</p></li><li><p>值：是型的一个具体赋值</p><p>例如：</p><p>学生记录型：（学号，姓名，性别，系别，年龄，籍贯）</p><p>一个记录值： （900201，李明，男，计算机，22，江苏）</p></li></ul><p><strong>模式</strong>：</p><ul><li>数据库逻辑结构和特征的描述</li><li>是型的描述</li><li>反映的是数据的结构及其联系</li><li>模式是相对稳定的</li></ul><p><strong>实例</strong>：</p><ul><li>模式的一个具体值</li><li>反映数据库某一时刻的状态</li><li>同一个模式可以有很多实例</li><li>实例随数据库中的数据的更新而变动</li></ul><p><strong>例如</strong>：</p><p>在学生选课数据库模式中，包含学生记录型、课程记录型和学生选课记录型 </p><ul><li><p>2019年的一个学生数据库实例包含：</p><ul><li><p>2019年学校中所有学生的记录</p></li><li><p>学校开设的所有课程的记录</p></li><li><p>所有学生选课的记录</p></li></ul></li><li><p>2018年度学生数据库模式对应的实例与2019年度学生数据库模式对应的实例是<strong>不同</strong>的</p></li></ul></li><li><h4 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h4><img src="/2023/02/27/shu-ju-ku-xu-lun/33.jpg" style="zoom:45%;"><ul><li><p><strong>模式</strong>：</p><p>也称作逻辑模式</p><ul><li>数据库中全体数据的逻辑结构和特征的描述</li><li>所有用户的公共数据视图，综合了所有用户的需求</li></ul><p>==一个数据库只有一个模式==</p><p>地位：是数据库系统模式结构的中间层</p><ul><li>与数据的物理存储细节和硬件环境无关</li><li>与具体的应用程序、开发工具及高级程序设计语言无关</li></ul><p>定义：</p><ul><li><p>数据的逻辑结构（数据项的名字、类型、取值范围等）</p></li><li><p>数据之间的联系</p></li><li><p>数据有关的安全性、完整性要求</p></li></ul></li><li><p><strong>外模式</strong>：</p><p>也称为子模式或用户模式</p><ul><li>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</li><li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li></ul><p>地位：介于模式与应用之间</p><ul><li>模式与外模式的关系：一对多<ul><li>外模式通常是模式的子集</li><li>一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</li></ul></li><li>外模式与应用的关系：一对多<ul><li>同一外模式也可以为某一用户的多个应用系统所使用</li><li>但一个应用程序只能使用一个外模式</li></ul></li></ul><p>外模式的用途：</p><ul><li><p>保证数据库安全性的一个有力措施</p></li><li><p>每个用户只能看见和访问所对应的外模式中的数据</p></li></ul></li><li><p><strong>内模式</strong>：</p><p>也称为存储模式</p><ul><li>是数据物理结构和存储方式的描述</li><li>是数据在数据库内部的表示方式<ul><li>记录的存储方式（顺序存储，按照B树结构存储，   按hash方法存储）</li><li>索引的组织方式</li><li>数据是否压缩存储</li><li>数据是否加密</li><li>数据存储记录结构的规定</li></ul></li></ul><p>==一个数据库只有一个内模式==</p><p>例如：学生记录</p><p>如果按<strong>堆</strong>存储，则插入一条新记录总是放在学生记录存储的<strong>最后</strong>，如图所示</p><img src="/2023/02/27/shu-ju-ku-xu-lun/34.jpg" style="zoom:30%;"><p>如果按<strong>学号升序</strong>存储，则插入一条记录就要找到它应在的位置插入，如图所示</p><img src="/2023/02/27/shu-ju-ku-xu-lun/35.jpg" style="zoom:39%;"><p>如果按照<strong>学生年龄聚簇</strong>存放，假如新插入的S3是16岁，则应插入的位置如图所示</p><img src="/2023/02/27/shu-ju-ku-xu-lun/36.jpg" style="zoom:39%;"><p><strong>数据库系统的三级模式结构示意</strong></p><img src="/2023/02/27/shu-ju-ku-xu-lun/37.jpg" style="zoom:48%;"></li></ul></li><li><h4 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h4><p>==三级模式是对数据的三个抽象级别== </p><p>二级映象在DBMS内部实现这三个抽象层次的联系和转换</p><img src="/2023/02/27/shu-ju-ku-xu-lun/38.jpg" style="zoom:54%;"><ul><li><p><strong>外模式／模式映象</strong></p><p>同一个模式可以有任意多个外模式 每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系映象定义通常包含在各自外模式的描述中</p><p><em><u>保证数据的逻辑独立性</u></em></p><ul><li>当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变</li><li>应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</li></ul></li><li><p><strong>模式／内模式映象</strong></p></li></ul><p>  模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。</p><ul><li>例如，说明逻辑记录和字段在内部是如何表示的</li></ul><p>  数据库中模式／内模式映象是<strong>唯一</strong>的</p><p>  ==该映象定义通常包含在模式描述中==</p><p>  <u><em>保证数据的物理独立性</em></u></p><ul><li>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变</li><li>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</li></ul><p>  数据库模式</p><ul><li>即全局逻辑结构是数据库的中心与关键</li><li>独立于数据库的其他层次</li><li>设计数据库模式结构时应首先确定数据库的逻辑模式</li></ul></li></ul><p>​              </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言与逆向工程chp1</title>
      <link href="/2023/02/24/hui-bian-yu-yan-yu-ni-xiang-gong-cheng-chp1/"/>
      <url>/2023/02/24/hui-bian-yu-yan-yu-ni-xiang-gong-cheng-chp1/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言与逆向工程chp1"><a href="#汇编语言与逆向工程chp1" class="headerlink" title="汇编语言与逆向工程chp1"></a>汇编语言与逆向工程chp1</h1><h2 id="指定软件"><a href="#指定软件" class="headerlink" title="指定软件"></a>指定软件</h2><ul><li>IDA PRO  </li><li>x64 dbg</li></ul><hr><p>课程针对节点安全<br>codelite<br>十六进制    hex编辑器010editor  </p>]]></content>
      
      
      <categories>
          
          <category> 汇编语言与逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之图</title>
      <link href="/2022/11/17/shu-ju-jie-gou-zhi-tu/"/>
      <url>/2022/11/17/shu-ju-jie-gou-zhi-tu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之图"><a href="#数据结构之图" class="headerlink" title="数据结构之图"></a>数据结构之图</h1><h2 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a><strong>图的定义和术语</strong></h2><p>图：G=(V,E)<br>V:顶点的有穷非空集合；<br>E：边的有穷集合；</p><p><strong>无向图</strong>：每条边都是无方向的<br><strong>有向图</strong>：每条边都是有方向的 </p><p><strong>完全图</strong>：任意两个点都有一条边相连<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/1.jpg">  </p><p><strong>稀疏图</strong>：有很少边或者弧的图<br><strong>稠密图</strong>：有较多边或弧的图<br><strong>网</strong>：边、弧带权的图<br>邻接：有边、弧相连的两个顶点之间的关系<br>存在(vi，vj)，则称vi和vj互为邻接点<br>存在&lt;vi，vj&gt;，则称vi邻接到vj，vj邻接于vi<br>**关联(依附)**：边、弧与顶点之间的关系，存在(vi，vj)/&lt;vi，vj&gt;,则称该边/弧关联于vi和vj  </p><p><strong>顶点的度</strong>：与该顶点相关联的边的数目，记为TD(v)</p><blockquote><p>在有向图中，顶点的度等于该顶点的入度与出度之和，顶点v的入度是以v为终点的有向边的条数，记为ID(v)；顶点的出度是以v为始点的有向边的条数，记作OD(v)<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/2.jpg">  </p></blockquote><p><strong>路径</strong>：接续的边构成的顶点序列<br><strong>路径长度</strong>：路径上边或弧的数目/权值之和<br><strong>回路</strong>：第一个顶点和最后一个顶点相同的路径<br><strong>简单路径</strong>：除路径起点和终点可以相同外，其余顶点均不相同<br><strong>简单回路</strong>：除路径起点和终点相同外，其余顶点均不相同  </p><blockquote><p><strong>连通图(强联通图)</strong><br>任意两个顶点都存在路径<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/3.jpg">  </p></blockquote><p><strong>权与网</strong>：图中边或弧所具有的相关数称为权，表明从一个顶点到顶一个顶点的距离或耗费<br><strong>子图</strong>：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/4.jpg">  </p><p>**连通分量(强连通分量)**：<br>无向图<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/5.jpg"><br>有向图：<br>有向图的极大连通子图称为其强连通分量<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/6.jpg">  </p><p><strong>极小连通子图</strong>：该子图是G的连通子图，在该子图中删除任意一条边会使子图不再连通<br><strong>生成树</strong>：包含无向图G所有顶点的极小连通子图<br><strong>生成森林</strong>：对非连通图，由各个连通分量的生成树的集合<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/7.jpg">  </p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><strong>图的存储结构</strong></h2><p>1.数组表示法（邻接矩阵）<br>2.链式存储结构：邻接表、邻接多重表、十字链表</p><h3 id="数组表示法（邻接矩阵）"><a href="#数组表示法（邻接矩阵）" class="headerlink" title="数组表示法（邻接矩阵）"></a><strong>数组表示法（邻接矩阵）</strong></h3><p>建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间的关系）<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/8.jpg"><br><strong>无向图的邻接矩阵表示法</strong><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/9.jpg"><br><strong>有向图的邻接矩阵表示法</strong><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/10.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/11.jpg"><br><strong>网（有权图）的邻接矩阵表示法</strong><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/12.jpg">  </p><h4 id="邻接矩阵的存储表示"><a href="#邻接矩阵的存储表示" class="headerlink" title="邻接矩阵的存储表示"></a><strong>邻接矩阵的存储表示</strong></h4><p>用两个数组分别存储顶点表和邻接矩阵  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MaxInt 32767 //表示极大值#define MVNum 100 //最大顶点数typedef char VerTexType;//设定点的数据类型为字符型 typedef int ArcType;//假设边的权值类型为整型  typedef struct {    VerTexType vexs[MVNum];//顶点表    ArcType arcs[MVNum][MVNum]; //邻接矩阵    int vexnum,arcnum;//图的当前点数和边数}AMGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/13.jpg"> </p><h5 id="算法1-采用邻接矩阵表示法创建无向图"><a href="#算法1-采用邻接矩阵表示法创建无向图" class="headerlink" title="算法1 采用邻接矩阵表示法创建无向图"></a><strong>算法1</strong> 采用邻接矩阵表示法创建无向图</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status CreateUND(AMGragh &amp;G){   cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;//输入总顶点数、总边数     for(i=0;i&lt;G.vexnum;++i){    cin&gt;&gt;G.vex[i];//依次输入点的信息   }   for(i=0;i&lt;G.vexnum;++i)    for(j=0;j&lt;G.vexnum;++j)     G.arcs[i][j]=Maxint;//边的权值均置为极大值      for(k=0;k&lt;G.arcnum;++k){    //构造邻接矩阵    cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;//输入一条边所依附的顶点及边的权值      i=LocateVex(G,v1);    j=LocateVex(G,v2);//确定v1和v2在G的位置     G.arcs[i][j]=w;     G.arcs[j][i]=G.arcs[i][j];//边&lt;v1,v2&gt;的权值设置为w，置对称边权值为w   }   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="补充算法-在图中查找顶点"><a href="#补充算法-在图中查找顶点" class="headerlink" title="补充算法 在图中查找顶点"></a><strong>补充算法</strong> 在图中查找顶点</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">int LocateVex(AMGraph G,VertexType u){    //在图G查找顶点u，返回顶点下标    int i;    for(i=0;i&lt;G.vexnum;++i){        if(u==G.vex[i])return i;    }    return -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="邻接矩阵的优缺"><a href="#邻接矩阵的优缺" class="headerlink" title="邻接矩阵的优缺"></a><strong>邻接矩阵的优缺</strong></h4><blockquote><p>优点：<img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/14.jpg">  </p></blockquote><blockquote><p>缺点：<img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/15.jpg">  </p></blockquote><h3 id="邻接表表示法-链式"><a href="#邻接表表示法-链式" class="headerlink" title="邻接表表示法(链式)"></a><strong>邻接表表示法(链式)</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/16.jpg">  </p><p>无向图：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/17.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/18.jpg"></p><p>有向图：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/19.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/20.jpg">  </p><h4 id="邻接表的存储表示"><a href="#邻接表的存储表示" class="headerlink" title="邻接表的存储表示"></a><strong>邻接表的存储表示</strong></h4><p>顶点的结点结构</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct VNode{    VerTexType data;//顶点信息    ArcNode *firstarcs; //指向第一条依附该顶点的边的指针}VNode,AdjList[MVNum];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>例如AdjList v;相当于：VNode v[MVNum];  </p></blockquote><p>边结点结构  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MVNum 100//最大顶点数typedef struct ArcNode{    //边结点    int adjvex//该边所指向的顶点位置    struct ArcNode *nextarc;//指向下条边的指针    OtherInfo info; //和边相关的信息}ArcNode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图的结构定义</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {    AdjList vertices;//vertices--vertex的复数    int vexnum,arcnum;//图的当前顶点数和弧数}ALGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>邻接表操作举例说明：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/21.jpg"><br>采用邻接表表示法创建无向图  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status CreateUDG(ALGraph &amp;G) {    //采用邻接表表示法，创建无向图G    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;    for(i=0;i&lt;G.vexnum;++i){        cin&gt;&gt;G.vertices[i].data;        G.vertices[i].firstarc=NULL;    }    for(k=0;k&lt;G.arcnum;++k){        cin&gt;&gt;v1&gt;&gt;v2;        i=LocateVex(G,v1);        j=LocateVex(G,v2);        p1=new ArcNode;        p1-&gt;adjvex=j;        p1-&gt;nexrarc=G.vertices[i].firstarc;        G.vertices[i].firstarc=p1;        p2=new ArcNode;        p2-&gt;adjvex=i;        p2-&gt;nexrarc=G.vertices[j].firstarc;        G.vertices[j].firstarc=p2;    }    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="邻接表的优缺"><a href="#邻接表的优缺" class="headerlink" title="邻接表的优缺"></a><strong>邻接表的优缺</strong></h4><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/22.jpg"><br>邻接矩阵与邻接表的关系<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/23.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/24.jpg"><br>可供选择的其他存储结构<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/25.jpg"></p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a><strong>十字链表</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/26.jpg">  </p><blockquote><p>顶点结点：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/27.jpg"><br>firstin:第一条入弧<br>firstout:第一条出弧</p></blockquote><blockquote><p>弧结点：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/28.jpg"><br>tailvex:弧尾位置<br>headvex:弧头位置<br>hlink:弧头相同的下一条弧<br>tlink:弧尾相同的下一条弧</p></blockquote><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/29.jpg"></p><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a><strong>邻接多重表</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/30.jpg"></p><h2 id="图的遍历-深度优先"><a href="#图的遍历-深度优先" class="headerlink" title="图的遍历-深度优先"></a><strong>图的遍历-深度优先</strong></h2><p>定义：从已给的连通图中某一顶点出发，沿着一些边访遍图中的所有顶点，且使每个顶点仅被访问一次    </p><p>遍历实质：找到邻接点  </p><blockquote><p>图的特点：<br> 图中可能存在回路，且图的任一顶点都可能与其他顶点相通，在访问完某个顶点之后可能会沿着某些边又回到曾经访问过的顶点，如何避免？  </p></blockquote><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/31.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/32.jpg"></p><h3 id="邻接矩阵表示的无向图深度遍历实现"><a href="#邻接矩阵表示的无向图深度遍历实现" class="headerlink" title="邻接矩阵表示的无向图深度遍历实现"></a><strong>邻接矩阵表示的无向图深度遍历实现</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/33.jpg">  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void DFS(AMGraph G,int v){    //图G为邻接矩阵类型    cout&lt;&lt;v;    visited[v]=true;//访问第v个顶点    for(w=0;w&lt;G.vexnum;w++)//依次检查邻接矩阵v所在的行    if((G.arcs[v][w]!=0)&amp;&amp;(!visited[w]))DFS(G,w);    //w是v的邻接点，如果w未访问，则递归调用DFS}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="深度遍历效率"><a href="#深度遍历效率" class="headerlink" title="深度遍历效率"></a><strong>深度遍历效率</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/34.jpg">  </p><h3 id="非连通图的深度优先遍历"><a href="#非连通图的深度优先遍历" class="headerlink" title="非连通图的深度优先遍历"></a><strong>非连通图的深度优先遍历</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/35.jpg">  </p><h2 id="图的遍历-广度优先"><a href="#图的遍历-广度优先" class="headerlink" title="图的遍历-广度优先"></a><strong>图的遍历-广度优先</strong></h2><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/36.jpg">  </p><h3 id="邻接表表示的无向图广度遍历实现"><a href="#邻接表表示的无向图广度遍历实现" class="headerlink" title="邻接表表示的无向图广度遍历实现"></a><strong>邻接表表示的无向图广度遍历实现</strong></h3><p>利用队列实现<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/37.jpg"><br>F：队头指针  R：队尾指针  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void BFS(Graph G,int v){    //按广度优先非递归遍历图G    cout&lt;&lt;v;    visited[v]=true;//访问第v个顶点    InitQueue(Q);//辅助队列Q初始化，置空      EnQueue(Q,v);//v进队      while(!QueueEmpty(Q)){//队列非空        DeQueue(Q,u);//队头元素出队并置为u        for(w=FirstAdjVex(G,u);w&gt;=0;w=NextAdjVex(G,u,w))        if(!visited[w]){            //w为u的尚未访问的邻接顶点            cout&lt;&lt;w;visited[w]=true;            EnQueue(Q,w);//w进队        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="广度遍历与深度遍历的比较"><a href="#广度遍历与深度遍历的比较" class="headerlink" title="广度遍历与深度遍历的比较"></a><strong>广度遍历与深度遍历的比较</strong></h2><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/38.jpg">  </p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a><strong>最小生成树</strong></h2><blockquote><p>回顾：生成树：所有顶点均由边连接在一起，但是不存在回路的图<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/39.jpg"><br>·一个图可以有许多棵不同的生成树<br>·所有生成树具有以下共同特点：<br>1.生成树的顶点个数与图的顶点个数相同<br>2.生成树是图的极小连通子图<br>3.在生成树中再加一条边必然形成回路<br>4.生成树中任意两个顶点间的路径是唯一的  </p></blockquote><h3 id="无向图的生成树"><a href="#无向图的生成树" class="headerlink" title="无向图的生成树"></a><strong>无向图的生成树</strong></h3><p>利用优先遍历即可  </p><blockquote><p>深度优先遍历形成的生成树<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/40.jpg"></p></blockquote><blockquote><p>广度优先遍历形成的生成树<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/41.jpg"></p></blockquote><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/42.jpg"></p><h3 id="最小生成树的定义"><a href="#最小生成树的定义" class="headerlink" title="最小生成树的定义"></a><strong>最小生成树的定义</strong></h3><p>给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那颗生成树称为最小生成树  </p><h3 id="构造最小生成树"><a href="#构造最小生成树" class="headerlink" title="构造最小生成树"></a><strong>构造最小生成树</strong></h3><blockquote><p>MST性质（一种贪心算法）：设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u，v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一棵包含边(u，v)的最小生成树。<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/43.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/44.jpg">  </p></blockquote><h3 id="构造最小生成树方法1-Prime算法"><a href="#构造最小生成树方法1-Prime算法" class="headerlink" title="构造最小生成树方法1-Prime算法"></a><strong>构造最小生成树方法1-Prime算法</strong></h3><p>算法思想：  不断扩大最小生成树的范围<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/45.jpg">  </p><h3 id="构造最小生成树方法2-Kruskal算法"><a href="#构造最小生成树方法2-Kruskal算法" class="headerlink" title="构造最小生成树方法2-Kruskal算法"></a><strong>构造最小生成树方法2-Kruskal算法</strong></h3><p>算法思想：直接选当前最小的边<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/46.jpg">  </p><p>注：最小生成树可能不唯一  </p><h3 id="两种算法的比较"><a href="#两种算法的比较" class="headerlink" title="两种算法的比较"></a><strong>两种算法的比较</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/47.jpg">  </p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a><strong>最短路径</strong></h2><p>顶点：表示地点<br>弧：表示两地连通<br>弧上的权值：表示距离或花费等等<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/48.jpg">  </p><h3 id="第一类问题：两点间的最短路径"><a href="#第一类问题：两点间的最短路径" class="headerlink" title="第一类问题：两点间的最短路径"></a><strong>第一类问题：两点间的最短路径</strong></h3><p>所有顶点间的最短路径-弗洛伊德算法<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/49.jpg">  </p><h3 id="第二类问题：某源点到其他各点最短路径"><a href="#第二类问题：某源点到其他各点最短路径" class="headerlink" title="第二类问题：某源点到其他各点最短路径"></a><strong>第二类问题：某源点到其他各点最短路径</strong></h3><p>单源最短路径-迪杰斯特拉算法<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/50.jpg">  </p><h3 id="单源最短路径-迪杰斯特拉算法"><a href="#单源最短路径-迪杰斯特拉算法" class="headerlink" title="单源最短路径-迪杰斯特拉算法"></a><strong>单源最短路径-迪杰斯特拉算法</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/51.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/52.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/53.jpg">  </p><h3 id="所有顶点间的最短路径-弗洛伊德算法"><a href="#所有顶点间的最短路径-弗洛伊德算法" class="headerlink" title="所有顶点间的最短路径-弗洛伊德算法"></a><strong>所有顶点间的最短路径-弗洛伊德算法</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/54.jpg">  </p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><strong>拓扑排序</strong></h2><p>有向无环图：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/55.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/56.jpg">  </p><h3 id="拓扑排序例子"><a href="#拓扑排序例子" class="headerlink" title="拓扑排序例子"></a><strong>拓扑排序例子</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/57.jpg"><br>AOV网的特点：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/58.jpg">  </p><h3 id="拓扑排序定义"><a href="#拓扑排序定义" class="headerlink" title="拓扑排序定义"></a><strong>拓扑排序定义</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/59.jpg">  </p><h3 id="拓扑排序方法"><a href="#拓扑排序方法" class="headerlink" title="拓扑排序方法"></a><strong>拓扑排序方法</strong></h3><p>简言之：一直选择没有前驱的点<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/60.jpg">  </p><p>检测AOV网中是否存在环的方法<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/61.jpg">  </p><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a><strong>关键路径</strong></h2><p>例：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/62.jpg"><br>把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续的时间<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/63.jpg">  </p><p>关键路径：路径长度最长的路径<br>路径长度：路径上各活动持续时间之和<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/64.jpg">  </p><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/65.jpg">  </p><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/66.jpg">  </p><p>求关键路径步骤：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/67.jpg"><br>时间余量为0即为关键活动<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/68.jpg">  </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之数和二叉树</title>
      <link href="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/"/>
      <url>/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之树和二叉树"><a href="#数据结构之树和二叉树" class="headerlink" title="数据结构之树和二叉树"></a>数据结构之树和二叉树</h1><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a><strong>树和二叉树</strong></h2><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/1.jpg">  </p><blockquote><p>树形结构<br>非线性结构：结点之间有分支、具有层次关系  </p></blockquote><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a><strong>树的定义</strong></h2><p>是n个结点的有限集<br>若n=0，称为空数，若n&gt;0，则它满足以下两个条件： </p><p>  (1)有且仅有一个特定的称为根的结点；  </p><p>  (2)其余节点可分为m(m&gt;=0)个互不相交的有限集，其中每一个集合本身又是一棵树，称为根的子树  （递归的定义）</p><h2 id="数的基本术语"><a href="#数的基本术语" class="headerlink" title="数的基本术语"></a><strong>数的基本术语</strong></h2><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/1.jpg">  </p><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/2.jpg">  </p><p>有序数：树中结点的各子树从左至右有次序(最左边的为第一个孩子)<br>无序数：树中结点的各子树无次序  </p><p>森林：是m（m&gt;=0）棵互不相交的树的集合，把根结点删除数就变成了森林，一棵树可以看成是一个特殊的森林。 </p><h2 id="树结构和线性结构的比较"><a href="#树结构和线性结构的比较" class="headerlink" title="树结构和线性结构的比较"></a><strong>树结构和线性结构的比较</strong></h2><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/3.jpg">  </p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a><strong>二叉树的定义</strong></h2><p>二叉树是n个结点的有限集，它或者是空集、或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成  </p><blockquote><p>特点<br>每个结点最多有俩孩子（不存在度大于2的结点）<br>有左右之分，次序不能颠倒<br>二叉树可以是空集合，根可以有空的左子树或空的右子树  </p></blockquote><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/4.jpg">  </p><blockquote><p>具有三个结点的二叉树有几种不同形态、普通树？<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/5.jpg">  </p></blockquote><blockquote><p>二叉树的五种基本形态<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/6.jpg">  </p></blockquote><h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a><strong>案例引入</strong></h2><p><strong>案例一</strong> 数据压缩问题<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/7.jpg">  </p><p><strong>案例二</strong> 利用二叉树求解表达式的值<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/8.jpg">  </p><h2 id="树和二叉树的抽象数据类型定义"><a href="#树和二叉树的抽象数据类型定义" class="headerlink" title="树和二叉树的抽象数据类型定义"></a><strong>树和二叉树的抽象数据类型定义</strong></h2><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT BinaryTree{   数据对象D：具有相同特性的数据元素的集合   数据关系R：若D为空集，则R为空集             若D非空，则R={H}；H是如下的二元关系               1.root唯一             2.Dj并Dk为空集             3...     基本操作P：}ADT BinaryTree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>基本操作P：<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/9.jpg"></p></blockquote><h2 id="二叉树的性质和存储结构"><a href="#二叉树的性质和存储结构" class="headerlink" title="二叉树的性质和存储结构"></a><strong>二叉树的性质和存储结构</strong></h2><blockquote><p>性质1：在二叉树的第i层上至多有2的i-1次方个结点，至少有1个结点  </p></blockquote><blockquote><p>性质2；深度为k的二叉树至多有2的k次方-1个结点，至少有k个结点  </p></blockquote><blockquote><p>性质3：对任何一棵二叉树T，如果其叶子数为n0，度为2的结点数为n2，则n0=n2+1  </p></blockquote><blockquote><p>满二叉树：一棵深度为k且有2的k次方-1个结点的二叉树称为满二叉树<br>特点：<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/16.jpg"> </p></blockquote><blockquote><p>完全二叉树<br>深度为k的具有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中 的编号为1~n的结点一一对应时，称之为完全二叉数<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/17.jpg"><br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/18.jpg">  </p></blockquote><h3 id="完全二叉树的性质"><a href="#完全二叉树的性质" class="headerlink" title="完全二叉树的性质"></a><strong>完全二叉树的性质</strong></h3><blockquote><p>性质4：具有n个结点的完全二叉树的深度为<img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/19.jpg">  </p></blockquote><blockquote><p>性质5：<img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/20.jpg">  </p></blockquote><h3 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a><strong>二叉树的顺序存储结构</strong></h3><p>实现：按满二叉树的节点层次编号，依次存放二叉树中的数据元素  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">//二叉树顺序存储表示#define MAXSIZE 100typedef TElemType SqBiTree[MAXSIZE];SqBiTree bt;//定义名为bt的数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/21.jpg">    </p><p>二叉树的顺序储存缺点：<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/22.jpg"><br>浪费空间，适用于满二叉树和完全二叉树  </p><h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a><strong>二叉树的链式存储结构</strong></h3><p>二叉链表表示法<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/23.jpg">    </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct BiNode{  TElemType data;  struct BiNode *lchild,*rchild;//左右孩子指针}BiNode,*BiTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/24.jpg">   </p><blockquote><p>在n个结点的二叉链中，有n+1个空指针域<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/25.jpg">   </p></blockquote><p>三叉链表表示法</p><blockquote><p>如果我们经常需要找前趋<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/26.jpg">   </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct TriTNode{  TElemType data;  struct TriTNode *lchild,*rchild,*parent;//左右孩子指针}TriTNode,*TriTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a><strong>遍历二叉树</strong></h2><p>顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均被访问过依次，且仅被访问一次<br>遍历目的：得到树中所有结点的一个线性排列，是树结构插入、删除、修改、查找和排序的前提  </p><p>遍历方法<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/27.jpg">   </p><blockquote><p>DLR：先序遍历<br>LDR：中序遍历<br>LRD：后序遍历  </p></blockquote><h3 id="先序遍历二叉树"><a href="#先序遍历二叉树" class="headerlink" title="先序遍历二叉树"></a><strong>先序遍历二叉树</strong></h3><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/28.jpg">      </p><h3 id="中序遍历二叉树"><a href="#中序遍历二叉树" class="headerlink" title="中序遍历二叉树"></a><strong>中序遍历二叉树</strong></h3><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/29.jpg">      </p><h3 id="后序遍历二叉树"><a href="#后序遍历二叉树" class="headerlink" title="后序遍历二叉树"></a><strong>后序遍历二叉树</strong></h3><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/30.jpg">    </p><blockquote><p>由二叉树的先序序列和中序序列、或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树  </p></blockquote><p>例：已知先序和中序序列求二叉树<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/31.jpg"><br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/32.jpg"><br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/33.jpg">   </p><h3 id="先序遍历二叉树-递归算法"><a href="#先序遍历二叉树-递归算法" class="headerlink" title="先序遍历二叉树-递归算法"></a><strong>先序遍历二叉树-递归算法</strong></h3><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/34.jpg">   </p><pre class="line-numbers language-none"><code class="language-none">Status PreOrderTraverse(BiTree T){  if(T==NULL)return OK;  else{    visit(T);//访问根结点    PreOrderTraverse(T-&gt;lchild);//递归遍历左子树    PreOrderTraverse(T-&gt;rchild);//递归遍历右子树  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中序遍历二叉树-递归算法"><a href="#中序遍历二叉树-递归算法" class="headerlink" title="中序遍历二叉树-递归算法"></a><strong>中序遍历二叉树-递归算法</strong></h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InOrderTraverse(BiTree T){  if(T==NULL)return OK;  else{    InOrderTraverse(T-&gt;lchild);//递归遍历左子树    visit(T);//访问根结点    InOrderTraverse(T-&gt;rchild);//递归遍历右子树  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后序遍历二叉树-递归算法"><a href="#后序遍历二叉树-递归算法" class="headerlink" title="后序遍历二叉树-递归算法"></a><strong>后序遍历二叉树-递归算法</strong></h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status PostOrderTraverse(BiTree T){  if(T==NULL)return OK;  else{    PostOrderTraverse(T-&gt;lchild);//递归遍历左子树    PostOrderTraverse(T-&gt;rchild);//递归遍历右子树    visit(T);//访问根结点  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>遍历算法时间复杂度O(n)<br>遍历算法空间复杂度O(n)  </p></blockquote><h3 id="中序遍历二叉树-非递归算法"><a href="#中序遍历二叉树-非递归算法" class="headerlink" title="中序遍历二叉树-非递归算法"></a><strong>中序遍历二叉树-非递归算法</strong></h3><p>二叉树中序遍历的非递归算法的关键：在中序遍历过某结点的整个左子树后，如何找到该节点的根与右子树  </p><blockquote><p>基本思想：<br>(1)建立一个栈<br>(2)根结点进栈，遍历左子树<br>(3)根结点出栈，输出根结点，遍历右子树<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/35.jpg">  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InOrderTraverse(BiTree T){  BiTree p; InitStack(S);  p=T;  while(p||!StackEmpty(S)){    if(p){      Push(S,p);      p=p-&gt;lchild;    }    else{      Pop(S,q);      printf("%c",q-&gt;data);      p=q-&gt;rchild;    }  }  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的层次遍历算法"><a href="#二叉树的层次遍历算法" class="headerlink" title="二叉树的层次遍历算法"></a><strong>二叉树的层次遍历算法</strong></h3><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/36.jpg">  </p><blockquote><p>算法思路：<br> 1.将根结点进队；<br> 2.队不空时循环：从队列中出列一个结点*p,访问它；若它有左孩子结点，将左孩子结点进队，若它有右孩子结点，将右孩子结点进队  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">//使用队列类型的定义如下typedef struct{  BTNode data[MaxSize];//存放队中元素  int front,rear;//队头和队尾指针}SqQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">//二叉树层次遍历算法void LevelOrder(BTNode *b){  BTNode *p; SqQueue *qu;  InitQueue(qu);//初始化队列    enQueue(qu,b);//根结点指针进入队列  while(!QueueEmpty(qu)){//队不为空，则循环    deQueue(qu,p);//出队结点p  printf("%c",p-&gt;data);//访问结点p  if(p-&gt;lchild!=NULL)enQueue(qu,p-&gt;lchild);//有左孩子时将其进队  if(p-&gt;rchild!=NULL)enQueue(qu,p-&gt;rchild);//有右孩子时将其进队  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的建立-遍历算法的应用"><a href="#二叉树的建立-遍历算法的应用" class="headerlink" title="二叉树的建立-遍历算法的应用"></a><strong>二叉树的建立-遍历算法的应用</strong></h3><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/37.jpg">  </p><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/38.jpg">  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status CreateBiTree(BiTree &amp;T){  scanf(&amp;ch);  if(ch=="#")T=NULL;  else{    if(!(T=(BiTNode*)malloc(sizeof(BiTNode))))exit(OVERFLOW);    T-&gt;data=ch;//生成根结点      CreateBiTree(T-&gt;lchild);//构造左子树    CreateBiTree(T-&gt;rchild);//构造右子树  }  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制二叉树-遍历算法的应用"><a href="#复制二叉树-遍历算法的应用" class="headerlink" title="复制二叉树-遍历算法的应用"></a><strong>复制二叉树-遍历算法的应用</strong></h3><blockquote><p>如果是空树，递归结束<br>否则，申请新结点空间，复制根结点<br>递归复制左子树<br>递归复制右子树</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">int Copy(BiTree T,BiTree &amp;NewT){  if(T==NULL){    NewT=NULL;    return 0;  }  else {    NewT=new BiTNode;    NewT-&gt;data=T-&gt;data;    Copy(T-&gt;lChild,NewT-&gt;lchild);    Copy(T-&gt;rChild,NewT-&gt;rchild);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计算二叉树深度-遍历算法的应用"><a href="#计算二叉树深度-遍历算法的应用" class="headerlink" title="计算二叉树深度-遍历算法的应用"></a><strong>计算二叉树深度-遍历算法的应用</strong></h3><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/39.jpg">  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int Depth(BiTree T){  if(T==NULL){    return 0;  }  else {    m=Depth(T-&gt;lChild);    n=Depth(T-&gt;rChild);    if(m&gt;n)return(m+1);    else return (n+1);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计算二叉树节点总数-遍历算法的应用"><a href="#计算二叉树节点总数-遍历算法的应用" class="headerlink" title="计算二叉树节点总数-遍历算法的应用"></a><strong>计算二叉树节点总数-遍历算法的应用</strong></h3><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/40.jpg">  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int NodeCount(BiTree T){  if(T==NULL){    return 0;  }  else   return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计算二叉树叶子节点总数-遍历算法的应用"><a href="#计算二叉树叶子节点总数-遍历算法的应用" class="headerlink" title="计算二叉树叶子节点总数-遍历算法的应用"></a><strong>计算二叉树叶子节点总数-遍历算法的应用</strong></h3><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/41.jpg">  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int LeadCount(BiTree T){  if(T==NULL){    return 0;  }  if(T-&gt;lchild==NULL &amp;&amp;T-&gt;rchild==NULL)return 1;  else   return LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a><strong>线索二叉树</strong></h2><p>当用二叉链表作为二叉树的存储结构时，可以很方便的找到某个结点的左右孩子；但一般情况下，无法直接找到该结点在某种遍历序列中的前驱和后继结点  </p><p>解决方法：<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/42.jpg"><br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/43.jpg"><br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/44.jpg">  </p><blockquote><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/45.jpg" alt="结点结构">  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct BiThrNode{  int data;  int ltag,rtag;  struct BiThrNode *lchild,rchild;}BithrNode,*BiThrTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/46.jpg"><br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/47.jpg">  </p><h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a><strong>树和森林</strong></h2><blockquote><p>森林：是m棵互不相交的树的集合<br>树和森林可以相互转化  </p></blockquote><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a><strong>树的存储结构</strong></h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a><strong>双亲表示法</strong></h3><blockquote><p>实现：定义结构数组，存放树的结点，每个结点两个域：<br>1.数据域：存放结点本身信息<br>2.双亲域：指示本结点的双亲结点在数组中的位置<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/10.jpg" alt="找双亲容易，找孩子难">  </p></blockquote><p>类型描述：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct PTNode{   TElemType data;  int parent;//双亲位置域}PTNode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>树结构：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAX_TREE_SIZE 100typedef struct PTNode{   PTNode nodes[MAX_TREE_SIZE];  int r,n;//根结点的位置和结点个数}PTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="孩子链表"><a href="#孩子链表" class="headerlink" title="孩子链表"></a><strong>孩子链表</strong></h3><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/11.jpg" alt="找孩子双亲容易，找双亲难"><br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/12.jpg"></p><p>孩子结点结构：<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/13.jpg"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct CTNode{   int child;  struct CTNode *next;}*ChildPtr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>双亲结点结构：<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/14.jpg"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct{   TElemType data;  ChildPtr firstchild;//孩子链表头指针}CTBox;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>树结构：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAX_TREE_SIZE 100typedef struct {   }CTBox nodes[MAX_TREE_SIZE];  int r,n;//根结点的位置和结点个数}CTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>带双亲的孩子链表：两种模式的混合<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/15.jpg"></p><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a><strong>孩子兄弟表示法</strong></h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之数组和广义表</title>
      <link href="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/"/>
      <url>/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之数组和广义表"><a href="#数据结构之数组和广义表" class="headerlink" title="数据结构之数组和广义表"></a>数据结构之数组和广义表</h1><h2 id="数组的定义及特点"><a href="#数组的定义及特点" class="headerlink" title="数组的定义及特点"></a>数组的定义及特点</h2><blockquote><p>按一定格式排列起来的<br>具有相同类型的数据元素的集合  </p></blockquote><blockquote><p>数组特点：结构固定：定义后，维数和维界不再改变  </p></blockquote><blockquote><p>数组基本操作：除了结构的初始化和销毁之外，只有取元素和修改元素值的操作  </p></blockquote><h2 id="数组的抽象数据类型定义"><a href="#数组的抽象数据类型定义" class="headerlink" title="数组的抽象数据类型定义"></a>数组的抽象数据类型定义</h2><p>n维数组的抽象数据类型  </p><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT Array{   数据对象：   ji=0,bi-1, i=1,2,3...n   D={aj1j2j3..jn|aj1j2j3..jn属于Elemset}     数据关系   基本操作：   构造数组   销毁数组   取数组元素值   给数组元素赋值   ...}ADT Array<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h2><blockquote><p>一维数组<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/1.jpg">  </p></blockquote><blockquote><p>二维数组<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/2.jpg"><br>存储单元是一维结构，而数组是个多维结构，则用一组连续存储单元存放数组的元素就有次序问题<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/3.jpg"><br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/4.jpg"> </p></blockquote><blockquote><p>三维数组<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/5.jpg"></p></blockquote><blockquote><p>n维数组<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/20.jpg"></p></blockquote><h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><p>矩阵：一个由m*n个元素排成的m行n列的表<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/6.jpg"><br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/7.jpg">  </p><p>1.对称矩阵：<br>可以只存储上半部分或下半部分，对于一个n*n矩阵，只需要存储n(n+1)/2个元素空间  </p><blockquote><p><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/8.jpg">  </p></blockquote><p>2.三角矩阵  </p><blockquote><p><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/9.jpg">  </p></blockquote><p>3.对角矩阵  </p><blockquote><p><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/10.jpg"><br>以对角线的顺序存储<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/11.jpg">  </p></blockquote><h2 id="稀疏矩阵存储"><a href="#稀疏矩阵存储" class="headerlink" title="稀疏矩阵存储"></a>稀疏矩阵存储</h2><p><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/12.jpg"><br>顺序存储结构：三元组法<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/13.jpg"><br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/14.jpg"><br>链式存储结构：十字链表<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/15.jpg"><br>例如：<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/16.jpg">  </p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>线性表的推广，其中每一个元素可以是原子或者一个广义表<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/17.jpg"><br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/18.jpg">  </p><h2 id="广义表的性质"><a href="#广义表的性质" class="headerlink" title="广义表的性质"></a>广义表的性质</h2><p>1.广义表中的数据元素有相对次序，一个直接前驱和一个直接后继<br>2.广义表的长度定义为最外层所包含元素的个数，如：C=(a,(b,c))是长度为2的广义表<br>3.广义表的深度定义为该广义表展开后所含括号的重数<br>4.广义表可以为其他广义表共享；如：广义表B就共享表A，在B中不必列出A的值，而是通过名称来引用，B=(A)<br>5.广义表可以是一个递归的表。如：F=(a,F)=(a,(a,(a,…)))<br>注意：递归表的深度是无穷值，长度是有限值<br>6.广义表是对层次结构，广义表的元素可以是氮元素，也可以是子表，而子表的元素还可以是子表<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/19.jpg">  </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 广义表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之串</title>
      <link href="/2022/10/14/shu-ju-jie-gou-zhi-chuan/"/>
      <url>/2022/10/14/shu-ju-jie-gou-zhi-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之串"><a href="#数据结构之串" class="headerlink" title="数据结构之串"></a>数据结构之串</h1><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a><strong>串的定义</strong></h2><p>串：内容受限的线性表  </p><blockquote><p>由零个或多个任意字符组成的有限序列<br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/1.jpg">  </p></blockquote><blockquote><p>子串：一个串中任意个连续字符组成的子序列<br>主串：包含子串的串相应地称为主串<br>字符位置：字符在序列中的序号<br>子串位置：子串第一个字符<br>空格串：由一个或多个空格组成的串，与空串不同<br>串相等：当且仅当两个串的长度相等并且各个对应的位置上字符都相等（所有空串都相等）</p></blockquote><h2 id="串的类型定义"><a href="#串的类型定义" class="headerlink" title="串的类型定义"></a><strong>串的类型定义</strong></h2><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT String{   数据对象：D={ai|ai属于Characterset，(i=1,2,3...n，n&gt;=0)}     数据关系：R={&lt;ai-1，ai&gt;|ai-1，ai属于D，(i=1,2,3...n)}   基本操作：   串赋值   穿比较   求串长   串连结   ...}ADT String<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>串中元素逻辑关系与线性表相同<br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/2.jpg">  </p></blockquote><h3 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a><strong>串的顺序存储结构</strong></h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXLEN 255   typedef struct {    char ch[MAXLEN+1];//存储串的一维数组（0号位一般不用）    int length; //串的当前长度}SString;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="串的链式存储结构-块链结构"><a href="#串的链式存储结构-块链结构" class="headerlink" title="串的链式存储结构-块链结构"></a><strong>串的链式存储结构-块链结构</strong></h3><p><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/3.jpg"> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define CHUNKSIZE 80  //块的大小可由用户定义 typedef struct Chunk{    char ch[CHUNKSIZE];    struct Chunk *next;}Chunk;typedef struct {    Chunk *head,*tail;//串的头指针与尾指针    int curlen;//串的当前长度}LString;  //字符串的块链结构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a><strong>串的模式匹配算法</strong></h2><p>算法目的：确定主串中所包含子串（模式串）第一次出现的位置  </p><blockquote><p>算法种类：BF算法、KMP算法  </p></blockquote><h3 id="串的BF算法"><a href="#串的BF算法" class="headerlink" title="串的BF算法"></a><strong>串的BF算法</strong></h3><p><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/4.jpg"> </p><blockquote><p>i-j+1是原始位置，再+1是原始位置的下一位置   </p></blockquote><p><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/5.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/6.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/7.jpg"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">//从主串的头部开始找int Index_BF(SString S,SString T){    int i=1,j=1;    while(i&lt;=S.length&amp;&amp;j&lt;=T.length){        if(S.ch[i]==T.ch[j]){++i;++j;}//主串和子串依次匹配下一个字符          else {i=i-j+2;j=1;}//主串、子串指针回溯重新开始下一次匹配          if(j&gt;T.length)return i-T.length;//返回匹配的第一个字符的下标          else return 0；//匹配不成功    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">//从主串的中间pos处开始找int Index_BF(SString S,SString T，int pos){    int i=pos,j=1;    while(i&lt;=S.length&amp;&amp;j&lt;=T.length){        if(S.ch[i]==T.ch[j]){++i;++j;}//主串和子串依次匹配下一个字符          else {i=i-j+2;j=1;}//主串、子串指针回溯重新开始下一次匹配          if(j&gt;T.length)return i-T.length;//返回匹配的第一个字符的下标          else return 0；//匹配不成功    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="串的KMP算法"><a href="#串的KMP算法" class="headerlink" title="串的KMP算法"></a><strong>串的KMP算法</strong></h3><p><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/8.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/9.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/10.jpg"></p><blockquote><p>计算next[j]=k；k-1=5（如上图，则k=6）</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">void get_next(SString T,int &amp;next[]){     i=1;next[1]=0;j=0;     while(i&lt;T.length){        if(j==0||T.ch[i]==T.ch[j]){            ++i;++j;            next[i]=j;        }        else j=next[j];     }}//从主串的中间pos处开始找int Index_KMP(SString S,SString T，int pos){    int i=pos,j=1;    while(i&lt;=S.length&amp;&amp;j&lt;=T.length){        if(j==0||S.ch[i]==T.ch[j]){++i;++j;}//主串和子串依次匹配下一个字符          else {            j=next[j]; //i不变，j后退         }        if(j&gt;T.length)return i-T.length;//返回匹配的第一个字符的下标          else return 0；//匹配不成功    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>主串S的指针i不必回溯，O(m+n)</p></blockquote><p>next数组细说<br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/11.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/12.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/13.jpg"></p><blockquote><p>看门牌，比如：如果要求7的next，看6的next值，是4，所以看第4，如果4和6相等，那么7就为4+1=5，但是并不等，于是看2,2和6也不等，就看1，1和6也不等，于是7就为1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之栈和队列</title>
      <link href="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/"/>
      <url>/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之栈和队列"><a href="#数据结构之栈和队列" class="headerlink" title="数据结构之栈和队列"></a>数据结构之栈和队列</h1><h2 id="栈和队列的定义"><a href="#栈和队列的定义" class="headerlink" title="栈和队列的定义"></a><strong>栈和队列的定义</strong></h2><p>栈和队列是两种常用的数据结构，是限定插入和删除只能在表的“端点”进行的线性表  </p><blockquote><p><strong>栈</strong>的操作具有后进先出的固有特性<br>如“数值转换”  “表达式求值”  “括号匹配检验”  “八皇后问题”  “函数调用”  “迷宫求解” 等等  </p></blockquote><blockquote><p><strong>队列</strong>的操作具有先进先出的特性<br>使得队列成为程序设计中解决类似排队问题的工具  </p></blockquote><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/1.jpg">  </p><h2 id="栈的定义和特点"><a href="#栈的定义和特点" class="headerlink" title="栈的定义和特点"></a><strong>栈的定义和特点</strong></h2><p>是一个特殊的线性表，限定仅在一端（通常是表尾）进行插入和删除操作的线性表  </p><p>又称为后进先出，简称LIFO结构  </p><blockquote><p>表尾（即an端）称为栈顶Top；表头（即a1端）称为栈底Base<br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/2.jpg"><br>插入元素到栈顶（表尾）的操作称为入栈；<br>从栈顶删除最后一个元素的操作称为出栈<br>压入=<code>PUSH(x)</code>  弹出=<code>POP(y)</code></p></blockquote><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/3.jpg">  </p><h2 id="队列的定义和特点"><a href="#队列的定义和特点" class="headerlink" title="队列的定义和特点"></a><strong>队列的定义和特点</strong></h2><p>在表一端插入（表尾），在另一端（表头）删除<br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/4.jpg">  </p><h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a><strong>案例引入</strong></h2><h3 id="案例1-进制转换"><a href="#案例1-进制转换" class="headerlink" title="案例1 进制转换"></a><strong>案例1</strong> 进制转换</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/5.jpg">  </p><h3 id="案例2-括号匹配的检验"><a href="#案例2-括号匹配的检验" class="headerlink" title="案例2 括号匹配的检验"></a><strong>案例2</strong> 括号匹配的检验</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/6.jpg">  </p><h3 id="案例3-表达式求值"><a href="#案例3-表达式求值" class="headerlink" title="案例3 表达式求值"></a><strong>案例3</strong> 表达式求值</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/7.jpg"><br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/8.jpg">  </p><h3 id="案例4-舞伴问题"><a href="#案例4-舞伴问题" class="headerlink" title="案例4 舞伴问题"></a><strong>案例4</strong> 舞伴问题</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/9.jpg">  </p><h2 id="栈的抽象数据类型的类型定义"><a href="#栈的抽象数据类型的类型定义" class="headerlink" title="栈的抽象数据类型的类型定义"></a><strong>栈的抽象数据类型的类型定义</strong></h2><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT Stack {    数据对象：       D={ai|ai属于ElemSet,i=1,2,3,...n,n&gt;=0}    数据关系：       R1={&lt;ai-1,ai&gt;|ai-1，ai属于D，i=2，...,n}         约定an端为栈顶，a1端为栈底。      基本操作：初始化、进栈、出栈、取栈顶元素等}}ADT Stack <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>InitStack(&amp;S)：初始化操作，构造一个空栈S  </li><li>DestoryStack(&amp;S)：销毁栈操作   </li><li>StackEmpty(S)：判断S是否为空栈</li><li>StackLength(L):返回S的元素个数</li><li>GetTop(S,&amp;e):取栈顶元素</li><li>ClearStack(&amp;S):栈置空操作</li><li>Puah(&amp;S,e):插入元素e为新的栈顶元素</li><li>Pop(&amp;S,&amp;e):删除S的栈顶元素，并用e返回其值</li></ul><h2 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a><strong>顺序栈的表示和实现</strong></h2><p>存储方式：与一般线性表的顺序存储结构完全相同<br>利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，栈底一般在低地址端  </p><ul><li>top指针：指示栈顶元素在顺序栈中的位置  </li><li>base指针，指示栈底元素在顺序栈中的位置  <blockquote><p>但是，为了方便操作，通常top指示真正的栈顶元素之上的下表地址<br>另外，用stacksize表示栈可以使用的最大容量<br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/10.jpg"></p></blockquote></li></ul><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/11.jpg"></p><p>使用数组作为顺序栈存储方式的特点：  </p><blockquote><p>简单方便单易产生溢出（数组大小固定）  </p></blockquote><p>上溢：栈已经满，又要压入元素<br>下溢：栈已经空，还要弹出元素  </p><blockquote><p>上溢是一种错误，而下溢一般认为是一种结束条件，即问题处理结束  </p></blockquote><h3 id="顺序栈的数据类型定义"><a href="#顺序栈的数据类型定义" class="headerlink" title="顺序栈的数据类型定义"></a><strong>顺序栈的数据类型定义</strong></h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 100typedef struct {    SElemType *base;//栈底指针    SElemType *top;//栈顶指针    int stacksize; //栈可用最大容量}SqStack;```  ![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/12.jpg)  ### **算法1** 顺序栈的初始化 ```CStatus InitStack(SqStack &amp;S){  S.base=new SElemType[MAXSIZE];//或  //S.base=(SElemType*)malloc(MAXSIZE*sizeof(SElemType));    if(!S.base)exit (OVERFLOW);  S.top=S.base;  S.stacksize=MAXSIZE;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-顺序栈判断是否是空"><a href="#算法2-顺序栈判断是否是空" class="headerlink" title="算法2 顺序栈判断是否是空"></a><strong>算法2</strong> 顺序栈判断是否是空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status StackEmpty(SqStack S){  if(S.top==S.base)return TRUE;  else return FALSE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-求顺序栈长度"><a href="#算法3-求顺序栈长度" class="headerlink" title="算法3 求顺序栈长度"></a><strong>算法3</strong> 求顺序栈长度</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status StackLength(SqStack S){  return S.top-S.base；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法4-清空顺序栈"><a href="#算法4-清空顺序栈" class="headerlink" title="算法4 清空顺序栈"></a><strong>算法4</strong> 清空顺序栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ClearStack(SqStack S){   if(S.base)S.top=S.base;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-销毁顺序栈"><a href="#算法5-销毁顺序栈" class="headerlink" title="算法5 销毁顺序栈"></a><strong>算法5</strong> 销毁顺序栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DestroyStack(SqStack &amp;S){   if(S.base){    delete S.base;    S.stacksize=0;    S.base= S.top =NULL;   }   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-顺序栈的入栈"><a href="#算法6-顺序栈的入栈" class="headerlink" title="算法6 顺序栈的入栈"></a><strong>算法6</strong> 顺序栈的入栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Push(SqStack &amp;S,SElemType e){   if(S.top-S.base==S.stacksize)//栈满       return ERROR;   *S.top++=e;//*S.top=e;S.top++;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-顺序栈的出栈"><a href="#算法7-顺序栈的出栈" class="headerlink" title="算法7 顺序栈的出栈"></a><strong>算法7</strong> 顺序栈的出栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Pop(SqStack &amp;S,SElemType &amp;e){   if(S.top==S.base)//等价于if(StackEmpty(S))   return ERROR;    e=*--S.top;//--S.top;e=*S.top;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a><strong>链栈的表示和实现</strong></h2><p>链栈是运算受限的单链表，只能在链表头部进行操作 </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct StackNode{    SElemType data；    struct StackNode *next;}StackNode,*LinkStack;  LinkStack S;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/13.jpg">  </p><h3 id="算法1-链栈的初始化"><a href="#算法1-链栈的初始化" class="headerlink" title="算法1 链栈的初始化"></a><strong>算法1</strong> 链栈的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void InitStack(LinkStack &amp;S){    //构造一个空栈，栈顶指针置为空    S=NULL;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-链栈的初始化"><a href="#算法2-链栈的初始化" class="headerlink" title="算法2 链栈的初始化"></a><strong>算法2</strong> 链栈的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void InitStack(LinkStack &amp;S){    //构造一个空栈，栈顶指针置为空    S=NULL;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-判断链栈是否为空"><a href="#算法3-判断链栈是否为空" class="headerlink" title="算法3 判断链栈是否为空"></a><strong>算法3</strong> 判断链栈是否为空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void StackEmpty(LinkStack S){    if(S==NULL)return TRUE;    else return FALSE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法4-链栈的入栈"><a href="#算法4-链栈的入栈" class="headerlink" title="算法4 链栈的入栈"></a><strong>算法4</strong> 链栈的入栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Push(LinkStack &amp;S,SElemType e){    p=new StackNode;    p-&gt;data=e;    p-&gt;next=S;    S=p;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-链栈的出栈"><a href="#算法5-链栈的出栈" class="headerlink" title="算法5 链栈的出栈"></a><strong>算法5</strong> 链栈的出栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Pop(LinkStack &amp;S,SElemType &amp;e){    if(S==NULL)return ERROR;    e=S-&gt;data;    p=S;    S=S-&gt;next;    delete p;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-取栈顶元素"><a href="#算法6-取栈顶元素" class="headerlink" title="算法6 取栈顶元素"></a><strong>算法6</strong> 取栈顶元素</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">SElemType GetTop(LinkStack S){    if(S!=NULL)    return S-&gt;data;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈和递归"><a href="#栈和递归" class="headerlink" title="栈和递归"></a><strong>栈和递归</strong></h2><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/14.jpg"></p><blockquote><p>注：栈的应用与递归详见数据结构书中P48页始  </p></blockquote><h2 id="队列的表示和操作实现"><a href="#队列的表示和操作实现" class="headerlink" title="队列的表示和操作实现"></a><strong>队列的表示和操作实现</strong></h2><p>是仅在表尾进行插入操作，在表头进行删除操作的线性表<br>表尾即an端，称为队尾，表头为a1端，称为对头。</p><blockquote><p>先进先出  </p></blockquote><p>插入元素称为入队，删除元素称为出队<br>队列的存储结构为链队或顺序队。  </p><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/15.jpg">  </p><h3 id="队列的抽象数据类型定义"><a href="#队列的抽象数据类型定义" class="headerlink" title="队列的抽象数据类型定义"></a><strong>队列的抽象数据类型定义</strong></h3><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT Queue {    数据对象：       D={ai|ai属于ElemSet,i=1,2,3,...n,n&gt;=0}    数据关系：       R={&lt;ai-1,ai&gt;|ai-1，ai属于D，i=2，...,n}         约定an端为栈顶，a1端为栈底。      基本操作：初始化等}}ADT Queue <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="队列的顺序表示"><a href="#队列的顺序表示" class="headerlink" title="队列的顺序表示"></a><strong>队列的顺序表示</strong></h2> <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXQSIZE 100typedef struct{  QElemType *base;//初始化的动态分配存储空间  int front; //头指针(队头元素下标)  int rear; //尾指针(队尾元素下标)}SqQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/16.jpg">  </p><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/17.jpg"></p><blockquote><p>解决假上溢的方法：引入循环队列  </p></blockquote><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/18.jpg"></p><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/19.jpg">  </p><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/20.jpg">  </p><h2 id="循环队列的类型定义"><a href="#循环队列的类型定义" class="headerlink" title="循环队列的类型定义"></a><strong>循环队列的类型定义</strong></h2><h3 id="算法1-循环队列的类型定义"><a href="#算法1-循环队列的类型定义" class="headerlink" title="算法1 循环队列的类型定义"></a><strong>算法1</strong> 循环队列的类型定义</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXQSIZE 100typedef struct{  QElemType *base;//初始化的动态分配存储空间  int front; //头指针(队头元素下标)  int rear; //尾指针(队尾元素下标)}SqQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-循环队列的初始化"><a href="#算法2-循环队列的初始化" class="headerlink" title="算法2 循环队列的初始化"></a><strong>算法2</strong> 循环队列的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitQueue(SqQueue &amp;Q){  Q.base = new QElemType[MAXQSIZE] //分配数组空间   if(!Q.base) exit (OVERFLOW);  Q.front=Q.rear=0; //头指针尾指针置为0，队列为空  return OK; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-循环队列的长度"><a href="#算法3-循环队列的长度" class="headerlink" title="算法3 循环队列的长度"></a><strong>算法3</strong> 循环队列的长度</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int QueueLength(SqQueue Q){  return((Q.rear-Q.front+MAXQSIZE)%MAXQSIZE);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法4-循环队列的入队"><a href="#算法4-循环队列的入队" class="headerlink" title="算法4 循环队列的入队"></a><strong>算法4</strong> 循环队列的入队</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status EnQueueLength(SqQueue &amp;Q，QElemType e){  if((Q.rear+1)%MAXQSIZE==Q.front)return ERROR;  Q.base[Q.rear]=e;  Q.rear=(Q.rear+1)%MAXQSIZE;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-循环队列的出队"><a href="#算法5-循环队列的出队" class="headerlink" title="算法5 循环队列的出队"></a><strong>算法5</strong> 循环队列的出队</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DeQueueLength(SqQueue &amp;Q，QElemType &amp;e){  if(Q.front==Q.rear)return ERROR;  e=Q.base[Q.front];  Q.front=(Q.front+1)%MAXQSIZE;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-取队头元素"><a href="#算法6-取队头元素" class="headerlink" title="算法6 取队头元素"></a><strong>算法6</strong> 取队头元素</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">SElemType GetHead(SqQueue Q){  if(Q.front!=Q.rear)return Q.base[Q.front];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="队列的链式表示和实现"><a href="#队列的链式表示和实现" class="headerlink" title="队列的链式表示和实现"></a><strong>队列的链式表示和实现</strong></h2><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/21.jpg">  </p><h3 id="算法1-链队列的类型定义"><a href="#算法1-链队列的类型定义" class="headerlink" title="算法1 链队列的类型定义"></a><strong>算法1</strong> 链队列的类型定义</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXQSIZE 100typedef struct Qnode{  QElemType data;  struct Qnode *next;}QNode,*QuenePtr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {  QuenePtr front;//队头指针  QuenePtr rear;//队尾指针}LinkQuene;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/22.jpg">  </p><h3 id="算法2-链队列的初始化"><a href="#算法2-链队列的初始化" class="headerlink" title="算法2 链队列的初始化"></a><strong>算法2</strong> 链队列的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitQueue(LinkQueue &amp;Q){  Q.front=Q.rear=(QueuePtr)malloc(sizeof(QNode));  if(!Q.front)exit(OVERFLOW);  Q.front-&gt;next=NULL;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-链队列的销毁"><a href="#算法3-链队列的销毁" class="headerlink" title="算法3 链队列的销毁"></a><strong>算法3</strong> 链队列的销毁</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DestroyQueue(LinkQueue &amp;Q){  while(Q.front){    p=Q.front-&gt;next;    free(Q.front);    Q.front=p;}  return OK;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法4-链队列的销毁"><a href="#算法4-链队列的销毁" class="headerlink" title="算法4 链队列的销毁"></a><strong>算法4</strong> 链队列的销毁</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DestroyQueue(LinkQueue &amp;Q){  while(Q.front){    p=Q.front-&gt;next;    free(Q.front);    Q.front=p;}  return OK;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-链队列的元素入队"><a href="#算法5-链队列的元素入队" class="headerlink" title="算法5 链队列的元素入队"></a><strong>算法5</strong> 链队列的元素入队</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status EnQueue(LinkQueue &amp;Q,QElemType e){  p=(QueuePtr)malloc(sizeof(QNode));  if(!p)exit (OVERFLOW);  p-&gt;data=e;p-&gt;next=NULL;  Q.rear-&gt;next=p;  Q.rear=p;  return OK;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-链队列的元素出队"><a href="#算法6-链队列的元素出队" class="headerlink" title="算法6 链队列的元素出队"></a><strong>算法6</strong> 链队列的元素出队</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DeQueue(LinkQueue &amp;Q,QElemType &amp;e){  if(Q.front==Q.rear)return ERROR;  p=Q.front-&gt;next;  e=p-&gt;data;  Q.front-&gt;next=p-&gt;next;  if(Q.rear==p)Q.rear=Q.front;  delete p;  return OK;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-链队列的队头元素"><a href="#算法7-链队列的队头元素" class="headerlink" title="算法7 链队列的队头元素"></a><strong>算法7</strong> 链队列的队头元素</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status GetHead(LinkQueue Q,QElemType &amp;e){   if(Q.front==Q.rear)return ERROR;   e=Q.front-&gt;next-&gt;data;   return OK;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之线性表</title>
      <link href="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/"/>
      <url>/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之线性表"><a href="#数据结构之线性表" class="headerlink" title="数据结构之线性表"></a>数据结构之线性表</h1><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a><strong>知识回顾</strong></h2><p>数据结构  </p><ul><li>逻辑结构  <ul><li>线性结构  <ul><li>线性表  </li><li>栈（特殊线性表） </li><li>队列（特殊线性表）</li><li>字符串、数组、广义表</li></ul></li><li>非线性结构  <ul><li>树形结构  </li><li>图形结构</li></ul></li></ul></li><li>数据的存储结构  <ul><li>顺序存储  </li><li>链式存储</li></ul></li><li>数据的运算：检索、排序、插入…</li></ul><h2 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a><strong>线性表的定义和特点</strong></h2><p>线性表是具有相同特性的数据元素的一个有限序列  </p><blockquote><p>(a1,a2,…,ai-1,ai,ai+1,…an)  </p><p>a1:线性起点<br>ai-1:ai的直接前趋<br>ai+1:ai的直接后继<br>an:线性终点<br>n=0时称为空表（n是表长） </p></blockquote><p>同一线性表中的元素必定具有相同特性，数据元素之间的关系是线性关系  </p><h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a><strong>案例引入</strong></h2><p>案例一：一元多项式的运算：实现两个多项式的加、减、乘运算  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/1.jpg" alt="案例一">  </p><p>案例二：稀疏多项式的运算  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/2.jpg"><br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/3.jpg" alt="案例二">  </p><blockquote><p>Q:那么数组C多大合适呢？  </p><p>顺序存储结构存在的问题  </p><ul><li>存储空间分配不灵活  </li><li>运算的空间复杂度高</li></ul></blockquote><p>—&gt;选择链式存储结构<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/4.jpg" alt="链式存储方法">   </p><p>案例三：图书信息管理系统  </p><ul><li>将图书表抽象为线性表  </li><li>表中每本书抽象线性表中数据元素</li></ul><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/5.jpg" alt="两种方式">  </p><p>线性表中数据元素可以是<em>简单类型</em>，也可以是<em>复杂类型</em>  </p><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a><strong>线性表的类型定义</strong></h2><blockquote><p>抽象数据类型（ADT）</p><ul><li>数据对象</li><li>数据对象关系集合  </li><li>作用在数据对象上的基本操作</li></ul></blockquote><p>抽象数据类型线性表的定义如下：  </p><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT List{   数据对象：D={ai|ai属于Elemset，(i=1,2,3...n，n&gt;=0)}     数据关系：R={&lt;ai-1，ai&gt;|ai-1，ai属于D，(i=1,2,3...n)}   基本操作：   IntList(&amp;L);   DestoryList(&amp;L);   ListInsert(&amp;L,i,e);   ListDelete(&amp;L,i,&amp;e);   ...}ADT List<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>InitList(&amp;L):构造一个空的线性表L</li><li>DestoryList(&amp;L)：线性表已存在的条件下，销毁线性表  </li><li>ClwanList(&amp;L)：线性表已存在的条件下，清除线性表元素，置L为空表  </li><li>ListEmpty(L)：线性表已存在的条件下，若L为空表，返回TRUE，否则返回FALSE</li><li>ListLength(L):线性表已存在的条件下，返回L中元素个数</li><li>GetElem(L,I,&amp;e):线性表已存在的条件下，1&lt;=i&lt;=ListLength(L),用e返回线性表中第i个元素的值</li><li>LocateElem(L,e,compare()):线性表已存在的条件下，compare()是数据元素判定函数，返回L中第一个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0</li><li>PriorElem(L,cur_e,&amp;pre_e):线性表已存在的条件下，若cur_e是L的数据元素，且不是第一个，则用pre_e返回他的前趋，否则操作失败，pre_e无意义</li><li>NextElem(L,cur_e,&amp;next_e):线性表已存在的条件下，若cur_e是L的数据元素，且不是最后一个，则用next_e返回他的后继，否则操作失败，next_e无意义</li><li>ListInsert(&amp;L,i,e):线性表已存在的条件下，1&lt;=i&lt;=ListLength(L)+1，在L的第i个位置之前插入新的元素e，L的长度加1</li><li>ListDelete(&amp;L,i,&amp;e)：线性表已存在的条件下，1&lt;=i&lt;=ListLength(L)，删除L的第i个元素，并用e返回其值，L的长度-1 </li><li>ListTraverse(&amp;L,visited()):线性表已存在的条件下，依次对线性表中的每个元素调用遍历visited()</li></ul><p>以上提及的运算是逻辑结构上定义的运算，只要给出这些运算功能是“做什么”，至于“如何做”，只有待确定了存储结构之后才考虑</p><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a><strong>线性表的顺序表示和实现</strong></h2><p>顺序存储：把逻辑上相邻的数据元素储存在物理上相邻的存储单元中的存储结构  </p><blockquote><p>线性表中的第一个数据元素a1的存储位置，称作线性表的<strong>起始位置</strong>或<strong>基地址</strong>  </p></blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/6.jpg" alt="两种方式">   </p><p>假设线性表的每个元素需要占用k个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足:LOC(ai+1)=LOC(ai)+k ；同时LOC(ai)=LOC(ai)+(i-1)*k  </p><blockquote><p>顺序表元素-&gt;数组元素<br>用一维数组表示顺序表  </p></blockquote><p>线性表长度可变但数组长度不可动态定义<br>-&gt;用以变量表示顺序表的长度属性  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define LIST INIT SIZE 100 //线性表存储空间的初始分配量  typedef struct {    ElemType elem[LIST_INIT_SIZE];    int length; //当前长度}SqList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多项式的顺序结构储存结构类型定义</strong>  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/7.jpg">  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 1000 //多项式可能达到的最大长度typedef struct {  //多项式非零项的定义  float p;  //系数  int e;  //指数}Polynomial;   typedef struct {    Polynomial *elem;  //储存空间的基地址  int length;  //多项式中当前项的个数}SqList;//多项式的顺序储存结构类型为SqList<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>图书表的顺序存储结构类型定义</strong><br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/8.jpg"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 1000 //图书表可能达到的最大长度typedef struct {  //图书信息定义  char no[20];  char name[50];  float price;}Book;   typedef struct {   Book *elem;  //储存空间的基地址  int length;  //图书表中当前图书个数}SqList;//图书表的顺序储存结构类型为SqList  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线性表的数据类型定义模板"><a href="#线性表的数据类型定义模板" class="headerlink" title="线性表的数据类型定义模板"></a><strong>线性表的数据类型定义模板</strong></h3><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/9.jpg"> </p><h2 id="类C语言有关操作"><a href="#类C语言有关操作" class="headerlink" title="类C语言有关操作"></a><strong>类C语言有关操作</strong></h2><p>数组静态分配：<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   ElemType data[MaxSize];    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>data:首元素地址</p></blockquote><p>数组动态分布<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   ElemType *data;    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>SqList L;<br>L.data=(Elem Type*)malloc(sizeof(Elem Type)*MaxSize);  </p></blockquote><p><code>malloc(m)</code>函数：开辟m字节长度的地址空间，并返回这段空间的首地址<br><code>sizeof(x)</code>运算：计算变量x的长度<br><code>free(p)</code>函数：释放指针p所指变量的存储空间，即彻底删除一个变量  </p><blockquote><p>需要加载头文件<code>&lt;stdlib.h&gt;</code>  </p></blockquote><p>补充：   </p><h3 id="C-的动态存储分配"><a href="#C-的动态存储分配" class="headerlink" title="C++的动态存储分配"></a><strong>C++的动态存储分配</strong></h3><p>new 类型名T(初始列表)<br>功能：申请用于存放T类型对象的内存空间，并依初值列表赋值以初值<br>结果值：  </p><ul><li>成功：T类型指针，指向新分配内存  </li><li>失败：0 （NULL）</li></ul><p><code>int *p1 = new int;</code><br>或 <code>int *p1 = new int（10）;</code><br>使用 <code>delete 指针P</code> 释放 </p><h2 id="线性表的顺序表示和实现-1"><a href="#线性表的顺序表示和实现-1" class="headerlink" title="线性表的顺序表示和实现"></a><strong>线性表的顺序表示和实现</strong></h2><p>线性表类型的构造（回顾）：<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   ElemType data[MaxSize];    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>线性表变量L的定义以及成员读取：<br> <pre class="line-numbers language-C" data-language="C"><code class="language-C">SqList L;L.elem;//orSqList *L;L-&gt;elem;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>补充：操作算法中用到的预定义常量和类型<br> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/10.jpg"> <p></p><h3 id="算法1-线性表的初始化"><a href="#算法1-线性表的初始化" class="headerlink" title="算法1 线性表的初始化"></a><strong>算法1</strong> 线性表的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitList_Sq(SqList &amp;L){  L.elem=new ElemType[MAXSIZE];  if(!L.elem) exit(OVERFLOW);  L.length=0; //空表长度为0  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-线性表的销毁"><a href="#算法2-线性表的销毁" class="headerlink" title="算法2 线性表的销毁"></a><strong>算法2</strong> 线性表的销毁</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void DestroyList(SqList &amp;L){ if(L.elem)delete L.elem;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法3-线性表的清空"><a href="#算法3-线性表的清空" class="headerlink" title="算法3 线性表的清空"></a><strong>算法3</strong> 线性表的清空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void CleanList(SqList &amp;L){ L.Length=0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法4-线性表的长度"><a href="#算法4-线性表的长度" class="headerlink" title="算法4 线性表的长度"></a><strong>算法4</strong> 线性表的长度</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int GetLength(SqList L){ return(L.Length);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法5-判断线性表是否为空"><a href="#算法5-判断线性表是否为空" class="headerlink" title="算法5 判断线性表是否为空"></a><strong>算法5</strong> 判断线性表是否为空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int IsEmpty(SqList L){ if(L.Length==0)return 1; else return 0；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-顺序表的取值（取值i元素）"><a href="#算法6-顺序表的取值（取值i元素）" class="headerlink" title="算法6 顺序表的取值（取值i元素）"></a><strong>算法6</strong> 顺序表的取值（取值i元素）</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int GetElem(SqList L, ElemType &amp;e){ if(i&lt;1||i&gt;L.length)return ERROR; e=L.elem[i-1]; return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-顺序表的元素查找（顺序查找）"><a href="#算法7-顺序表的元素查找（顺序查找）" class="headerlink" title="算法7 顺序表的元素查找（顺序查找）"></a><strong>算法7</strong> 顺序表的元素查找（顺序查找）</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int LocateElem(SqList L, ElemType e){ for(i=0；i&lt;L.length;i++)   if(L.elem[i]==e) return i+1; return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/11.jpg">  </p><h3 id="算法8-顺序表的元素插入"><a href="#算法8-顺序表的元素插入" class="headerlink" title="算法8 顺序表的元素插入"></a><strong>算法8</strong> 顺序表的元素插入</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListInsert_Sq(SqList &amp;L,int i,Elem Type e){  if(i&lt;1||i&gt;L.length+1)return ERROR; //i值不合法  if(L.length==MAXSIZE)return ERROR; //当前存储空间已满  for(j=L.length-1;j&gt;=i-1;j--)   L.elem[j+1]=L.elem[j];   L.elem[i-1]=e;   L.length++; //表长+1   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/12.jpg">   </p><h3 id="算法9-顺序表的元素删除"><a href="#算法9-顺序表的元素删除" class="headerlink" title="算法9 顺序表的元素删除"></a><strong>算法9</strong> 顺序表的元素删除</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListDelete_Sq(SqList &amp;L,int i){  if(i&lt;1||i&gt;L.length+1)return ERROR; //i值不合法  for(j=i;j&lt;=L.length-1;j++)   L.elem[j-1]=L.elem[j];   L.length--; //表长-1   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/14.jpg">  </p><h2 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a><strong>线性表的链式表示和实现</strong></h2><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/15.jpg">  </p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a><strong>相关术语</strong></h3><ul><li>结点；数据元素的存储映像，由数据域和指针域两部分组成  </li><li>链表：n个结点由指针链组成一个链表</li></ul><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/16.jpg" alt="带头结点的单链表">   </p><p>单链表：有一个指针域<br>双链表：有两个指针域<br>循环链表：首尾相接  </p><p>头指针：指向链表第一个结点的指针<br>首元结点：存储第一个数据元素a1的结点<br>头结点：实在链表的首元结点之前附设的一个结点<br>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/17.jpg">  </p><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/18.jpg">  </p><blockquote><p><em>如何表示空表？</em><br>无头结点时，头指针为空时表示空表<br>有头结点时，当头结点的指针域为空时表示空表  </p></blockquote><blockquote><p><em>在链表中设置头结点有什么好处？</em><br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/19.jpg">  </p></blockquote><blockquote><p><em>头结点的数据域内装的是什么？</em><br>数据域可以为空，也可以存放表长等信息，但此结点不计入表长值  </p></blockquote><p>顺序表：随机存取<br>链表：顺序存取</p><p>单链表是由表头唯一确定的，因此单链表可以用<strong>头指针</strong>的名字来命名，若头指针名是L，则把链表称为表L</p><h3 id="链表结点的定义"><a href="#链表结点的定义" class="headerlink" title="链表结点的定义"></a><strong>链表结点的定义</strong></h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct Lnode{ ElemType data;  //结点的数据域 struct Lnode *next;  //结点的指针域  }Lnode,*LinkList;//LlinkList为指向结构体Lnode的指针类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>单链表L的定义：<br>定义链表L： <code>LinkList L;</code><br>定义结点指针p： <code>LNode *p;</code> 、<code>LinkList p;</code></p><p>例如，存储学生学号、姓名、成绩的单链表结点类型定义如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct student{ char num[8]; char name[8]; int score; struct student *next;  }Lnode,*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过为了统一链表的操作，通常这样定义：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct { char num[8]; char name[8]; int score; }ElemType;typedef struct Lnode{ ElemType data； struct Lnode *next;  }Lnode,*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法1-单链表的初始化"><a href="#算法1-单链表的初始化" class="headerlink" title="算法1 单链表的初始化"></a><strong>算法1</strong> 单链表的初始化</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitList L(LinkList &amp;L){   L=new LNode;  //或 L=(LinkList)malloc (sizeof(LNode));   L-&gt;next=NULL;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-判断链表是否为空"><a href="#算法2-判断链表是否为空" class="headerlink" title="算法2 判断链表是否为空"></a><strong>算法2</strong> 判断链表是否为空</h3><p>空表：链表中无元素，称为空链表(头指针和头结点仍然在)</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int ListEmpty (LinkList L){ if(L-&gt;next) //非空   return 0; else    return 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-单链表的销毁"><a href="#算法3-单链表的销毁" class="headerlink" title="算法3 单链表的销毁"></a><strong>算法3</strong> 单链表的销毁</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DestroyList_L(LinkList &amp;L){ Lnode *p; while(L){   p=L;   L=L-&gt;next;   delete p; }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法4-清空单链表"><a href="#算法4-清空单链表" class="headerlink" title="算法4 清空单链表"></a><strong>算法4</strong> 清空单链表</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ClearList(LinkList &amp;L){   Lnode *p，*q；   p=L-&gt;next;   while(p){     q=p-&gt;next;     delete p;     p=q;   }  L-&gt;next=NULL;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-单链表表长"><a href="#算法5-单链表表长" class="headerlink" title="算法5 单链表表长"></a><strong>算法5</strong> 单链表表长</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int ListLength_L(LinkList L){   LinkList p; //Lnode *p;    p=L-&gt;next; //p指向第一个结点     i=0;     while(p){       i++;       p=p-&gt;next;     }   return i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-取值"><a href="#算法6-取值" class="headerlink" title="算法6 取值"></a><strong>算法6</strong> 取值</h3><p> 取单链表中第i个元素内容  </p> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status GetElem L(LinkList L, int i,ElemType &amp;e){  p=L-&gt;next;  j=1;  while(p &amp;&amp; j&lt;i){    p=p-&gt;next; ++j;  }  if(!p||j&gt;i) return ERROR;    e=p-&gt;data;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-按值查找"><a href="#算法7-按值查找" class="headerlink" title="算法7 按值查找"></a><strong>算法7</strong> 按值查找</h3><p>根据指定数据获取该数据所在的位置(地址)</p> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Lnode *LocateElem_L(LinkList L,ElemType e){  P=L-&gt;next;  while(p&amp;&amp;p-&gt;data!=e)     p=p-&gt;next;  return p;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-变化-按值查找"><a href="#算法7-变化-按值查找" class="headerlink" title="算法7-变化 按值查找"></a><strong>算法7-变化</strong> 按值查找</h3><p>根据指定数据获取该数据所在的位置序号</p> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int LocateElem_L(LinkList L,ElemType e){  P=L-&gt;next; j=1;  while(p&amp;&amp;p-&gt;data!=e)     {p=p-&gt;next;j++;}  if(p)return j;  else return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法8-插入-在第i个结点前插入值为e的新结点"><a href="#算法8-插入-在第i个结点前插入值为e的新结点" class="headerlink" title="算法8 插入-在第i个结点前插入值为e的新结点"></a><strong>算法8</strong> 插入-在第i个结点前插入值为e的新结点</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListInsert_L(LinkList &amp;L,int i,ElemType e){  P=L;j=0;  while(p&amp;&amp;j&lt;i-1)     {p=p-&gt;next;++j;}  if(p||j&gt;i-1)return ERROR;  s=new LNode; s-&gt;data=e;  s-&gt;next=p-&gt;next;  p-&gt;next=s;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法9-删除-删除第i个结点"><a href="#算法9-删除-删除第i个结点" class="headerlink" title="算法9 删除-删除第i个结点"></a><strong>算法9</strong> 删除-删除第i个结点</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e){  P=L;j=0;  while(p-&gt;next&amp;&amp;j&lt;i-1){p=p-&gt;next;++j;}       if(!p-&gt;next||j&gt;i-1)return ERROR;  q=p-&gt;next;  p-&gt;next=q-&gt;next;  e=q-&gt;data;  delete q;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>单链表各算法时间效率  </p><ul><li>查找：O(n)</li><li>插入和删除：一般情况下O(1),但如果从头查找，所消耗的时间复杂度为O(n)</li></ul></blockquote><h3 id="算法10-单链表的建立"><a href="#算法10-单链表的建立" class="headerlink" title="算法10 单链表的建立"></a><strong>算法10</strong> 单链表的建立</h3><p>头插法：元素插入到链表头部<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/20.jpg"> </p><p>首先，在内存中找到一个空间存放头结点  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/21.jpg"><br><code>L=new LNode;</code>或<code>L=(LinkList)malloc(sizeof(LNode));</code>  </p></blockquote><p>将头结点置空  </p><blockquote><p><code>L-&gt;next=NULL;</code></p></blockquote><p>依次插入其余结点，从最后一个结点开始  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/22.jpg"><br><code>p=new LNode;  p-&gt;data=an;</code> </p></blockquote><p>将L的next域赋值给p的next域，并将头结点L的next赋值为新结点P的地址  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/23.jpg"><br><code>p=next=L-&gt;next;  L-&gt;next=p;</code>  </p></blockquote><p>继续放置前一个结点</p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/24.jpg"><br><code>p=new LNode; p-&gt;data=an-1</code>  </p></blockquote><p>再接着做之前的步骤  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/25.jpg"><br><code>p=next=L-&gt;next;  L-&gt;next=p;</code><br>反复循环，直到所有元素都插入  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">//倒位序输入n个元素值void CreateList_H(LinkList &amp;L,int n){   L=new LNode;   L-&gt;next=NULL;   for(i=n;i&gt;0;--i){     p=new LNode;     scanf(&amp;p-&gt;data);     p-&gt;next=L-&gt;next;     L-&gt;next=p;   } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尾插法：元素插入在链表尾部  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">//正位序输入n个元素值void CreateList_H(LinkList &amp;L,int n){   L=new LNode;   L-&gt;next=NULL;   r=L;//尾指针r指向头结点   for(i=0;i&lt;n;++i){     p=new LNode;     scanf(&amp;p-&gt;data);     p-&gt;next=NULL;     r-&gt;next=p;     r=p;//r指向新的尾结点   } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a><strong>循环链表</strong></h2><p>是一种头尾相接的链表<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/26.jpg"><br>优点：从表中任意结点出发均可找到表中其他结点  </p><blockquote><p>循环列表没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断<code>p</code>或<code>p-&gt;next </code>是否为空，而是判断他们是否等于头指针  </p></blockquote><p>循环条件:  </p><table><thead><tr><th>单链表</th><th>单循环链表</th></tr></thead><tbody><tr><td>p!=NULL</td><td>p!=L</td></tr><tr><td>P-&gt;next!=NULL</td><td>p-&gt;NEXT!=1</td></tr></tbody></table><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/27.jpg"> </p><blockquote><p>循环链表若经常需要对首尾进行操作，则设置尾指针更为合适  </p></blockquote><h3 id="带尾指针循环链表的合并"><a href="#带尾指针循环链表的合并" class="headerlink" title="带尾指针循环链表的合并"></a><strong>带尾指针循环链表的合并</strong></h3><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/28.jpg"></p><blockquote><p>p存表头结点，Tb表头连接到Ta表尾，释放Tb表头结点，修改指针<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/29.jpg"><br><code>p=Ta-&gt;next;</code><br><code>Ta-&gt;next=Tb-&gt;next-&gt;next;</code><br><code>delete Tb-&gt;next;</code>   </p></blockquote><p>算法描述  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">LinkList Connect(LinkList Ta,LinkList Tb){   p=Ta-&gt;next;   Ta-&gt;next=Tb-&gt;next-&gt;next;   delete Tb-&gt;next;   Tb-&gt;next=p;   return Tb; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a><strong>双向链表</strong></h2><p> 双向链表的结点结构<br> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/30.jpg">   </p><h3 id="双向链表的结构定义"><a href="#双向链表的结构定义" class="headerlink" title="双向链表的结构定义"></a><strong>双向链表的结构定义</strong></h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct DuLNode{  Elemtype data;  struct DuLNode *prior, *next;}DuLNode,*DuLinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/31.jpg">   </p><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a><strong>双向循环链表</strong></h3><p>-让头结点的前驱指针指向链表的最后一个结点<br>-让最后一个结点的后继指向头结点<br> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/32.jpg"> </p><h3 id="算法1-双向链表的插入"><a href="#算法1-双向链表的插入" class="headerlink" title="算法1 双向链表的插入"></a><strong>算法1</strong> 双向链表的插入</h3><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/33.jpg">   </p><blockquote><p><code>s-&gt;prior=p-&gt;prior;</code><br><code>p-&gt;prior-&gt;next=s;</code><br><code>s-&gt;next=p;</code><br><code>p-&gt;prior=s;</code>  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">void LinkInsert_DuL(DuLinkList &amp;L, int i,ElemType e){   if(!(p=GetElemP_DuL(L,i)))return ERROR;   s=new DuLNode;   s-&gt;data=e;   s-&gt;prior=p-&gt;prior;   p-&gt;prior-&gt;next=s;   s-&gt;next=p;   p-&gt;prior=s;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-双向链表的删除"><a href="#算法2-双向链表的删除" class="headerlink" title="算法2 双向链表的删除"></a><strong>算法2</strong> 双向链表的删除</h3><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/34.jpg"></p><blockquote><p><code>p-&gt;prior-&gt;next=p-&gt;next;</code><br><code>p-&gt;next-&gt;prior=p-&gt;prior;</code>  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">void LinkInsert_DuL(DuLinkList &amp;L, int i,ElemType e){   if(!(p=GetElemP_DuL(L,i)))return ERROR;   e=p-&gt;data;   p-&gt;prior-&gt;next=p-&gt;next;   p-&gt;next-&gt;prior=p-&gt;prior;   free(p);   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单链表、循环链表和双向链表的时间效率比较"><a href="#单链表、循环链表和双向链表的时间效率比较" class="headerlink" title="单链表、循环链表和双向链表的时间效率比较"></a><strong>单链表、循环链表和双向链表的时间效率比较</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/35.jpg">  </p><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a><strong>顺序表和链表的比较</strong></h2><p>链式存储结构的优点：</p><blockquote><p>结点空间可以动态申请和释放<br>删除和插入时不需要移动数据元素  </p></blockquote><p>链式存储结构的缺点：</p><blockquote><p>存储密度小，每个结点的指针域需额外占用存储空间<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/36.jpg"><br>非随机存取结构，对任意结点的操作都要从头指针依指针链查找到该结点，增加了算法复杂度  </p></blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/37.jpg">  </p><h2 id="案例1：一元多项式的运算"><a href="#案例1：一元多项式的运算" class="headerlink" title="案例1：一元多项式的运算"></a><strong>案例1：一元多项式的运算</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/38.jpg">  </p><h2 id="案例2：稀疏多项式的运算"><a href="#案例2：稀疏多项式的运算" class="headerlink" title="案例2：稀疏多项式的运算"></a><strong>案例2：稀疏多项式的运算</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/39.jpg">  </p><p>结构建立：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct PNode{    float coef;  //系数    int expn;    //指数    struct PNode *next; //指针域  }PNode,*Polynomial;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/40.jpg"></p><p>多项式创建：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void CreatePolyn(Polynomial &amp;P, int n){   P=new PNode;   P-&gt;next=NULL;   for(i=1;i&lt;=n;i++){    s=new PNode;    cin&gt;&gt;s-&gt;coef&gt;&gt;s-&gt;expn;    pre=P;    q=P-&gt;next;    while(q&amp;&amp;q-&gt;expn&lt;s-&gt;expn){      pre=q; q=q-&gt;next;    }    s-&gt;next=q;    pre-&gt;next=s;   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多项式相加：<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/41.jpg">  </p><h2 id="案例3：图书信息管理系统"><a href="#案例3：图书信息管理系统" class="headerlink" title="案例3：图书信息管理系统"></a><strong>案例3：图书信息管理系统</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/42.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础简记ch.1</title>
      <link href="/2022/09/07/php-ji-chu-jian-ji-ch.1/"/>
      <url>/2022/09/07/php-ji-chu-jian-ji-ch.1/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP基础简记ch-1"><a href="#PHP基础简记ch-1" class="headerlink" title="PHP基础简记ch.1"></a>PHP基础简记ch.1</h1><h2 id="PHP标记"><a href="#PHP标记" class="headerlink" title="PHP标记"></a><strong>PHP标记</strong></h2><p> 1.脚本标记   </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;script language="php"&gt;  echo 'hello world';&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 2.标准标记  </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  echo 'hello world';?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="PHP注释"><a href="#PHP注释" class="headerlink" title="PHP注释"></a><strong>PHP注释</strong></h2><ul><li>行注释 <code>//</code>、<code>#</code>  </li><li>块注释 <code>/* */</code></li></ul><h2 id="语句分隔符"><a href="#语句分隔符" class="headerlink" title="语句分隔符"></a><strong>语句分隔符</strong></h2><p>PHP中，代码是以行为单位，系统需要通过判断行的结束，该结束通常都是一个符号：分号 <code>;</code> (英文状态下的)</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  //定义变量  $var1;  $var2 = 1;//定义同时赋值  echo $var2;//通过var2变量名字找到储存内容1，然后输出    //删除变量，使用unset（变量名字）  unset($var2)?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>提前定义的变量，储存许多需要用的数据（预定义变量都是数组）  </p><ul><li>$_GET：获取所有表单以get方式提交的数据</li><li>$_POST: POST提交的数据都会保存在此次</li><li>$_REQUEST: GET和POST提交的都会保存</li><li>$_SERVER: 服务器信息</li><li>$_SESSION: session会话数据</li></ul><h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><p>如果一个变量保存的值刚好是另一个变量的名字，则可以：  </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  //可变变量  $a = 'b';  $b = 'bb';  echo $$a;  //输出结果为bb?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h3><p>将一个变量赋值给另一个变量  </p><ul><li>值传递  </li><li>引用传递</li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  $a = 1;  $b = $a; //值传递    $b = 2;  echo $a,$b;  //输出结果1,2  $a = 1;  $b = &amp;$a; //引用传递    $b = 2;  echo $a,$b;  //输出结果2,2?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h2><p>常量一旦定义，通常数据不可改变</p><ul><li>使用定义常量的函数 <code>define( , )</code>  </li><li>5.3后才有的：const 常量名 = 值</li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  define('PI',3.14) ;  const PII =3 ;?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>常量不需要使用<code>$</code>符号，一旦使用会被认为是变量<br>常量的名字组成由字母、数字和下划线组成，不能以数字开头<br>常量的名字通常以大写字母为主<br>define 和 const 定义的常亮有区别，在于权限的区别，如：   </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  define('-_-','smile') ;  //正确  const -_- ='smile' ; //错误?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如需访问常量，则需使用另外一个访问常量的函数：<code>echo constant('常量名')</code>  </p><h3 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h3><p>系统常量： 系统帮助用户定义的常量，用户可以直接使用<br>常用的几个系统常量：  </p><ul><li>PHP_VERSION  </li><li>PHP_INT_SIZE  </li><li>PHP_INT_MAX</li></ul><p>在PHP中还有一些特殊的常量，他们由双下划线开始+常量名+双下划线结束，这种常量称之为系统魔术常量，魔术常量的值通常会跟着环境变化，但是用户改变不了，如：  </p><ul><li><code>__DIR__</code>:被执行脚本在电脑的绝对路径  </li><li><code>__FILE__</code>:被执行脚本在电脑的绝对路径（带文件名）  </li><li><code>__LINE__</code>:当前所属行数的绝对路径  </li><li><code>__NAMESPACE__</code>:当前所属命名空间  </li><li><code>__CLASS__</code>:当前所属类  </li><li><code>__METHOD__</code>:当前所属方法</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>在PHP中得的是存储的数据本身的类型，而不是变量的类型，PHP是一种弱类型语言，本身并没有类型  </p><h3 id="PHP的八种数据类型"><a href="#PHP的八种数据类型" class="headerlink" title="PHP的八种数据类型"></a>PHP的八种数据类型</h3><p>在PHP中将数据分为三大类八小类  </p><ul><li>基本数据类型<ul><li>整型：int ，四个字节储存  </li><li>浮点型：float/double ，八个字节储存</li><li>字符串型：string  </li><li>布尔类型：bool</li></ul></li><li>复合数据类型<ul><li>对象：object ，存放对象  </li><li>数组：array ，存储多个数据（一次性）</li></ul></li><li>特殊数据类型<ul><li>资源：resource ，存放资源数据</li><li>空类型：NULL</li></ul></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>需要指定数据类型，需要外部数据  </p><ul><li>自动转换：系统根据需求自己判定，效率偏低  </li><li>强制转换：人为转换，在变量前加一个括号，在里面写入对应类型</li></ul><p>在转换过程中，用的比较多的为转布尔类型和转数值类型，关于转布尔的说明：<br><img src="/2022/09/07/php-ji-chu-jian-ji-ch.1/about_bool.jpg" alt="布尔的相关说明">  </p><p>字符串转数值的说明  </p><ul><li>布尔true为1， false为0  </li><li>字符串转数值：<ul><li>以字母开头的字符串永远为0</li><li>以数字开头的字符串，取到碰到字符串为止（不会出现多个小数点）</li></ul></li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  $a = 'abc1.1.1';  $b = '1.1.1abc'; //创建数据  echo $a + $b;  //自动转换  //算数+运算，系统先转换成数值类型（整型和浮点型）  //结果为1.1    echo (float)$a,(foloat)$b; //输出结果01.1?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h3><p>通过一组类型判断函数，来判断变量，最终返回这个变量所保存的数据类型（如果相同返回true）：以is_开头后面跟类型名字的函数: is_xxx(变量名)</p><p>bool类型不能用echo来查看，可使用<code>var_dump</code>结构来查看  </p><p>还有一组函数可以来获取积极设定数据的类型 gettype(变量名)：获取类型，得到的是该类型对应的字符串</p><p>settype(变量名，类型): 设定数据类型：与强制转换不同  </p><ul><li>强制转换是对数据值复制的内容进行处理  </li><li>settype会改变变量本身</li></ul><h3 id="整数类型进制"><a href="#整数类型进制" class="headerlink" title="整数类型进制"></a>整数类型进制</h3><blockquote><p>在PHP中提供了四种类型的定义方式：十进制、二进制、八进制、十六进制<br><code>$a=120; //十进制</code><br><code>$a=0b120; //二进制</code><br><code>$a=0120; //八进制</code><br><code>$a=0x120; //十六进制</code>  </p></blockquote><h3 id="整数类型进制转换"><a href="#整数类型进制转换" class="headerlink" title="整数类型进制转换"></a>整数类型进制转换</h3><ul><li><code>decbin()</code>:10转2  </li><li><code>decoct()</code>:10转8  </li><li><code>dechex()</code>:10转16  </li><li><code>bindec()</code>:2转10</li></ul><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>整型超过自身存储的大小后会用浮点型存储  </p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h2><p>与其他语言几乎一致，补充一点‘全等于’：<code>===</code> 左边与右边相同(大小、数据类型)</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
