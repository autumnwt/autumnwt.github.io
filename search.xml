<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构之线性表</title>
      <link href="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/"/>
      <url>/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之线性表"><a href="#数据结构之线性表" class="headerlink" title="数据结构之线性表"></a>数据结构之线性表</h1><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a><strong>知识回顾</strong></h2><p>数据结构  </p><ul><li>逻辑结构  <ul><li>线性结构  <ul><li>线性表  </li><li>栈（特殊线性表） </li><li>队列（特殊线性表）</li><li>字符串、数组、广义表</li></ul></li><li>非线性结构  <ul><li>树形结构  </li><li>图形结构</li></ul></li></ul></li><li>数据的存储结构  <ul><li>顺序存储  </li><li>链式存储</li></ul></li><li>数据的运算：检索、排序、插入…</li></ul><h2 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a><strong>线性表的定义和特点</strong></h2><p>线性表是具有相同特性的数据元素的一个有限序列  </p><blockquote><p>(a1,a2,…,ai-1,ai,ai+1,…an)  </p><p>a1:线性起点<br>ai-1:ai的直接前趋<br>ai+1:ai的直接后继<br>an:线性终点<br>n=0时称为空表（n是表长） </p></blockquote><p>同一线性表中的元素必定具有相同特性，数据元素之间的关系是线性关系  </p><h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a><strong>案例引入</strong></h2><p>案例一：一元多项式的运算：实现两个多项式的加、减、乘运算  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/1.jpg" alt="案例一">  </p><p>案例二：稀疏多项式的运算  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/2.jpg"><br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/3.jpg" alt="案例二">  </p><blockquote><p>Q:那么数组C多大合适呢？  </p><p>顺序存储结构存在的问题  </p><ul><li>存储空间分配不灵活  </li><li>运算的空间复杂度高</li></ul></blockquote><p>—&gt;选择链式存储结构<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/4.jpg" alt="链式存储方法">   </p><p>案例三：图书信息管理系统  </p><ul><li>将图书表抽象为线性表  </li><li>表中每本书抽象线性表中数据元素</li></ul><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/5.jpg" alt="两种方式">  </p><p>线性表中数据元素可以是<em>简单类型</em>，也可以是<em>复杂类型</em>  </p><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a><strong>线性表的类型定义</strong></h2><blockquote><p>抽象数据类型（ADT）</p><ul><li>数据对象</li><li>数据对象关系集合  </li><li>作用在数据对象上的基本操作</li></ul></blockquote><p>抽象数据类型线性表的定义如下：  </p><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT List{   数据对象：D={ai|ai属于Elemset，(i=1,2,3...n，n&gt;=0)}     数据关系：R={&lt;ai-1，ai&gt;|ai-1，ai属于D，(i=1,2,3...n)}   基本操作：   IntList(&amp;L);   DestoryList(&amp;L);   ListInsert(&amp;L,i,e);   ListDelete(&amp;L,i,&amp;e);   ...}ADT List<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>InitList(&amp;L):构造一个空的线性表L</li><li>DestoryList(&amp;L)：线性表已存在的条件下，销毁线性表  </li><li>ClwanList(&amp;L)：线性表已存在的条件下，清除线性表元素，置L为空表  </li><li>ListEmpty(L)：线性表已存在的条件下，若L为空表，返回TRUE，否则返回FALSE</li><li>ListLength(L):线性表已存在的条件下，返回L中元素个数</li><li>GetElem(L,I,&amp;e):线性表已存在的条件下，1&lt;=i&lt;=ListLength(L),用e返回线性表中第i个元素的值</li><li>LocateElem(L,e,compare()):线性表已存在的条件下，compare()是数据元素判定函数，返回L中第一个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0</li><li>PriorElem(L,cur_e,&amp;pre_e):线性表已存在的条件下，若cur_e是L的数据元素，且不是第一个，则用pre_e返回他的前趋，否则操作失败，pre_e无意义</li><li>NextElem(L,cur_e,&amp;next_e):线性表已存在的条件下，若cur_e是L的数据元素，且不是最后一个，则用next_e返回他的后继，否则操作失败，next_e无意义</li><li>ListInsert(&amp;L,i,e):线性表已存在的条件下，1&lt;=i&lt;=ListLength(L)+1，在L的第i个位置之前插入新的元素e，L的长度加1</li><li>ListDelete(&amp;L,i,&amp;e)：线性表已存在的条件下，1&lt;=i&lt;=ListLength(L)，删除L的第i个元素，并用e返回其值，L的长度-1 </li><li>ListTraverse(&amp;L,visited()):线性表已存在的条件下，依次对线性表中的每个元素调用遍历visited()</li></ul><p>以上提及的运算是逻辑结构上定义的运算，只要给出这些运算功能是“做什么”，至于“如何做”，只有待确定了存储结构之后才考虑</p><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a><strong>线性表的顺序表示和实现</strong></h2><p>顺序存储：把逻辑上相邻的数据元素储存在物理上相邻的存储单元中的存储结构  </p><blockquote><p>线性表中的第一个数据元素a1的存储位置，称作线性表的<strong>起始位置</strong>或<strong>基地址</strong>  </p></blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/6.jpg" alt="两种方式">   </p><p>假设线性表的每个元素需要占用k个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足:LOC(ai+1)=LOC(ai)+k ；同时LOC(ai)=LOC(ai)+(i-1)*k  </p><blockquote><p>顺序表元素-&gt;数组元素<br>用一维数组表示顺序表  </p></blockquote><p>线性表长度可变但数组长度不可动态定义<br>-&gt;用以变量表示顺序表的长度属性  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define LIST INIT SIZE 100 //线性表存储空间的初始分配量  typedef struct {    ElemType elem[LIST_INIT_SIZE];    int length; //当前长度}SqList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多项式的顺序结构储存结构类型定义</strong>  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/7.jpg">  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 1000 //多项式可能达到的最大长度typedef struct {  //多项式非零项的定义  float p;  //系数  int e;  //指数}Polynomial;   typedef struct {    Polynomial *elem;  //储存空间的基地址  int length;  //多项式中当前项的个数}SqList;//多项式的顺序储存结构类型为SqList```  **图书表的顺序存储结构类型定义**   ![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/8.jpg)   ```C#define MAXSIZE 1000 //图书表可能达到的最大长度typedef struct {  //图书信息定义  char no[20];  char name[50];  float price;}Book;   typedef struct {   Book *elem;  //储存空间的基地址  int length;  //图书表中当前图书个数}SqList;//图书表的顺序储存结构类型为SqList  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线性表的数据类型定义模板"><a href="#线性表的数据类型定义模板" class="headerlink" title="线性表的数据类型定义模板"></a><strong>线性表的数据类型定义模板</strong></h3><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/9.jpg"> </p><h2 id="类C语言有关操作"><a href="#类C语言有关操作" class="headerlink" title="类C语言有关操作"></a><strong>类C语言有关操作</strong></h2><p>数组静态分配：<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   Elem Type data[MaxSize];    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>data:首元素地址</p></blockquote><p>数组动态分布<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   Elem Type *data;    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>SqList L;<br>L.data=(Elem Type*)malloc(sizeof(Elem Type)*MaxSize);  </p></blockquote><p><code>malloc(m)</code>函数：开辟m字节长度的地址空间，并返回这段空间的首地址<br><code>sizeof(x)</code>运算：计算变量x的长度<br><code>free(p)</code>函数：释放指针p所指变量的存储空间，即彻底删除一个变量  </p><blockquote><p>需要加载头文件<code>&lt;stdlib.h&gt;</code>  </p></blockquote><p>补充：   </p><h3 id="C-的动态存储分配"><a href="#C-的动态存储分配" class="headerlink" title="C++的动态存储分配"></a><strong>C++的动态存储分配</strong></h3><p>new 类型名T(初始列表)<br>功能：申请用于存放T类型对象的内存空间，并依初值列表赋值以初值<br>结果值：  </p><ul><li>成功：T类型指针，指向新分配内存  </li><li>失败：0 （NULL）</li></ul><p><code>int *p1 = new int;</code><br>或 <code>int *p1 = new int（10）;</code><br>使用 <code>delete 指针P</code> 释放 </p><h2 id="线性表的顺序表示和实现-1"><a href="#线性表的顺序表示和实现-1" class="headerlink" title="线性表的顺序表示和实现"></a><strong>线性表的顺序表示和实现</strong></h2><p>线性表类型的构造（回顾）：<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   Elem Type data[MaxSize];    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>线性表变量L的定义以及成员读取：<br> <pre class="line-numbers language-C" data-language="C"><code class="language-C">SqList L;L.elem;//orSqList *L;L-&gt;elem;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>补充：操作算法中用到的预定义常量和类型<br> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/10.jpg"> <p></p><h3 id="算法1-线性表的初始化"><a href="#算法1-线性表的初始化" class="headerlink" title="算法1 线性表的初始化"></a><strong>算法1</strong> 线性表的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitList_Sq(SqList &amp;L){  L.elem=new eLEMType[MAXSIZE];  if(!L.elem) exit(OVERFLOW);  L.length=0; //空表长度为0  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-线性表的销毁"><a href="#算法2-线性表的销毁" class="headerlink" title="算法2 线性表的销毁"></a><strong>算法2</strong> 线性表的销毁</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void DestroyList(SqList &amp;L){ if(L.elem)delete L.elem;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法3-线性表的清空"><a href="#算法3-线性表的清空" class="headerlink" title="算法3 线性表的清空"></a><strong>算法3</strong> 线性表的清空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void CleanList(SqList &amp;L){ L.Length=0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法4-线性表的长度"><a href="#算法4-线性表的长度" class="headerlink" title="算法4 线性表的长度"></a><strong>算法4</strong> 线性表的长度</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int GetLength(SqList L){ renturn(L.Length);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法5-判断线性表是否为空"><a href="#算法5-判断线性表是否为空" class="headerlink" title="算法5 判断线性表是否为空"></a><strong>算法5</strong> 判断线性表是否为空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int IsEmpty(SqList L){ if(L.Length==0)return 1; else return 0；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-顺序表的取值（取值i元素）"><a href="#算法6-顺序表的取值（取值i元素）" class="headerlink" title="算法6 顺序表的取值（取值i元素）"></a><strong>算法6</strong> 顺序表的取值（取值i元素）</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int GetElem(SqList L, ElemType &amp;e){ if(i&lt;1||i&gt;L.length)return ERROR; e=L.elem[i-1]; return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-顺序表的元素查找（顺序查找）"><a href="#算法7-顺序表的元素查找（顺序查找）" class="headerlink" title="算法7 顺序表的元素查找（顺序查找）"></a><strong>算法7</strong> 顺序表的元素查找（顺序查找）</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int LocateElem(SqList L, ElemType e){ for(i=0；i&lt;L.length;i++)   if(L.elem[i]==e) return i+1; return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/11.jpg">  </p><h3 id="算法8-顺序表的元素插入"><a href="#算法8-顺序表的元素插入" class="headerlink" title="算法8 顺序表的元素插入"></a><strong>算法8</strong> 顺序表的元素插入</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListInsert_Sq(SqList &amp;L,int i,Elem Type e){  if(i&lt;1||i&gt;L.length+1)return ERROR; //i值不合法  if(L.length==MAXSIZE)return ERROR; //当前存储空间已满  for(j=L.length-1;j&gt;=i-1;j--)   L.elem[j+1]=L.elem[j];   L.elem[i-1]=e;   L.length++; //表长+1   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/12.jpg">   </p><h3 id="算法9-顺序表的元素删除"><a href="#算法9-顺序表的元素删除" class="headerlink" title="算法9 顺序表的元素删除"></a><strong>算法9</strong> 顺序表的元素删除</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListDelete_Sq(SqList &amp;L,int i){  if(i&lt;1||i&gt;L.length+1)return ERROR; //i值不合法  for(j=i;j&lt;=L.length-1;j++)   L.elem[j-1]=L.elem[j];   L.length--; //表长-1   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/14.jpg">  </p><h2 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a><strong>线性表的链式表示和实现</strong></h2><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/15.jpg">  </p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a><strong>相关术语</strong></h3><ul><li>结点；数据元素的存储映像，由数据域和指针域两部分组成  </li><li>链表：n个结点由指针链组成一个链表</li></ul><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/16.jpg" alt="带头结点的单链表">   </p><p>单链表：有一个指针域<br>双链表：有两个指针域<br>循环链表：首尾相接  </p><p>头指针：指向链表第一个结点的指针<br>首元结点：存储第一个数据元素a1的结点<br>头结点：实在链表的首元结点之前附设的一个结点<br>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/17.jpg">  </p><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/18.jpg">  </p><blockquote><p><em>如何表示空表？</em><br>无头结点时，头指针为空时表示空表<br>有头结点时，当头结点的指针域为空时表示空表  </p></blockquote><blockquote><p><em>在链表中设置头结点有什么好处？</em><br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/19.jpg">  </p></blockquote><blockquote><p><em>头结点的数据域内装的是什么？</em><br>数据域可以为空，也可以存放表长等信息，但此结点不计入表长值  </p></blockquote><p>顺序表：随机存取<br>链表：顺序存取</p><p>单链表是由表头唯一确定的，因此单链表可以用<strong>头指针</strong>的名字来命名，若头指针名是L，则把链表称为表L</p><h3 id="链表结点的定义"><a href="#链表结点的定义" class="headerlink" title="链表结点的定义"></a><strong>链表结点的定义</strong></h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct Lnode{ ElemType data;  //结点的数据域 struct Lnode *next;  //结点的指针域  }Lnode,*LinkList;//LlinkList为指向结构体Lnode的指针类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>单链表L的定义：<br>定义链表L： <code>LinkList L;</code><br>定义结点指针p： <code>LNode *p;</code> 、<code>LinkList p;</code></p><p>例如，存储学生学号、姓名、成绩的单链表结点类型定义如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct student{ char num[8]; char name[8]; int score; struct student *next;  }Lnode,*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过为了统一链表的操作，通常这样定义：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct { char num[8]; char name[8]; int score; }ElemType;typedef struct Lnode{ ElemType data； struct Lnode *next;  }Lnode,*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础简记ch.1</title>
      <link href="/2022/09/07/php-ji-chu-jian-ji-ch.1/"/>
      <url>/2022/09/07/php-ji-chu-jian-ji-ch.1/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP基础简记ch-1"><a href="#PHP基础简记ch-1" class="headerlink" title="PHP基础简记ch.1"></a>PHP基础简记ch.1</h1><h2 id="PHP标记"><a href="#PHP标记" class="headerlink" title="PHP标记"></a><strong>PHP标记</strong></h2><p> 1.脚本标记   </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;script language="php"&gt;  echo 'hello world';&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 2.标准标记  </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  echo 'hello world';?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="PHP注释"><a href="#PHP注释" class="headerlink" title="PHP注释"></a><strong>PHP注释</strong></h2><ul><li>行注释 <code>//</code>、<code>#</code>  </li><li>块注释 <code>/* */</code></li></ul><h2 id="语句分隔符"><a href="#语句分隔符" class="headerlink" title="语句分隔符"></a><strong>语句分隔符</strong></h2><p>PHP中，代码是以行为单位，系统需要通过判断行的结束，该结束通常都是一个符号：分号 <code>;</code> (英文状态下的)</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  //定义变量  $var1;  $var2 = 1;//定义同时赋值  echo $var2;//通过var2变量名字找到储存内容1，然后输出    //删除变量，使用unset（变量名字）  unset($var2)?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>提前定义的变量，储存许多需要用的数据（预定义变量都是数组）  </p><ul><li>$_GET：获取所有表单以get方式提交的数据</li><li>$_POST: POST提交的数据都会保存在此次</li><li>$_REQUEST: GET和POST提交的都会保存</li><li>$_SERVER: 服务器信息</li><li>$_SESSION: session会话数据</li></ul><h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><p>如果一个变量保存的值刚好是另一个变量的名字，则可以：  </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  //可变变量  $a = 'b';  $b = 'bb';  echo $$a;  //输出结果为bb?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h3><p>将一个变量赋值给另一个变量  </p><ul><li>值传递  </li><li>引用传递</li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  $a = 1;  $b = $a; //值传递    $b = 2;  echo $a,$b;  //输出结果1,2  $a = 1;  $b = &amp;$a; //引用传递    $b = 2;  echo $a,$b;  //输出结果2,2?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h2><p>常量一旦定义，通常数据不可改变</p><ul><li>使用定义常量的函数 <code>define( , )</code>  </li><li>5.3后才有的：const 常量名 = 值</li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  define('PI',3.14) ;  const PII =3 ;?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>常量不需要使用<code>$</code>符号，一旦使用会被认为是变量<br>常量的名字组成由字母、数字和下划线组成，不能以数字开头<br>常量的名字通常以大写字母为主<br>define 和 const 定义的常亮有区别，在于权限的区别，如：   </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  define('-_-','smile') ;  //正确  const -_- ='smile' ; //错误?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如需访问常量，则需使用另外一个访问常量的函数：<code>echo constant('常量名')</code>  </p><h3 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h3><p>系统常量： 系统帮助用户定义的常量，用户可以直接使用<br>常用的几个系统常量：  </p><ul><li>PHP_VERSION  </li><li>PHP_INT_SIZE  </li><li>PHP_INT_MAX</li></ul><p>在PHP中还有一些特殊的常量，他们由双下划线开始+常量名+双下划线结束，这种常量称之为系统魔术常量，魔术常量的值通常会跟着环境变化，但是用户改变不了，如：  </p><ul><li><code>__DIR__</code>:被执行脚本在电脑的绝对路径  </li><li><code>__FILE__</code>:被执行脚本在电脑的绝对路径（带文件名）  </li><li><code>__LINE__</code>:当前所属行数的绝对路径  </li><li><code>__NAMESPACE__</code>:当前所属命名空间  </li><li><code>__CLASS__</code>:当前所属类  </li><li><code>__METHOD__</code>:当前所属方法</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>在PHP中得的是存储的数据本身的类型，而不是变量的类型，PHP是一种弱类型语言，本身并没有类型  </p><h3 id="PHP的八种数据类型"><a href="#PHP的八种数据类型" class="headerlink" title="PHP的八种数据类型"></a>PHP的八种数据类型</h3><p>在PHP中将数据分为三大类八小类  </p><ul><li>基本数据类型<ul><li>整型：int ，四个字节储存  </li><li>浮点型：float/double ，八个字节储存</li><li>字符串型：string  </li><li>布尔类型：bool</li></ul></li><li>复合数据类型<ul><li>对象：object ，存放对象  </li><li>数组：array ，存储多个数据（一次性）</li></ul></li><li>特殊数据类型<ul><li>资源：resource ，存放资源数据</li><li>空类型：NULL</li></ul></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>需要指定数据类型，需要外部数据  </p><ul><li>自动转换：系统根据需求自己判定，效率偏低  </li><li>强制转换：人为转换，在变量前加一个括号，在里面写入对应类型</li></ul><p>在转换过程中，用的比较多的为转布尔类型和转数值类型，关于转布尔的说明：<br><img src="/2022/09/07/php-ji-chu-jian-ji-ch.1/about_bool.jpg" alt="布尔的相关说明">  </p><p>字符串转数值的说明  </p><ul><li>布尔true为1， false为0  </li><li>字符串转数值：<ul><li>以字母开头的字符串永远为0</li><li>以数字开头的字符串，取到碰到字符串为止（不会出现多个小数点）</li></ul></li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  $a = 'abc1.1.1';  $b = '1.1.1abc'; //创建数据  echo $a + $b;  //自动转换  //算数+运算，系统先转换成数值类型（整型和浮点型）  //结果为1.1    echo (float)$a,(foloat)$b; //输出结果01.1?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h3><p>通过一组类型判断函数，来判断变量，最终返回这个变量所保存的数据类型（如果相同返回true）：以is_开头后面跟类型名字的函数: is_xxx(变量名)</p><p>bool类型不能用echo来查看，可使用<code>var_dump</code>结构来查看  </p><p>还有一组函数可以来获取积极设定数据的类型 gettype(变量名)：获取类型，得到的是该类型对应的字符串</p><p>settype(变量名，类型): 设定数据类型：与强制转换不同  </p><ul><li>强制转换是对数据值复制的内容进行处理  </li><li>settype会改变变量本身</li></ul><h3 id="整数类型进制"><a href="#整数类型进制" class="headerlink" title="整数类型进制"></a>整数类型进制</h3><blockquote><p>在PHP中提供了四种类型的定义方式：十进制、二进制、八进制、十六进制<br><code>$a=120; //十进制</code><br><code>$a=0b120; //二进制</code><br><code>$a=0120; //八进制</code><br><code>$a=0x120; //十六进制</code>  </p></blockquote><h3 id="整数类型进制转换"><a href="#整数类型进制转换" class="headerlink" title="整数类型进制转换"></a>整数类型进制转换</h3><ul><li><code>decbin()</code>:10转2  </li><li><code>decoct()</code>:10转8  </li><li><code>dechex()</code>:10转16  </li><li><code>bindec()</code>:2转10</li></ul><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>整型超过自身存储的大小后会用浮点型存储  </p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h2><p>与其他语言几乎一致，补充一点‘全等于’：<code>===</code> 左边与右边相同(大小、数据类型)</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/02/hello-world/"/>
      <url>/2022/09/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
