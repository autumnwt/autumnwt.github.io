<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构之图</title>
      <link href="/2022/11/17/shu-ju-jie-gou-zhi-tu/"/>
      <url>/2022/11/17/shu-ju-jie-gou-zhi-tu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之图"><a href="#数据结构之图" class="headerlink" title="数据结构之图"></a>数据结构之图</h1><h2 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a><strong>图的定义和术语</strong></h2><p>图：G=(V,E)<br>V:顶点的有穷非空集合；<br>E：边的有穷集合；</p><p><strong>无向图</strong>：每条边都是无方向的<br><strong>有向图</strong>：每条边都是有方向的 </p><p><strong>完全图</strong>：任意两个点都有一条边相连<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/1.jpg">  </p><p><strong>稀疏图</strong>：有很少边或者弧的图<br><strong>稠密图</strong>：有较多边或弧的图<br><strong>网</strong>：边、弧带权的图<br>邻接：有边、弧相连的两个顶点之间的关系<br>存在(vi，vj)，则称vi和vj互为邻接点<br>存在&lt;vi，vj&gt;，则称vi邻接到vj，vj邻接于vi<br>**关联(依附)**：边、弧与顶点之间的关系，存在(vi，vj)/&lt;vi，vj&gt;,则称该边/弧关联于vi和vj  </p><p><strong>顶点的度</strong>：与该顶点相关联的边的数目，记为TD(v)</p><blockquote><p>在有向图中，顶点的度等于该顶点的入度与出度之和，顶点v的入度是以v为终点的有向边的条数，记为ID(v)；顶点的出度是以v为始点的有向边的条数，记作OD(v)<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/2.jpg">  </p></blockquote><p><strong>路径</strong>：接续的边构成的顶点序列<br><strong>路径长度</strong>：路径上边或弧的数目/权值之和<br><strong>回路</strong>：第一个顶点和最后一个顶点相同的路径<br><strong>简单路径</strong>：除路径起点和终点可以相同外，其余顶点均不相同<br><strong>简单回路</strong>：除路径起点和终点相同外，其余顶点均不相同  </p><blockquote><p><strong>连通图(强联通图)</strong><br>任意两个顶点都存在路径<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/3.jpg">  </p></blockquote><p><strong>权与网</strong>：图中边或弧所具有的相关数称为权，表明从一个顶点到顶一个顶点的距离或耗费<br><strong>子图</strong>：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/4.jpg">  </p><p>**连通分量(强连通分量)**：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/5.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/6.jpg">  </p><p><strong>极小连通子图</strong>：该子图是G的连通子图，在该子图中删除任意一条边会使子图不再连通<br><strong>生成树</strong>：包含无向图G所有顶点的极小连通子图<br><strong>生成森林</strong>：对非连通图，由各个连通分量的生成树的集合<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/7.jpg">  </p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><strong>图的存储结构</strong></h2><p>1.数组表示法（邻接矩阵）<br>2.链式存储结构：邻接表、邻接多重表、十字链表</p><h3 id="数组表示法（邻接矩阵）"><a href="#数组表示法（邻接矩阵）" class="headerlink" title="数组表示法（邻接矩阵）"></a><strong>数组表示法（邻接矩阵）</strong></h3><p>建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间的关系）<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/8.jpg"><br><strong>无向图的邻接矩阵表示法</strong><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/9.jpg"><br><strong>有向图的邻接矩阵表示法</strong><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/10.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/11.jpg"><br><strong>网（有权图）的邻接矩阵表示法</strong><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/12.jpg">  </p><h4 id="邻接矩阵的存储表示"><a href="#邻接矩阵的存储表示" class="headerlink" title="邻接矩阵的存储表示"></a><strong>邻接矩阵的存储表示</strong></h4><p>用两个数组分别存储顶点表和邻接矩阵  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MaxInt 32767 //表示极大值#define MVNum 100 //最大顶点数typedef char VerTexType;//设定点的数据类型为字符型 typedef int ArcType;//假设边的权值类型为整型  typedef struct {    VerTexType vexs[MVNum];//顶点表    ArcType arcs[MVNum][MVNum]; //邻接矩阵    int vexnum,arcnum;//图的当前点数和边数}AMGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/13.jpg"> </p><h5 id="算法1-采用邻接矩阵表示法创建无向图"><a href="#算法1-采用邻接矩阵表示法创建无向图" class="headerlink" title="算法1 采用邻接矩阵表示法创建无向图"></a><strong>算法1</strong> 采用邻接矩阵表示法创建无向图</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status CreateUND(AMGragh &amp;G){   cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;//输入总顶点数、总边数     for(i=0;i&lt;G.vexnum;++i){    cin&gt;&gt;G.vex[i];//依次输入点的信息   }   for(i=0;i&lt;G.vexnum;++i)    for(j=0;j&lt;G.vexnum;++j)     G.arcs[i][j]=Maxint;//边的权值均置为极大值      for(k=0;k&lt;G.arcnum;++k){    //构造邻接矩阵    cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;//输入一条边所依附的顶点及边的权值      i=LocateVex(G,v1);    j=LocateVex(G,v2);//确定v1和v2在G的位置     G.arcs[i][j]=w;     G.arcs[j][i]=G.arcs[i][j];//边&lt;v1,v2&gt;的权值设置为w，置对称边权值为w   }   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="补充算法-在图中查找顶点"><a href="#补充算法-在图中查找顶点" class="headerlink" title="补充算法 在图中查找顶点"></a><strong>补充算法</strong> 在图中查找顶点</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">int LocateVex(AMGraph G,VertexType u){    //在图G查找顶点u，返回顶点下标    int i;    for(i=0;i&lt;G.vexnum;++i){        if(u==G.vex[i])return i;    }    return -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="邻接矩阵的优缺"><a href="#邻接矩阵的优缺" class="headerlink" title="邻接矩阵的优缺"></a><strong>邻接矩阵的优缺</strong></h4><blockquote><p>优点：<img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/14.jpg">  </p></blockquote><blockquote><p>缺点：<img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/15.jpg">  </p></blockquote><h3 id="邻接表表示法-链式"><a href="#邻接表表示法-链式" class="headerlink" title="邻接表表示法(链式)"></a><strong>邻接表表示法(链式)</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/16.jpg">  </p><p>无向图：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/17.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/18.jpg"></p><p>有向图：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/19.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/20.jpg">  </p><h4 id="邻接表的存储表示"><a href="#邻接表的存储表示" class="headerlink" title="邻接表的存储表示"></a><strong>邻接表的存储表示</strong></h4><p>顶点的结点结构</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct VNode{    VerTexType data;//顶点信息    ArcNode *firstarcs; //指向第一条依附该顶点的边的指针}VNode,AdjList[MVNum];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>例如AdjList v;相当于：VNode v[MVNum];  </p></blockquote><p>边结点结构  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MVNum 100//最大顶点数typedef struct ArcNode{    //边结点    int adjvex//该边所指向的顶点位置    struct ArcNode *nextarc;//指向下条边的指针    OtherInfo info; //和边相关的信息}ArcNode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图的结构定义</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {    AdjList vertices;//vertices--vertex的复数    int vexnum,arcnum;//图的当前顶点数和弧数}ALGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>邻接表操作举例说明：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/21.jpg"><br>采用邻接表表示法创建无向图  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status CreateUDG(ALGraph &amp;G) {    //采用邻接表表示法，创建无向图G    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;    for(i=0;i&lt;G.vexnum;++i){        cin&gt;&gt;G.vertices[i].data;        G.vertices[i].firstarc=NULL;    }    for(k=0;k&lt;G.arcnum;++k){        cin&gt;&gt;v1&gt;&gt;v2;        i=LocateVex(G,v1);        j=LocateVex(G,v2);        p1=new ArcNode;        p1-&gt;adjvex=j;        p1-&gt;nexrarc=G.vertices[i].firstarc;        G.vertices[i].firstarc=p1;        p2=new ArcNode;        p2-&gt;adjvex=i;        p2-&gt;nexrarc=G.vertices[j].firstarc;        G.vertices[j].firstarc=p2;    }    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="邻接表的优缺"><a href="#邻接表的优缺" class="headerlink" title="邻接表的优缺"></a><strong>邻接表的优缺</strong></h4><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/22.jpg"><br>邻接矩阵与邻接表的关系<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/23.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/24.jpg"><br>可供选择的其他存储结构<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/25.jpg"></p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a><strong>十字链表</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/26.jpg">  </p><blockquote><p>顶点结点：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/27.jpg"><br>firstin:第一条入弧<br>firstout:第一条出弧</p></blockquote><blockquote><p>弧结点：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/28.jpg"><br>tailvex:弧尾位置<br>headvex:弧头位置<br>hlink:弧头相同的下一条弧<br>tlink:弧尾相同的下一条弧</p></blockquote><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/29.jpg"></p><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a><strong>邻接多重表</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/30.jpg"></p><h2 id="图的遍历-深度优先"><a href="#图的遍历-深度优先" class="headerlink" title="图的遍历-深度优先"></a><strong>图的遍历-深度优先</strong></h2><p>定义：从已给的连通图中某一顶点出发，沿着一些边访遍图中的所有顶点，且使每个顶点仅被访问一次    </p><p>遍历实质：找到邻接点  </p><blockquote><p>图的特点：<br> 图中可能存在回路，且图的任一顶点都可能与其他顶点相通，在访问完某个顶点之后可能会沿着某些边又回到曾经访问过的顶点，如何避免？  </p></blockquote><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/31.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/32.jpg"></p><h3 id="邻接矩阵表示的无向图深度遍历实现"><a href="#邻接矩阵表示的无向图深度遍历实现" class="headerlink" title="邻接矩阵表示的无向图深度遍历实现"></a><strong>邻接矩阵表示的无向图深度遍历实现</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/33.jpg">  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void DFS(AMGraph G,int v){    //图G为邻接矩阵类型    cout&lt;&lt;v;    visited[v]=true;//访问第v个顶点    for(w=0;w&lt;G.vexnum;w++)//依次检查邻接矩阵v所在的行    if((G.arcs[v][w]!=0)&amp;&amp;(!visited[w]))DFS(G,w);    //w是v的邻接点，如果w未访问，则递归调用DFS}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="深度遍历效率"><a href="#深度遍历效率" class="headerlink" title="深度遍历效率"></a><strong>深度遍历效率</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/34.jpg">  </p><h3 id="非连通图的深度优先遍历"><a href="#非连通图的深度优先遍历" class="headerlink" title="非连通图的深度优先遍历"></a><strong>非连通图的深度优先遍历</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/35.jpg">  </p><h2 id="图的遍历-广度优先"><a href="#图的遍历-广度优先" class="headerlink" title="图的遍历-广度优先"></a><strong>图的遍历-广度优先</strong></h2><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/36.jpg">  </p><h3 id="邻接表表示的无向图广度遍历实现"><a href="#邻接表表示的无向图广度遍历实现" class="headerlink" title="邻接表表示的无向图广度遍历实现"></a><strong>邻接表表示的无向图广度遍历实现</strong></h3><p>利用队列实现<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/37.jpg"><br>F：队头指针  R：队尾指针  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void BFS(Graph G,int v){    //按广度优先非递归遍历图G    cout&lt;&lt;v;    visited[v]=true;//访问第v个顶点    InitQueue(Q);//辅助队列Q初始化，置空      EnQueue(Q,v);//v进队      while(!QueueEmpty(Q)){//队列非空        DeQueue(Q,u);//队头元素出队并置为u        for(w=FirstAdjVex(G,u);w&gt;=0;w=NextAdjVex(G,u,w))        if(!visited[w]){            //w为u的尚未访问的邻接顶点            cout&lt;&lt;w;visited[w]=true;            EnQueue(Q,w);//w进队        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="广度遍历与深度遍历的比较"><a href="#广度遍历与深度遍历的比较" class="headerlink" title="广度遍历与深度遍历的比较"></a><strong>广度遍历与深度遍历的比较</strong></h2><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/38.jpg">  </p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a><strong>最小生成树</strong></h2><blockquote><p>回顾：生成树：所有顶点均由边连接在一起，但是不存在回路的图<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/39.jpg"><br>·一个图可以有许多棵不同的生成树<br>·所有生成树具有以下共同特点：<br>1.生成树的顶点个数与图的顶点个数相同<br>2.生成树是图的极小连通子图<br>3.在生成树中再加一条边必然形成回路<br>4.生成树中任意两个顶点间的路径是唯一的  </p></blockquote><h3 id="无向图的生成树"><a href="#无向图的生成树" class="headerlink" title="无向图的生成树"></a><strong>无向图的生成树</strong></h3><p>利用优先遍历即可  </p><blockquote><p>深度优先遍历形成的生成树<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/40.jpg"></p></blockquote><blockquote><p>广度优先遍历形成的生成树<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/41.jpg"></p></blockquote><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/42.jpg"></p><h3 id="最小生成树的定义"><a href="#最小生成树的定义" class="headerlink" title="最小生成树的定义"></a><strong>最小生成树的定义</strong></h3><p>给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那颗生成树称为最小生成树  </p><h3 id="构造最小生成树"><a href="#构造最小生成树" class="headerlink" title="构造最小生成树"></a><strong>构造最小生成树</strong></h3><blockquote><p>MST性质（一种贪心算法）：设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u，v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一棵包含边(u，v)的最小生成树。<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/43.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/44.jpg">  </p></blockquote><h3 id="构造最小生成树方法1-Prime算法"><a href="#构造最小生成树方法1-Prime算法" class="headerlink" title="构造最小生成树方法1-Prime算法"></a><strong>构造最小生成树方法1-Prime算法</strong></h3><p>算法思想：  不断扩大最小生成树的范围<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/45.jpg">  </p><h3 id="构造最小生成树方法2-Kruskal算法"><a href="#构造最小生成树方法2-Kruskal算法" class="headerlink" title="构造最小生成树方法2-Kruskal算法"></a><strong>构造最小生成树方法2-Kruskal算法</strong></h3><p>算法思想：直接选当前最小的边<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/46.jpg">  </p><p>注：最小生成树可能不唯一  </p><h3 id="两种算法的比较"><a href="#两种算法的比较" class="headerlink" title="两种算法的比较"></a><strong>两种算法的比较</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/47.jpg">  </p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a><strong>最短路径</strong></h2><p>顶点：表示地点<br>弧：表示两地连通<br>弧上的权值：表示距离或花费等等<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/48.jpg">  </p><h3 id="第一类问题：两点间的最短路径"><a href="#第一类问题：两点间的最短路径" class="headerlink" title="第一类问题：两点间的最短路径"></a><strong>第一类问题：两点间的最短路径</strong></h3><p>所有顶点间的最短路径-弗洛伊德算法<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/49.jpg">  </p><h3 id="第二类问题：某源点到其他各点最短路径"><a href="#第二类问题：某源点到其他各点最短路径" class="headerlink" title="第二类问题：某源点到其他各点最短路径"></a><strong>第二类问题：某源点到其他各点最短路径</strong></h3><p>单源最短路径-迪杰斯特拉算法<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/50.jpg">  </p><h3 id="单源最短路径-迪杰斯特拉算法"><a href="#单源最短路径-迪杰斯特拉算法" class="headerlink" title="单源最短路径-迪杰斯特拉算法"></a><strong>单源最短路径-迪杰斯特拉算法</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/51.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/52.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/53.jpg">  </p><h3 id="所有顶点间的最短路径-弗洛伊德算法"><a href="#所有顶点间的最短路径-弗洛伊德算法" class="headerlink" title="所有顶点间的最短路径-弗洛伊德算法"></a><strong>所有顶点间的最短路径-弗洛伊德算法</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/54.jpg">  </p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><strong>拓扑排序</strong></h2><p>有向无环图：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/55.jpg"><br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/56.jpg">  </p><h3 id="拓扑排序例子"><a href="#拓扑排序例子" class="headerlink" title="拓扑排序例子"></a><strong>拓扑排序例子</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/57.jpg"><br>AOV网的特点：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/58.jpg">  </p><h3 id="拓扑排序定义"><a href="#拓扑排序定义" class="headerlink" title="拓扑排序定义"></a><strong>拓扑排序定义</strong></h3><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/59.jpg">  </p><h3 id="拓扑排序方法"><a href="#拓扑排序方法" class="headerlink" title="拓扑排序方法"></a><strong>拓扑排序方法</strong></h3><p>简言之：一直选择没有前驱的点<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/60.jpg">  </p><p>检测AOV网中是否存在环的方法<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/61.jpg">  </p><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a><strong>关键路径</strong></h2><p>例：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/62.jpg"><br>把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续的时间<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/63.jpg">  </p><p>关键路径：路径长度最长的路径<br>路径长度：路径上各活动持续时间之和<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/64.jpg">  </p><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/65.jpg">  </p><p><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/66.jpg">  </p><p>求关键路径步骤：<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/67.jpg"><br>时间余量为0即为关键活动<br><img src="/2022/11/17/shu-ju-jie-gou-zhi-tu/68.jpg">  </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之数和二叉树</title>
      <link href="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/"/>
      <url>/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之树和二叉树"><a href="#数据结构之树和二叉树" class="headerlink" title="数据结构之树和二叉树"></a>数据结构之树和二叉树</h1><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a><strong>树和二叉树</strong></h2><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/1.jpg">  </p><blockquote><p>树形结构<br>非线性结构：结点之间有分支、具有层次关系  </p></blockquote><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a><strong>树的定义</strong></h2><p>是n个结点的有限集<br>若n=0，称为空数，若n&gt;0，则它满足以下两个条件： </p><p>  (1)有且仅有一个特定的称为根的结点；  </p><p>  (2)其余节点可分为m(m&gt;=0)个互不相交的有限集，其中每一个集合本身又是一棵树，称为根的子树  （递归的定义）</p><h2 id="数的基本术语"><a href="#数的基本术语" class="headerlink" title="数的基本术语"></a><strong>数的基本术语</strong></h2><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/1.jpg">  </p><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/2.jpg">  </p><p>有序数：树中结点的各子树从左至右有次序(最左边的为第一个孩子)<br>无序数：树中结点的各子树无次序  </p><p>森林：是m（m&gt;=0）棵互不相交的树的集合，把根结点删除数就变成了森林，一棵树可以看成是一个特殊的森林。 </p><h2 id="树结构和线性结构的比较"><a href="#树结构和线性结构的比较" class="headerlink" title="树结构和线性结构的比较"></a><strong>树结构和线性结构的比较</strong></h2><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/3.jpg">  </p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a><strong>二叉树的定义</strong></h2><p>二叉树是n个结点的有限集，它或者是空集、或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成  </p><blockquote><p>特点<br>每个结点最多有俩孩子（不存在度大于2的结点）<br>有左右之分，次序不能颠倒<br>二叉树可以是空集合，根可以有空的左子树或空的右子树  </p></blockquote><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/4.jpg">  </p><blockquote><p>具有三个结点的二叉树有几种不同形态、普通树？<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/5.jpg">  </p></blockquote><blockquote><p>二叉树的五种基本形态<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/6.jpg">  </p></blockquote><h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a><strong>案例引入</strong></h2><p><strong>案例一</strong> 数据压缩问题<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/7.jpg">  </p><p><strong>案例二</strong> 利用二叉树求解表达式的值<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/8.jpg">  </p><h2 id="树和二叉树的抽象数据类型定义"><a href="#树和二叉树的抽象数据类型定义" class="headerlink" title="树和二叉树的抽象数据类型定义"></a><strong>树和二叉树的抽象数据类型定义</strong></h2><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT BinaryTree{   数据对象D：具有相同特性的数据元素的集合   数据关系R：若D为空集，则R为空集             若D非空，则R={H}；H是如下的二元关系               1.root唯一             2.Dj并Dk为空集             3...     基本操作P：}ADT BinaryTree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>基本操作P：<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/9.jpg"></p></blockquote><h2 id="二叉树的性质和存储结构"><a href="#二叉树的性质和存储结构" class="headerlink" title="二叉树的性质和存储结构"></a><strong>二叉树的性质和存储结构</strong></h2><blockquote><p>性质1：在二叉树的第i层上至多有2的i-1次方个结点，至少有1个结点  </p></blockquote><blockquote><p>性质2；深度为k的二叉树至多有2的k次方-1个结点，至少有k个结点  </p></blockquote><blockquote><p>性质3：对任何一棵二叉树T，如果其叶子数为n0，度为2的结点数为n2，则n0=n2+1  </p></blockquote><h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a><strong>树和森林</strong></h2><blockquote><p>森林：是m棵互不相交的树的集合<br>树和森林可以相互转化  </p></blockquote><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a><strong>树的存储结构</strong></h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a><strong>双亲表示法</strong></h3><blockquote><p>实现：定义结构数组，存放树的结点，每个结点两个域：<br>1.数据域：存放结点本身信息<br>2.双亲域：指示本结点的双亲结点在数组中的位置<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/10.jpg" alt="找双亲容易，找孩子难">  </p></blockquote><p>类型描述：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct PTNode{   TElemType data;  int parent;//双亲位置域}PTNode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>树结构：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAX_TREE_SIZE 100typedef struct PTNode{   PTNode nodes[MAX_TREE_SIZE];  int r,n;//根结点的位置和结点个数}PTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="孩子链表"><a href="#孩子链表" class="headerlink" title="孩子链表"></a><strong>孩子链表</strong></h3><p><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/11.jpg" alt="找孩子双亲容易，找双亲难"><br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/12.jpg"></p><p>孩子结点结构：<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/13.jpg"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct CTNode{   int child;  struct CTNode *next;}*ChildPtr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>双亲结点结构：<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/14.jpg"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct{   TElemType data;  ChildPtr firstchild;//孩子链表头指针}CTBox;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>树结构：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAX_TREE_SIZE 100typedef struct {   }CTBox nodes[MAX_TREE_SIZE];  int r,n;//根结点的位置和结点个数}CTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>带双亲的孩子链表：两种模式的混合<br><img src="/2022/11/06/shu-ju-jie-gou-zhi-shu-he-er-cha-shu/15.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之数组和广义表</title>
      <link href="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/"/>
      <url>/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之数组和广义表"><a href="#数据结构之数组和广义表" class="headerlink" title="数据结构之数组和广义表"></a>数据结构之数组和广义表</h1><h2 id="数组的定义及特点"><a href="#数组的定义及特点" class="headerlink" title="数组的定义及特点"></a>数组的定义及特点</h2><blockquote><p>按一定格式排列起来的<br>具有相同类型的数据元素的集合  </p></blockquote><blockquote><p>数组特点：结构固定：定义后，维数和维界不再改变  </p></blockquote><blockquote><p>数组基本操作：除了结构的初始化和销毁之外，只有取元素和修改元素值的操作  </p></blockquote><h2 id="数组的抽象数据类型定义"><a href="#数组的抽象数据类型定义" class="headerlink" title="数组的抽象数据类型定义"></a>数组的抽象数据类型定义</h2><p>n维数组的抽象数据类型  </p><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT Array{   数据对象：   ji=0,bi-1, i=1,2,3...n   D={aj1j2j3..jn|aj1j2j3..jn属于Elemset}     数据关系   基本操作：   构造数组   销毁数组   取数组元素值   给数组元素赋值   ...}ADT Array<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h2><blockquote><p>一维数组<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/1.jpg">  </p></blockquote><blockquote><p>二维数组<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/2.jpg"><br>存储单元是一维结构，而数组是个多维结构，则用一组连续存储单元存放数组的元素就有次序问题<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/3.jpg"><br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/4.jpg"> </p></blockquote><blockquote><p>三维数组<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/5.jpg"></p></blockquote><blockquote><p>n维数组<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/20.jpg"></p></blockquote><h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><p>矩阵：一个由m*n个元素排成的m行n列的表<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/6.jpg"><br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/7.jpg">  </p><p>1.对称矩阵：<br>可以只存储上半部分或下半部分，对于一个n*n矩阵，只需要存储n(n+1)/2个元素空间  </p><blockquote><p><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/8.jpg">  </p></blockquote><p>2.三角矩阵  </p><blockquote><p><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/9.jpg">  </p></blockquote><p>3.对角矩阵  </p><blockquote><p><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/10.jpg"><br>以对角线的顺序存储<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/11.jpg">  </p></blockquote><h2 id="稀疏矩阵存储"><a href="#稀疏矩阵存储" class="headerlink" title="稀疏矩阵存储"></a>稀疏矩阵存储</h2><p><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/12.jpg"><br>顺序存储结构：三元组法<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/13.jpg"><br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/14.jpg"><br>链式存储结构：十字链表<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/15.jpg"><br>例如：<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/16.jpg">  </p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>线性表的推广，其中每一个元素可以是原子或者一个广义表<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/17.jpg"><br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/18.jpg">  </p><h2 id="广义表的性质"><a href="#广义表的性质" class="headerlink" title="广义表的性质"></a>广义表的性质</h2><p>1.广义表中的数据元素有相对次序，一个直接前驱和一个直接后继<br>2.广义表的长度定义为最外层所包含元素的个数，如：C=(a,(b,c))是长度为2的广义表<br>3.广义表的深度定义为该广义表展开后所含括号的重数<br>4.广义表可以为其他广义表共享；如：广义表B就共享表A，在B中不必列出A的值，而是通过名称来引用，B=(A)<br>5.广义表可以是一个递归的表。如：F=(a,F)=(a,(a,(a,…)))<br>注意：递归表的深度是无穷值，长度是有限值<br>6.广义表是对层次结构，广义表的元素可以是氮元素，也可以是子表，而子表的元素还可以是子表<br><img src="/2022/10/26/shu-ju-jie-gou-zhi-shu-zu-he-guang-yi-biao/19.jpg">  </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 广义表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之串</title>
      <link href="/2022/10/14/shu-ju-jie-gou-zhi-chuan/"/>
      <url>/2022/10/14/shu-ju-jie-gou-zhi-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之串"><a href="#数据结构之串" class="headerlink" title="数据结构之串"></a>数据结构之串</h1><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a><strong>串的定义</strong></h2><p>串：内容受限的线性表  </p><blockquote><p>由零个或多个任意字符组成的有限序列<br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/1.jpg">  </p></blockquote><blockquote><p>子串：一个串中任意个连续字符组成的子序列<br>主串：包含子串的串相应地称为主串<br>字符位置：字符在序列中的序号<br>子串位置：子串第一个字符<br>空格串：由一个或多个空格组成的串，与空串不同<br>串相等：当且仅当两个串的长度相等并且各个对应的位置上字符都相等（所有空串都相等）</p></blockquote><h2 id="串的类型定义"><a href="#串的类型定义" class="headerlink" title="串的类型定义"></a><strong>串的类型定义</strong></h2><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT String{   数据对象：D={ai|ai属于Characterset，(i=1,2,3...n，n&gt;=0)}     数据关系：R={&lt;ai-1，ai&gt;|ai-1，ai属于D，(i=1,2,3...n)}   基本操作：   串赋值   穿比较   求串长   串连结   ...}ADT String<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>串中元素逻辑关系与线性表相同<br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/2.jpg">  </p></blockquote><h3 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a><strong>串的顺序存储结构</strong></h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXLEN 255   typedef struct {    char ch[MAXLEN+1];//存储串的一维数组（0号位一般不用）    int length; //串的当前长度}SString;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="串的链式存储结构-块链结构"><a href="#串的链式存储结构-块链结构" class="headerlink" title="串的链式存储结构-块链结构"></a><strong>串的链式存储结构-块链结构</strong></h3><p><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/3.jpg"> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define CHUNKSIZE 80  //块的大小可由用户定义 typedef struct Chunk{    char ch[CHUNKSIZE];    struct Chunk *next;}Chunk;typedef struct {    Chunk *head,*tail;//串的头指针与尾指针    int curlen;//串的当前长度}LString;  //字符串的块链结构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a><strong>串的模式匹配算法</strong></h2><p>算法目的：确定主串中所包含子串（模式串）第一次出现的位置  </p><blockquote><p>算法种类：BF算法、KMP算法  </p></blockquote><h3 id="串的BF算法"><a href="#串的BF算法" class="headerlink" title="串的BF算法"></a><strong>串的BF算法</strong></h3><p><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/4.jpg"> </p><blockquote><p>i-j+1是原始位置，再+1是原始位置的下一位置   </p></blockquote><p><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/5.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/6.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/7.jpg"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">//从主串的头部开始找int Index_BF(SString S,SString T){    int i=1,j=1;    while(i&lt;=S.length&amp;&amp;j&lt;=T.length){        if(S.ch[i]==T.ch[j]){++i;++j;}//主串和子串依次匹配下一个字符          else {i=i-j+2;j=1;}//主串、子串指针回溯重新开始下一次匹配          if(j&gt;T.length)return i-T.length;//返回匹配的第一个字符的下标          else return 0；//匹配不成功    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">//从主串的中间pos处开始找int Index_BF(SString S,SString T，int pos){    int i=pos,j=1;    while(i&lt;=S.length&amp;&amp;j&lt;=T.length){        if(S.ch[i]==T.ch[j]){++i;++j;}//主串和子串依次匹配下一个字符          else {i=i-j+2;j=1;}//主串、子串指针回溯重新开始下一次匹配          if(j&gt;T.length)return i-T.length;//返回匹配的第一个字符的下标          else return 0；//匹配不成功    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="串的KMP算法"><a href="#串的KMP算法" class="headerlink" title="串的KMP算法"></a><strong>串的KMP算法</strong></h3><p><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/8.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/9.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/10.jpg"></p><blockquote><p>计算next[j]=k；k-1=5（如上图，则k=6）</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">void get_next(SString T,int &amp;next[]){     i=1;next[1]=0;j=0;     while(i&lt;T.length){        if(j==0||T.ch[i]==T.ch[j]){            ++i;++j;            next[i]=j;        }        else j=next[j];     }}//从主串的中间pos处开始找int Index_KMP(SString S,SString T，int pos){    int i=pos,j=1;    while(i&lt;=S.length&amp;&amp;j&lt;=T.length){        if(j==0||S.ch[i]==T.ch[j]){++i;++j;}//主串和子串依次匹配下一个字符          else {            j=next[j]; //i不变，j后退         }        if(j&gt;T.length)return i-T.length;//返回匹配的第一个字符的下标          else return 0；//匹配不成功    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>主串S的指针i不必回溯，O(m+n)</p></blockquote><p>next数组细说<br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/11.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/12.jpg"><br><img src="/2022/10/14/shu-ju-jie-gou-zhi-chuan/13.jpg"></p><blockquote><p>看门牌，比如：如果要求7的next，看6的next值，是4，所以看第4，如果4和6相等，那么7就为4+1=5，但是并不等，于是看2,2和6也不等，就看1，1和6也不等，于是7就为1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之栈和队列</title>
      <link href="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/"/>
      <url>/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之栈和队列"><a href="#数据结构之栈和队列" class="headerlink" title="数据结构之栈和队列"></a>数据结构之栈和队列</h1><h2 id="栈和队列的定义"><a href="#栈和队列的定义" class="headerlink" title="栈和队列的定义"></a><strong>栈和队列的定义</strong></h2><p>栈和队列是两种常用的数据结构，是限定插入和删除只能在表的“端点”进行的线性表  </p><blockquote><p><strong>栈</strong>的操作具有后进先出的固有特性<br>如“数值转换”  “表达式求值”  “括号匹配检验”  “八皇后问题”  “函数调用”  “迷宫求解” 等等  </p></blockquote><blockquote><p><strong>队列</strong>的操作具有先进先出的特性<br>使得队列成为程序设计中解决类似排队问题的工具  </p></blockquote><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/1.jpg">  </p><h2 id="栈的定义和特点"><a href="#栈的定义和特点" class="headerlink" title="栈的定义和特点"></a><strong>栈的定义和特点</strong></h2><p>是一个特殊的线性表，限定仅在一端（通常是表尾）进行插入和删除操作的线性表  </p><p>又称为后进先出，简称LIFO结构  </p><blockquote><p>表尾（即an端）称为栈顶Top；表头（即a1端）称为栈底Base<br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/2.jpg"><br>插入元素到栈顶（表尾）的操作称为入栈；<br>从栈顶删除最后一个元素的操作称为出栈<br>压入=<code>PUSH(x)</code>  弹出=<code>POP(y)</code></p></blockquote><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/3.jpg">  </p><h2 id="队列的定义和特点"><a href="#队列的定义和特点" class="headerlink" title="队列的定义和特点"></a><strong>队列的定义和特点</strong></h2><p>在表一端插入（表尾），在另一端（表头）删除<br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/4.jpg">  </p><h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a><strong>案例引入</strong></h2><h3 id="案例1-进制转换"><a href="#案例1-进制转换" class="headerlink" title="案例1 进制转换"></a><strong>案例1</strong> 进制转换</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/5.jpg">  </p><h3 id="案例2-括号匹配的检验"><a href="#案例2-括号匹配的检验" class="headerlink" title="案例2 括号匹配的检验"></a><strong>案例2</strong> 括号匹配的检验</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/6.jpg">  </p><h3 id="案例3-表达式求值"><a href="#案例3-表达式求值" class="headerlink" title="案例3 表达式求值"></a><strong>案例3</strong> 表达式求值</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/7.jpg"><br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/8.jpg">  </p><h3 id="案例4-舞伴问题"><a href="#案例4-舞伴问题" class="headerlink" title="案例4 舞伴问题"></a><strong>案例4</strong> 舞伴问题</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/9.jpg">  </p><h2 id="栈的抽象数据类型的类型定义"><a href="#栈的抽象数据类型的类型定义" class="headerlink" title="栈的抽象数据类型的类型定义"></a><strong>栈的抽象数据类型的类型定义</strong></h2><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT Stack {    数据对象：       D={ai|ai属于ElemSet,i=1,2,3,...n,n&gt;=0}    数据关系：       R1={&lt;ai-1,ai&gt;|ai-1，ai属于D，i=2，...,n}         约定an端为栈顶，a1端为栈底。      基本操作：初始化、进栈、出栈、取栈顶元素等}}ADT Stack <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>InitStack(&amp;S)：初始化操作，构造一个空栈S  </li><li>DestoryStack(&amp;S)：销毁栈操作   </li><li>StackEmpty(S)：判断S是否为空栈</li><li>StackLength(L):返回S的元素个数</li><li>GetTop(S,&amp;e):取栈顶元素</li><li>ClearStack(&amp;S):栈置空操作</li><li>Puah(&amp;S,e):插入元素e为新的栈顶元素</li><li>Pop(&amp;S,&amp;e):删除S的栈顶元素，并用e返回其值</li></ul><h2 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a><strong>顺序栈的表示和实现</strong></h2><p>存储方式：与一般线性表的顺序存储结构完全相同<br>利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，栈底一般在低地址端  </p><ul><li>top指针：指示栈顶元素在顺序栈中的位置  </li><li>base指针，指示栈底元素在顺序栈中的位置  <blockquote><p>但是，为了方便操作，通常top指示真正的栈顶元素之上的下表地址<br>另外，用stacksize表示栈可以使用的最大容量<br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/10.jpg"></p></blockquote></li></ul><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/11.jpg"></p><p>使用数组作为顺序栈存储方式的特点：  </p><blockquote><p>简单方便单易产生溢出（数组大小固定）  </p></blockquote><p>上溢：栈已经满，又要压入元素<br>下溢：栈已经空，还要弹出元素  </p><blockquote><p>上溢是一种错误，而下溢一般认为是一种结束条件，即问题处理结束  </p></blockquote><h3 id="顺序栈的数据类型定义"><a href="#顺序栈的数据类型定义" class="headerlink" title="顺序栈的数据类型定义"></a><strong>顺序栈的数据类型定义</strong></h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 100typedef struct {    SElemType *base;//栈底指针    SElemType *top;//栈顶指针    int stacksize; //栈可用最大容量}SqStack;```  ![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/12.jpg)  ### **算法1** 顺序栈的初始化 ```CStatus InitStack(SqStack &amp;S){  S.base=new SElemType[MAXSIZE];//或  //S.base=(SElemType*)malloc(MAXSIZE*sizeof(SElemType));    if(!S.base)exit (OVERFLOW);  S.top=S.base;  S.stacksize=MAXSIZE;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-顺序栈判断是否是空"><a href="#算法2-顺序栈判断是否是空" class="headerlink" title="算法2 顺序栈判断是否是空"></a><strong>算法2</strong> 顺序栈判断是否是空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status StackEmpty(SqStack S){  if(S.top==S.base)return TRUE;  else return FALSE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-求顺序栈长度"><a href="#算法3-求顺序栈长度" class="headerlink" title="算法3 求顺序栈长度"></a><strong>算法3</strong> 求顺序栈长度</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status StackLength(SqStack S){  return S.top-S.base；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法4-清空顺序栈"><a href="#算法4-清空顺序栈" class="headerlink" title="算法4 清空顺序栈"></a><strong>算法4</strong> 清空顺序栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ClearStack(SqStack S){   if(S.base)S.top=S.base;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-销毁顺序栈"><a href="#算法5-销毁顺序栈" class="headerlink" title="算法5 销毁顺序栈"></a><strong>算法5</strong> 销毁顺序栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DestroyStack(SqStack &amp;S){   if(S.base){    delete S.base;    S.stacksize=0;    S.base= S.top =NULL;   }   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-顺序栈的入栈"><a href="#算法6-顺序栈的入栈" class="headerlink" title="算法6 顺序栈的入栈"></a><strong>算法6</strong> 顺序栈的入栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Push(SqStack &amp;S,SElemType e){   if(S.top-S.base==S.stacksize)//栈满       return ERROR;   *S.top++=e;//*S.top=e;S.top++;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-顺序栈的出栈"><a href="#算法7-顺序栈的出栈" class="headerlink" title="算法7 顺序栈的出栈"></a><strong>算法7</strong> 顺序栈的出栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Pop(SqStack &amp;S,SElemType &amp;e){   if(S.top==S.base)//等价于if(StackEmpty(S))   return ERROR;    e=*--S.top;//--S.top;e=*S.top;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a><strong>链栈的表示和实现</strong></h2><p>链栈是运算受限的单链表，只能在链表头部进行操作 </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct StackNode{    SElemType data；    struct StackNode *next;}StackNode,*LinkStack;  LinkStack S;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/13.jpg">  </p><h3 id="算法1-链栈的初始化"><a href="#算法1-链栈的初始化" class="headerlink" title="算法1 链栈的初始化"></a><strong>算法1</strong> 链栈的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void InitStack(LinkStack &amp;S){    //构造一个空栈，栈顶指针置为空    S=NULL;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-链栈的初始化"><a href="#算法2-链栈的初始化" class="headerlink" title="算法2 链栈的初始化"></a><strong>算法2</strong> 链栈的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void InitStack(LinkStack &amp;S){    //构造一个空栈，栈顶指针置为空    S=NULL;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-判断链栈是否为空"><a href="#算法3-判断链栈是否为空" class="headerlink" title="算法3 判断链栈是否为空"></a><strong>算法3</strong> 判断链栈是否为空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void StackEmpty(LinkStack S){    if(S==NULL)return TRUE;    else return FALSE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法4-链栈的入栈"><a href="#算法4-链栈的入栈" class="headerlink" title="算法4 链栈的入栈"></a><strong>算法4</strong> 链栈的入栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Push(LinkStack &amp;S,SElemType e){    p=new StackNode;    p-&gt;data=e;    p-&gt;next=S;    S=p;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-链栈的出栈"><a href="#算法5-链栈的出栈" class="headerlink" title="算法5 链栈的出栈"></a><strong>算法5</strong> 链栈的出栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Pop(LinkStack &amp;S,SElemType &amp;e){    if(S==NULL)return ERROR;    e=S-&gt;data;    p=S;    S=S-&gt;next;    delete p;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-取栈顶元素"><a href="#算法6-取栈顶元素" class="headerlink" title="算法6 取栈顶元素"></a><strong>算法6</strong> 取栈顶元素</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">SElemType GetTop(LinkStack S){    if(S!=NULL)    return S-&gt;data;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈和递归"><a href="#栈和递归" class="headerlink" title="栈和递归"></a><strong>栈和递归</strong></h2><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/14.jpg"></p><blockquote><p>注：栈的应用与递归详见数据结构书中P48页始  </p></blockquote><h2 id="队列的表示和操作实现"><a href="#队列的表示和操作实现" class="headerlink" title="队列的表示和操作实现"></a><strong>队列的表示和操作实现</strong></h2><p>是仅在表尾进行插入操作，在表头进行删除操作的线性表<br>表尾即an端，称为队尾，表头为a1端，称为对头。</p><blockquote><p>先进先出  </p></blockquote><p>插入元素称为入队，删除元素称为出队<br>队列的存储结构为链队或顺序队。  </p><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/15.jpg">  </p><h3 id="队列的抽象数据类型定义"><a href="#队列的抽象数据类型定义" class="headerlink" title="队列的抽象数据类型定义"></a><strong>队列的抽象数据类型定义</strong></h3><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT Queue {    数据对象：       D={ai|ai属于ElemSet,i=1,2,3,...n,n&gt;=0}    数据关系：       R={&lt;ai-1,ai&gt;|ai-1，ai属于D，i=2，...,n}         约定an端为栈顶，a1端为栈底。      基本操作：初始化等}}ADT Queue <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="队列的顺序表示"><a href="#队列的顺序表示" class="headerlink" title="队列的顺序表示"></a><strong>队列的顺序表示</strong></h2> <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXQSIZE 100typedef struct{  QElemType *base;//初始化的动态分配存储空间  int front; //头指针(队头元素下标)  int rear; //尾指针(队尾元素下标)}SqQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/16.jpg">  </p><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/17.jpg"></p><blockquote><p>解决假上溢的方法：引入循环队列  </p></blockquote><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/18.jpg"></p><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/19.jpg">  </p><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/20.jpg">  </p><h2 id="循环队列的类型定义"><a href="#循环队列的类型定义" class="headerlink" title="循环队列的类型定义"></a><strong>循环队列的类型定义</strong></h2><h3 id="算法1-循环队列的类型定义"><a href="#算法1-循环队列的类型定义" class="headerlink" title="算法1 循环队列的类型定义"></a><strong>算法1</strong> 循环队列的类型定义</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXQSIZE 100typedef struct{  QElemType *base;//初始化的动态分配存储空间  int front; //头指针(队头元素下标)  int rear; //尾指针(队尾元素下标)}SqQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-循环队列的初始化"><a href="#算法2-循环队列的初始化" class="headerlink" title="算法2 循环队列的初始化"></a><strong>算法2</strong> 循环队列的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitQueue(SqQueue &amp;Q){  Q.base = new QElemType[MAXQSIZE] //分配数组空间   if(!Q.base) exit (OVERFLOW);  Q.front=Q.rear=0; //头指针尾指针置为0，队列为空  return OK; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-循环队列的长度"><a href="#算法3-循环队列的长度" class="headerlink" title="算法3 循环队列的长度"></a><strong>算法3</strong> 循环队列的长度</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int QueueLength(SqQueue Q){  return((Q.rear-Q.front+MAXQSIZE)%MAXQSIZE);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法4-循环队列的入队"><a href="#算法4-循环队列的入队" class="headerlink" title="算法4 循环队列的入队"></a><strong>算法4</strong> 循环队列的入队</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status EnQueueLength(SqQueue &amp;Q，QElemType e){  if((Q.rear+1)%MAXQSIZE==Q.front)return ERROR;  Q.base[Q.rear]=e;  Q.rear=(Q.rear+1)%MAXQSIZE;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-循环队列的出队"><a href="#算法5-循环队列的出队" class="headerlink" title="算法5 循环队列的出队"></a><strong>算法5</strong> 循环队列的出队</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DeQueueLength(SqQueue &amp;Q，QElemType &amp;e){  if(Q.front==Q.rear)return ERROR;  e=Q.base[Q.front];  Q.front=(Q.front+1)%MAXQSIZE;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-取队头元素"><a href="#算法6-取队头元素" class="headerlink" title="算法6 取队头元素"></a><strong>算法6</strong> 取队头元素</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">SElemType GetHead(SqQueue Q){  if(Q.front!=Q.rear)return Q.base[Q.front];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="队列的链式表示和实现"><a href="#队列的链式表示和实现" class="headerlink" title="队列的链式表示和实现"></a><strong>队列的链式表示和实现</strong></h2><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/21.jpg">  </p><h3 id="算法1-链队列的类型定义"><a href="#算法1-链队列的类型定义" class="headerlink" title="算法1 链队列的类型定义"></a><strong>算法1</strong> 链队列的类型定义</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXQSIZE 100typedef struct Qnode{  QElemType data;  struct Qnode *next;}QNode,*QuenePtr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {  QuenePtr front;//队头指针  QuenePtr rear;//队尾指针}LinkQuene;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/22.jpg">  </p><h3 id="算法2-链队列的初始化"><a href="#算法2-链队列的初始化" class="headerlink" title="算法2 链队列的初始化"></a><strong>算法2</strong> 链队列的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitQueue(LinkQueue &amp;Q){  Q.front=Q.rear=(QueuePtr)malloc(sizeof(QNode));  if(!Q.front)exit(OVERFLOW);  Q.front-&gt;next=NULL;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-链队列的销毁"><a href="#算法3-链队列的销毁" class="headerlink" title="算法3 链队列的销毁"></a><strong>算法3</strong> 链队列的销毁</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DestroyQueue(LinkQueue &amp;Q){  while(Q.front){    p=Q.front-&gt;next;    free(Q.front);    Q.front=p;}  return OK;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法4-链队列的销毁"><a href="#算法4-链队列的销毁" class="headerlink" title="算法4 链队列的销毁"></a><strong>算法4</strong> 链队列的销毁</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DestroyQueue(LinkQueue &amp;Q){  while(Q.front){    p=Q.front-&gt;next;    free(Q.front);    Q.front=p;}  return OK;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-链队列的元素入队"><a href="#算法5-链队列的元素入队" class="headerlink" title="算法5 链队列的元素入队"></a><strong>算法5</strong> 链队列的元素入队</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status EnQueue(LinkQueue &amp;Q,QElemType e){  p=(QueuePtr)malloc(sizeof(QNode));  if(!p)exit (OVERFLOW);  p-&gt;data=e;p-&gt;next=NULL;  Q.rear-&gt;next=p;  Q.rear=p;  return OK;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-链队列的元素出队"><a href="#算法6-链队列的元素出队" class="headerlink" title="算法6 链队列的元素出队"></a><strong>算法6</strong> 链队列的元素出队</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DeQueue(LinkQueue &amp;Q,QElemType &amp;e){  if(Q.front==Q.rear)return ERROR;  p=Q.front-&gt;next;  e=p-&gt;data;  Q.front-&gt;next=p-&gt;next;  if(Q.rear==p)Q.rear=Q.front;  delete p;  return OK;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-链队列的队头元素"><a href="#算法7-链队列的队头元素" class="headerlink" title="算法7 链队列的队头元素"></a><strong>算法7</strong> 链队列的队头元素</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status GetHead(LinkQueue Q,QElemType &amp;e){   if(Q.front==Q.rear)return ERROR;   e=Q.front-&gt;next-&gt;data;   return OK;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之线性表</title>
      <link href="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/"/>
      <url>/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之线性表"><a href="#数据结构之线性表" class="headerlink" title="数据结构之线性表"></a>数据结构之线性表</h1><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a><strong>知识回顾</strong></h2><p>数据结构  </p><ul><li>逻辑结构  <ul><li>线性结构  <ul><li>线性表  </li><li>栈（特殊线性表） </li><li>队列（特殊线性表）</li><li>字符串、数组、广义表</li></ul></li><li>非线性结构  <ul><li>树形结构  </li><li>图形结构</li></ul></li></ul></li><li>数据的存储结构  <ul><li>顺序存储  </li><li>链式存储</li></ul></li><li>数据的运算：检索、排序、插入…</li></ul><h2 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a><strong>线性表的定义和特点</strong></h2><p>线性表是具有相同特性的数据元素的一个有限序列  </p><blockquote><p>(a1,a2,…,ai-1,ai,ai+1,…an)  </p><p>a1:线性起点<br>ai-1:ai的直接前趋<br>ai+1:ai的直接后继<br>an:线性终点<br>n=0时称为空表（n是表长） </p></blockquote><p>同一线性表中的元素必定具有相同特性，数据元素之间的关系是线性关系  </p><h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a><strong>案例引入</strong></h2><p>案例一：一元多项式的运算：实现两个多项式的加、减、乘运算  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/1.jpg" alt="案例一">  </p><p>案例二：稀疏多项式的运算  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/2.jpg"><br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/3.jpg" alt="案例二">  </p><blockquote><p>Q:那么数组C多大合适呢？  </p><p>顺序存储结构存在的问题  </p><ul><li>存储空间分配不灵活  </li><li>运算的空间复杂度高</li></ul></blockquote><p>—&gt;选择链式存储结构<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/4.jpg" alt="链式存储方法">   </p><p>案例三：图书信息管理系统  </p><ul><li>将图书表抽象为线性表  </li><li>表中每本书抽象线性表中数据元素</li></ul><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/5.jpg" alt="两种方式">  </p><p>线性表中数据元素可以是<em>简单类型</em>，也可以是<em>复杂类型</em>  </p><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a><strong>线性表的类型定义</strong></h2><blockquote><p>抽象数据类型（ADT）</p><ul><li>数据对象</li><li>数据对象关系集合  </li><li>作用在数据对象上的基本操作</li></ul></blockquote><p>抽象数据类型线性表的定义如下：  </p><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT List{   数据对象：D={ai|ai属于Elemset，(i=1,2,3...n，n&gt;=0)}     数据关系：R={&lt;ai-1，ai&gt;|ai-1，ai属于D，(i=1,2,3...n)}   基本操作：   IntList(&amp;L);   DestoryList(&amp;L);   ListInsert(&amp;L,i,e);   ListDelete(&amp;L,i,&amp;e);   ...}ADT List<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>InitList(&amp;L):构造一个空的线性表L</li><li>DestoryList(&amp;L)：线性表已存在的条件下，销毁线性表  </li><li>ClwanList(&amp;L)：线性表已存在的条件下，清除线性表元素，置L为空表  </li><li>ListEmpty(L)：线性表已存在的条件下，若L为空表，返回TRUE，否则返回FALSE</li><li>ListLength(L):线性表已存在的条件下，返回L中元素个数</li><li>GetElem(L,I,&amp;e):线性表已存在的条件下，1&lt;=i&lt;=ListLength(L),用e返回线性表中第i个元素的值</li><li>LocateElem(L,e,compare()):线性表已存在的条件下，compare()是数据元素判定函数，返回L中第一个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0</li><li>PriorElem(L,cur_e,&amp;pre_e):线性表已存在的条件下，若cur_e是L的数据元素，且不是第一个，则用pre_e返回他的前趋，否则操作失败，pre_e无意义</li><li>NextElem(L,cur_e,&amp;next_e):线性表已存在的条件下，若cur_e是L的数据元素，且不是最后一个，则用next_e返回他的后继，否则操作失败，next_e无意义</li><li>ListInsert(&amp;L,i,e):线性表已存在的条件下，1&lt;=i&lt;=ListLength(L)+1，在L的第i个位置之前插入新的元素e，L的长度加1</li><li>ListDelete(&amp;L,i,&amp;e)：线性表已存在的条件下，1&lt;=i&lt;=ListLength(L)，删除L的第i个元素，并用e返回其值，L的长度-1 </li><li>ListTraverse(&amp;L,visited()):线性表已存在的条件下，依次对线性表中的每个元素调用遍历visited()</li></ul><p>以上提及的运算是逻辑结构上定义的运算，只要给出这些运算功能是“做什么”，至于“如何做”，只有待确定了存储结构之后才考虑</p><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a><strong>线性表的顺序表示和实现</strong></h2><p>顺序存储：把逻辑上相邻的数据元素储存在物理上相邻的存储单元中的存储结构  </p><blockquote><p>线性表中的第一个数据元素a1的存储位置，称作线性表的<strong>起始位置</strong>或<strong>基地址</strong>  </p></blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/6.jpg" alt="两种方式">   </p><p>假设线性表的每个元素需要占用k个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足:LOC(ai+1)=LOC(ai)+k ；同时LOC(ai)=LOC(ai)+(i-1)*k  </p><blockquote><p>顺序表元素-&gt;数组元素<br>用一维数组表示顺序表  </p></blockquote><p>线性表长度可变但数组长度不可动态定义<br>-&gt;用以变量表示顺序表的长度属性  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define LIST INIT SIZE 100 //线性表存储空间的初始分配量  typedef struct {    ElemType elem[LIST_INIT_SIZE];    int length; //当前长度}SqList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多项式的顺序结构储存结构类型定义</strong>  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/7.jpg">  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 1000 //多项式可能达到的最大长度typedef struct {  //多项式非零项的定义  float p;  //系数  int e;  //指数}Polynomial;   typedef struct {    Polynomial *elem;  //储存空间的基地址  int length;  //多项式中当前项的个数}SqList;//多项式的顺序储存结构类型为SqList<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>图书表的顺序存储结构类型定义</strong><br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/8.jpg"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 1000 //图书表可能达到的最大长度typedef struct {  //图书信息定义  char no[20];  char name[50];  float price;}Book;   typedef struct {   Book *elem;  //储存空间的基地址  int length;  //图书表中当前图书个数}SqList;//图书表的顺序储存结构类型为SqList  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线性表的数据类型定义模板"><a href="#线性表的数据类型定义模板" class="headerlink" title="线性表的数据类型定义模板"></a><strong>线性表的数据类型定义模板</strong></h3><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/9.jpg"> </p><h2 id="类C语言有关操作"><a href="#类C语言有关操作" class="headerlink" title="类C语言有关操作"></a><strong>类C语言有关操作</strong></h2><p>数组静态分配：<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   ElemType data[MaxSize];    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>data:首元素地址</p></blockquote><p>数组动态分布<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   ElemType *data;    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>SqList L;<br>L.data=(Elem Type*)malloc(sizeof(Elem Type)*MaxSize);  </p></blockquote><p><code>malloc(m)</code>函数：开辟m字节长度的地址空间，并返回这段空间的首地址<br><code>sizeof(x)</code>运算：计算变量x的长度<br><code>free(p)</code>函数：释放指针p所指变量的存储空间，即彻底删除一个变量  </p><blockquote><p>需要加载头文件<code>&lt;stdlib.h&gt;</code>  </p></blockquote><p>补充：   </p><h3 id="C-的动态存储分配"><a href="#C-的动态存储分配" class="headerlink" title="C++的动态存储分配"></a><strong>C++的动态存储分配</strong></h3><p>new 类型名T(初始列表)<br>功能：申请用于存放T类型对象的内存空间，并依初值列表赋值以初值<br>结果值：  </p><ul><li>成功：T类型指针，指向新分配内存  </li><li>失败：0 （NULL）</li></ul><p><code>int *p1 = new int;</code><br>或 <code>int *p1 = new int（10）;</code><br>使用 <code>delete 指针P</code> 释放 </p><h2 id="线性表的顺序表示和实现-1"><a href="#线性表的顺序表示和实现-1" class="headerlink" title="线性表的顺序表示和实现"></a><strong>线性表的顺序表示和实现</strong></h2><p>线性表类型的构造（回顾）：<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   ElemType data[MaxSize];    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>线性表变量L的定义以及成员读取：<br> <pre class="line-numbers language-C" data-language="C"><code class="language-C">SqList L;L.elem;//orSqList *L;L-&gt;elem;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>补充：操作算法中用到的预定义常量和类型<br> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/10.jpg"> <p></p><h3 id="算法1-线性表的初始化"><a href="#算法1-线性表的初始化" class="headerlink" title="算法1 线性表的初始化"></a><strong>算法1</strong> 线性表的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitList_Sq(SqList &amp;L){  L.elem=new ElemType[MAXSIZE];  if(!L.elem) exit(OVERFLOW);  L.length=0; //空表长度为0  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-线性表的销毁"><a href="#算法2-线性表的销毁" class="headerlink" title="算法2 线性表的销毁"></a><strong>算法2</strong> 线性表的销毁</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void DestroyList(SqList &amp;L){ if(L.elem)delete L.elem;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法3-线性表的清空"><a href="#算法3-线性表的清空" class="headerlink" title="算法3 线性表的清空"></a><strong>算法3</strong> 线性表的清空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void CleanList(SqList &amp;L){ L.Length=0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法4-线性表的长度"><a href="#算法4-线性表的长度" class="headerlink" title="算法4 线性表的长度"></a><strong>算法4</strong> 线性表的长度</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int GetLength(SqList L){ return(L.Length);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法5-判断线性表是否为空"><a href="#算法5-判断线性表是否为空" class="headerlink" title="算法5 判断线性表是否为空"></a><strong>算法5</strong> 判断线性表是否为空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int IsEmpty(SqList L){ if(L.Length==0)return 1; else return 0；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-顺序表的取值（取值i元素）"><a href="#算法6-顺序表的取值（取值i元素）" class="headerlink" title="算法6 顺序表的取值（取值i元素）"></a><strong>算法6</strong> 顺序表的取值（取值i元素）</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int GetElem(SqList L, ElemType &amp;e){ if(i&lt;1||i&gt;L.length)return ERROR; e=L.elem[i-1]; return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-顺序表的元素查找（顺序查找）"><a href="#算法7-顺序表的元素查找（顺序查找）" class="headerlink" title="算法7 顺序表的元素查找（顺序查找）"></a><strong>算法7</strong> 顺序表的元素查找（顺序查找）</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int LocateElem(SqList L, ElemType e){ for(i=0；i&lt;L.length;i++)   if(L.elem[i]==e) return i+1; return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/11.jpg">  </p><h3 id="算法8-顺序表的元素插入"><a href="#算法8-顺序表的元素插入" class="headerlink" title="算法8 顺序表的元素插入"></a><strong>算法8</strong> 顺序表的元素插入</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListInsert_Sq(SqList &amp;L,int i,Elem Type e){  if(i&lt;1||i&gt;L.length+1)return ERROR; //i值不合法  if(L.length==MAXSIZE)return ERROR; //当前存储空间已满  for(j=L.length-1;j&gt;=i-1;j--)   L.elem[j+1]=L.elem[j];   L.elem[i-1]=e;   L.length++; //表长+1   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/12.jpg">   </p><h3 id="算法9-顺序表的元素删除"><a href="#算法9-顺序表的元素删除" class="headerlink" title="算法9 顺序表的元素删除"></a><strong>算法9</strong> 顺序表的元素删除</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListDelete_Sq(SqList &amp;L,int i){  if(i&lt;1||i&gt;L.length+1)return ERROR; //i值不合法  for(j=i;j&lt;=L.length-1;j++)   L.elem[j-1]=L.elem[j];   L.length--; //表长-1   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/14.jpg">  </p><h2 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a><strong>线性表的链式表示和实现</strong></h2><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/15.jpg">  </p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a><strong>相关术语</strong></h3><ul><li>结点；数据元素的存储映像，由数据域和指针域两部分组成  </li><li>链表：n个结点由指针链组成一个链表</li></ul><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/16.jpg" alt="带头结点的单链表">   </p><p>单链表：有一个指针域<br>双链表：有两个指针域<br>循环链表：首尾相接  </p><p>头指针：指向链表第一个结点的指针<br>首元结点：存储第一个数据元素a1的结点<br>头结点：实在链表的首元结点之前附设的一个结点<br>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/17.jpg">  </p><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/18.jpg">  </p><blockquote><p><em>如何表示空表？</em><br>无头结点时，头指针为空时表示空表<br>有头结点时，当头结点的指针域为空时表示空表  </p></blockquote><blockquote><p><em>在链表中设置头结点有什么好处？</em><br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/19.jpg">  </p></blockquote><blockquote><p><em>头结点的数据域内装的是什么？</em><br>数据域可以为空，也可以存放表长等信息，但此结点不计入表长值  </p></blockquote><p>顺序表：随机存取<br>链表：顺序存取</p><p>单链表是由表头唯一确定的，因此单链表可以用<strong>头指针</strong>的名字来命名，若头指针名是L，则把链表称为表L</p><h3 id="链表结点的定义"><a href="#链表结点的定义" class="headerlink" title="链表结点的定义"></a><strong>链表结点的定义</strong></h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct Lnode{ ElemType data;  //结点的数据域 struct Lnode *next;  //结点的指针域  }Lnode,*LinkList;//LlinkList为指向结构体Lnode的指针类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>单链表L的定义：<br>定义链表L： <code>LinkList L;</code><br>定义结点指针p： <code>LNode *p;</code> 、<code>LinkList p;</code></p><p>例如，存储学生学号、姓名、成绩的单链表结点类型定义如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct student{ char num[8]; char name[8]; int score; struct student *next;  }Lnode,*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过为了统一链表的操作，通常这样定义：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct { char num[8]; char name[8]; int score; }ElemType;typedef struct Lnode{ ElemType data； struct Lnode *next;  }Lnode,*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法1-单链表的初始化"><a href="#算法1-单链表的初始化" class="headerlink" title="算法1 单链表的初始化"></a><strong>算法1</strong> 单链表的初始化</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitList L(LinkList &amp;L){   L=new LNode;  //或 L=(LinkList)malloc (sizeof(LNode));   L-&gt;next=NULL;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-判断链表是否为空"><a href="#算法2-判断链表是否为空" class="headerlink" title="算法2 判断链表是否为空"></a><strong>算法2</strong> 判断链表是否为空</h3><p>空表：链表中无元素，称为空链表(头指针和头结点仍然在)</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int ListEmpty (LinkList L){ if(L-&gt;next) //非空   return 0; else    return 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-单链表的销毁"><a href="#算法3-单链表的销毁" class="headerlink" title="算法3 单链表的销毁"></a><strong>算法3</strong> 单链表的销毁</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DestroyList_L(LinkList &amp;L){ Lnode *p; while(L){   p=L;   L=L-&gt;next;   delete p; }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法4-清空单链表"><a href="#算法4-清空单链表" class="headerlink" title="算法4 清空单链表"></a><strong>算法4</strong> 清空单链表</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ClearList(LinkList &amp;L){   Lnode *p，*q；   p=L-&gt;next;   while(p){     q=p-&gt;next;     delete p;     p=q;   }  L-&gt;next=NULL;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-单链表表长"><a href="#算法5-单链表表长" class="headerlink" title="算法5 单链表表长"></a><strong>算法5</strong> 单链表表长</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int ListLength_L(LinkList L){   LinkList p; //Lnode *p;    p=L-&gt;next; //p指向第一个结点     i=0;     while(p){       i++;       p=p-&gt;next;     }   return i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-取值"><a href="#算法6-取值" class="headerlink" title="算法6 取值"></a><strong>算法6</strong> 取值</h3><p> 取单链表中第i个元素内容  </p> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status GetElem L(LinkList L, int i,ElemType &amp;e){  p=L-&gt;next;  j=1;  while(p &amp;&amp; j&lt;i){    p=p-&gt;next; ++j;  }  if(!p||j&gt;i) return ERROR;    e=p-&gt;data;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-按值查找"><a href="#算法7-按值查找" class="headerlink" title="算法7 按值查找"></a><strong>算法7</strong> 按值查找</h3><p>根据指定数据获取该数据所在的位置(地址)</p> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Lnode *LocateElem_L(LinkList L,ElemType e){  P=L-&gt;next;  while(p&amp;&amp;p-&gt;data!=e)     p=p-&gt;next;  return p;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-变化-按值查找"><a href="#算法7-变化-按值查找" class="headerlink" title="算法7-变化 按值查找"></a><strong>算法7-变化</strong> 按值查找</h3><p>根据指定数据获取该数据所在的位置序号</p> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int LocateElem_L(LinkList L,ElemType e){  P=L-&gt;next; j=1;  while(p&amp;&amp;p-&gt;data!=e)     {p=p-&gt;next;j++;}  if(p)return j;  else return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法8-插入-在第i个结点前插入值为e的新结点"><a href="#算法8-插入-在第i个结点前插入值为e的新结点" class="headerlink" title="算法8 插入-在第i个结点前插入值为e的新结点"></a><strong>算法8</strong> 插入-在第i个结点前插入值为e的新结点</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListInsert_L(LinkList &amp;L,int i,ElemType e){  P=L;j=0;  while(p&amp;&amp;j&lt;i-1)     {p=p-&gt;next;++j;}  if(p||j&gt;i-1)return ERROR;  s=new LNode; s-&gt;data=e;  s-&gt;next=p-&gt;next;  p-&gt;next=s;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法9-删除-删除第i个结点"><a href="#算法9-删除-删除第i个结点" class="headerlink" title="算法9 删除-删除第i个结点"></a><strong>算法9</strong> 删除-删除第i个结点</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e){  P=L;j=0;  while(p-&gt;next&amp;&amp;j&lt;i-1){p=p-&gt;next;++j;}       if(!p-&gt;next||j&gt;i-1)return ERROR;  q=p-&gt;next;  p-&gt;next=q-&gt;next;  e=q-&gt;data;  delete q;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>单链表各算法时间效率  </p><ul><li>查找：O(n)</li><li>插入和删除：一般情况下O(1),但如果从头查找，所消耗的时间复杂度为O(n)</li></ul></blockquote><h3 id="算法10-单链表的建立"><a href="#算法10-单链表的建立" class="headerlink" title="算法10 单链表的建立"></a><strong>算法10</strong> 单链表的建立</h3><p>头插法：元素插入到链表头部<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/20.jpg"> </p><p>首先，在内存中找到一个空间存放头结点  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/21.jpg"><br><code>L=new LNode;</code>或<code>L=(LinkList)malloc(sizeof(LNode));</code>  </p></blockquote><p>将头结点置空  </p><blockquote><p><code>L-&gt;next=NULL;</code></p></blockquote><p>依次插入其余结点，从最后一个结点开始  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/22.jpg"><br><code>p=new LNode;  p-&gt;data=an;</code> </p></blockquote><p>将L的next域赋值给p的next域，并将头结点L的next赋值为新结点P的地址  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/23.jpg"><br><code>p=next=L-&gt;next;  L-&gt;next=p;</code>  </p></blockquote><p>继续放置前一个结点</p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/24.jpg"><br><code>p=new LNode; p-&gt;data=an-1</code>  </p></blockquote><p>再接着做之前的步骤  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/25.jpg"><br><code>p=next=L-&gt;next;  L-&gt;next=p;</code><br>反复循环，直到所有元素都插入  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">//倒位序输入n个元素值void CreateList_H(LinkList &amp;L,int n){   L=new LNode;   L-&gt;next=NULL;   for(i=n;i&gt;0;--i){     p=new LNode;     scanf(&amp;p-&gt;data);     p-&gt;next=L-&gt;next;     L-&gt;next=p;   } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尾插法：元素插入在链表尾部  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">//正位序输入n个元素值void CreateList_H(LinkList &amp;L,int n){   L=new LNode;   L-&gt;next=NULL;   r=L;//尾指针r指向头结点   for(i=0;i&lt;n;++i){     p=new LNode;     scanf(&amp;p-&gt;data);     p-&gt;next=NULL;     r-&gt;next=p;     r=p;//r指向新的尾结点   } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a><strong>循环链表</strong></h2><p>是一种头尾相接的链表<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/26.jpg"><br>优点：从表中任意结点出发均可找到表中其他结点  </p><blockquote><p>循环列表没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断<code>p</code>或<code>p-&gt;next </code>是否为空，而是判断他们是否等于头指针  </p></blockquote><p>循环条件:  </p><table><thead><tr><th>单链表</th><th>单循环链表</th></tr></thead><tbody><tr><td>p!=NULL</td><td>p!=L</td></tr><tr><td>P-&gt;next!=NULL</td><td>p-&gt;NEXT!=1</td></tr></tbody></table><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/27.jpg"> </p><blockquote><p>循环链表若经常需要对首尾进行操作，则设置尾指针更为合适  </p></blockquote><h3 id="带尾指针循环链表的合并"><a href="#带尾指针循环链表的合并" class="headerlink" title="带尾指针循环链表的合并"></a><strong>带尾指针循环链表的合并</strong></h3><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/28.jpg"></p><blockquote><p>p存表头结点，Tb表头连接到Ta表尾，释放Tb表头结点，修改指针<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/29.jpg"><br><code>p=Ta-&gt;next;</code><br><code>Ta-&gt;next=Tb-&gt;next-&gt;next;</code><br><code>delete Tb-&gt;next;</code>   </p></blockquote><p>算法描述  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">LinkList Connect(LinkList Ta,LinkList Tb){   p=Ta-&gt;next;   Ta-&gt;next=Tb-&gt;next-&gt;next;   delete Tb-&gt;next;   Tb-&gt;next=p;   return Tb; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a><strong>双向链表</strong></h2><p> 双向链表的结点结构<br> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/30.jpg">   </p><h3 id="双向链表的结构定义"><a href="#双向链表的结构定义" class="headerlink" title="双向链表的结构定义"></a><strong>双向链表的结构定义</strong></h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct DuLNode{  Elemtype data;  struct DuLNode *prior, *next;}DuLNode,*DuLinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/31.jpg">   </p><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a><strong>双向循环链表</strong></h3><p>-让头结点的前驱指针指向链表的最后一个结点<br>-让最后一个结点的后继指向头结点<br> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/32.jpg"> </p><h3 id="算法1-双向链表的插入"><a href="#算法1-双向链表的插入" class="headerlink" title="算法1 双向链表的插入"></a><strong>算法1</strong> 双向链表的插入</h3><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/33.jpg">   </p><blockquote><p><code>s-&gt;prior=p-&gt;prior;</code><br><code>p-&gt;prior-&gt;next=s;</code><br><code>s-&gt;next=p;</code><br><code>p-&gt;prior=s;</code>  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">void LinkInsert_DuL(DuLinkList &amp;L, int i,ElemType e){   if(!(p=GetElemP_DuL(L,i)))return ERROR;   s=new DuLNode;   s-&gt;data=e;   s-&gt;prior=p-&gt;prior;   p-&gt;prior-&gt;next=s;   s-&gt;next=p;   p-&gt;prior=s;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-双向链表的删除"><a href="#算法2-双向链表的删除" class="headerlink" title="算法2 双向链表的删除"></a><strong>算法2</strong> 双向链表的删除</h3><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/34.jpg"></p><blockquote><p><code>p-&gt;prior-&gt;next=p-&gt;next;</code><br><code>p-&gt;next-&gt;prior=p-&gt;prior;</code>  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">void LinkInsert_DuL(DuLinkList &amp;L, int i,ElemType e){   if(!(p=GetElemP_DuL(L,i)))return ERROR;   e=p-&gt;data;   p-&gt;prior-&gt;next=p-&gt;next;   p-&gt;next-&gt;prior=p-&gt;prior;   free(p);   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单链表、循环链表和双向链表的时间效率比较"><a href="#单链表、循环链表和双向链表的时间效率比较" class="headerlink" title="单链表、循环链表和双向链表的时间效率比较"></a><strong>单链表、循环链表和双向链表的时间效率比较</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/35.jpg">  </p><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a><strong>顺序表和链表的比较</strong></h2><p>链式存储结构的优点：</p><blockquote><p>结点空间可以动态申请和释放<br>删除和插入时不需要移动数据元素  </p></blockquote><p>链式存储结构的缺点：</p><blockquote><p>存储密度小，每个结点的指针域需额外占用存储空间<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/36.jpg"><br>非随机存取结构，对任意结点的操作都要从头指针依指针链查找到该结点，增加了算法复杂度  </p></blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/37.jpg">  </p><h2 id="案例1：一元多项式的运算"><a href="#案例1：一元多项式的运算" class="headerlink" title="案例1：一元多项式的运算"></a><strong>案例1：一元多项式的运算</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/38.jpg">  </p><h2 id="案例2：稀疏多项式的运算"><a href="#案例2：稀疏多项式的运算" class="headerlink" title="案例2：稀疏多项式的运算"></a><strong>案例2：稀疏多项式的运算</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/39.jpg">  </p><p>结构建立：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct PNode{    float coef;  //系数    int expn;    //指数    struct PNode *next; //指针域  }PNode,*Polynomial;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/40.jpg"></p><p>多项式创建：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void CreatePolyn(Polynomial &amp;P, int n){   P=new PNode;   P-&gt;next=NULL;   for(i=1;i&lt;=n;i++){    s=new PNode;    cin&gt;&gt;s-&gt;coef&gt;&gt;s-&gt;expn;    pre=P;    q=P-&gt;next;    while(q&amp;&amp;q-&gt;expn&lt;s-&gt;expn){      pre=q; q=q-&gt;next;    }    s-&gt;next=q;    pre-&gt;next=s;   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多项式相加：<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/41.jpg">  </p><h2 id="案例3：图书信息管理系统"><a href="#案例3：图书信息管理系统" class="headerlink" title="案例3：图书信息管理系统"></a><strong>案例3：图书信息管理系统</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/42.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础简记ch.1</title>
      <link href="/2022/09/07/php-ji-chu-jian-ji-ch.1/"/>
      <url>/2022/09/07/php-ji-chu-jian-ji-ch.1/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP基础简记ch-1"><a href="#PHP基础简记ch-1" class="headerlink" title="PHP基础简记ch.1"></a>PHP基础简记ch.1</h1><h2 id="PHP标记"><a href="#PHP标记" class="headerlink" title="PHP标记"></a><strong>PHP标记</strong></h2><p> 1.脚本标记   </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;script language="php"&gt;  echo 'hello world';&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 2.标准标记  </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  echo 'hello world';?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="PHP注释"><a href="#PHP注释" class="headerlink" title="PHP注释"></a><strong>PHP注释</strong></h2><ul><li>行注释 <code>//</code>、<code>#</code>  </li><li>块注释 <code>/* */</code></li></ul><h2 id="语句分隔符"><a href="#语句分隔符" class="headerlink" title="语句分隔符"></a><strong>语句分隔符</strong></h2><p>PHP中，代码是以行为单位，系统需要通过判断行的结束，该结束通常都是一个符号：分号 <code>;</code> (英文状态下的)</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  //定义变量  $var1;  $var2 = 1;//定义同时赋值  echo $var2;//通过var2变量名字找到储存内容1，然后输出    //删除变量，使用unset（变量名字）  unset($var2)?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>提前定义的变量，储存许多需要用的数据（预定义变量都是数组）  </p><ul><li>$_GET：获取所有表单以get方式提交的数据</li><li>$_POST: POST提交的数据都会保存在此次</li><li>$_REQUEST: GET和POST提交的都会保存</li><li>$_SERVER: 服务器信息</li><li>$_SESSION: session会话数据</li></ul><h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><p>如果一个变量保存的值刚好是另一个变量的名字，则可以：  </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  //可变变量  $a = 'b';  $b = 'bb';  echo $$a;  //输出结果为bb?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h3><p>将一个变量赋值给另一个变量  </p><ul><li>值传递  </li><li>引用传递</li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  $a = 1;  $b = $a; //值传递    $b = 2;  echo $a,$b;  //输出结果1,2  $a = 1;  $b = &amp;$a; //引用传递    $b = 2;  echo $a,$b;  //输出结果2,2?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h2><p>常量一旦定义，通常数据不可改变</p><ul><li>使用定义常量的函数 <code>define( , )</code>  </li><li>5.3后才有的：const 常量名 = 值</li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  define('PI',3.14) ;  const PII =3 ;?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>常量不需要使用<code>$</code>符号，一旦使用会被认为是变量<br>常量的名字组成由字母、数字和下划线组成，不能以数字开头<br>常量的名字通常以大写字母为主<br>define 和 const 定义的常亮有区别，在于权限的区别，如：   </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  define('-_-','smile') ;  //正确  const -_- ='smile' ; //错误?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如需访问常量，则需使用另外一个访问常量的函数：<code>echo constant('常量名')</code>  </p><h3 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h3><p>系统常量： 系统帮助用户定义的常量，用户可以直接使用<br>常用的几个系统常量：  </p><ul><li>PHP_VERSION  </li><li>PHP_INT_SIZE  </li><li>PHP_INT_MAX</li></ul><p>在PHP中还有一些特殊的常量，他们由双下划线开始+常量名+双下划线结束，这种常量称之为系统魔术常量，魔术常量的值通常会跟着环境变化，但是用户改变不了，如：  </p><ul><li><code>__DIR__</code>:被执行脚本在电脑的绝对路径  </li><li><code>__FILE__</code>:被执行脚本在电脑的绝对路径（带文件名）  </li><li><code>__LINE__</code>:当前所属行数的绝对路径  </li><li><code>__NAMESPACE__</code>:当前所属命名空间  </li><li><code>__CLASS__</code>:当前所属类  </li><li><code>__METHOD__</code>:当前所属方法</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>在PHP中得的是存储的数据本身的类型，而不是变量的类型，PHP是一种弱类型语言，本身并没有类型  </p><h3 id="PHP的八种数据类型"><a href="#PHP的八种数据类型" class="headerlink" title="PHP的八种数据类型"></a>PHP的八种数据类型</h3><p>在PHP中将数据分为三大类八小类  </p><ul><li>基本数据类型<ul><li>整型：int ，四个字节储存  </li><li>浮点型：float/double ，八个字节储存</li><li>字符串型：string  </li><li>布尔类型：bool</li></ul></li><li>复合数据类型<ul><li>对象：object ，存放对象  </li><li>数组：array ，存储多个数据（一次性）</li></ul></li><li>特殊数据类型<ul><li>资源：resource ，存放资源数据</li><li>空类型：NULL</li></ul></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>需要指定数据类型，需要外部数据  </p><ul><li>自动转换：系统根据需求自己判定，效率偏低  </li><li>强制转换：人为转换，在变量前加一个括号，在里面写入对应类型</li></ul><p>在转换过程中，用的比较多的为转布尔类型和转数值类型，关于转布尔的说明：<br><img src="/2022/09/07/php-ji-chu-jian-ji-ch.1/about_bool.jpg" alt="布尔的相关说明">  </p><p>字符串转数值的说明  </p><ul><li>布尔true为1， false为0  </li><li>字符串转数值：<ul><li>以字母开头的字符串永远为0</li><li>以数字开头的字符串，取到碰到字符串为止（不会出现多个小数点）</li></ul></li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  $a = 'abc1.1.1';  $b = '1.1.1abc'; //创建数据  echo $a + $b;  //自动转换  //算数+运算，系统先转换成数值类型（整型和浮点型）  //结果为1.1    echo (float)$a,(foloat)$b; //输出结果01.1?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h3><p>通过一组类型判断函数，来判断变量，最终返回这个变量所保存的数据类型（如果相同返回true）：以is_开头后面跟类型名字的函数: is_xxx(变量名)</p><p>bool类型不能用echo来查看，可使用<code>var_dump</code>结构来查看  </p><p>还有一组函数可以来获取积极设定数据的类型 gettype(变量名)：获取类型，得到的是该类型对应的字符串</p><p>settype(变量名，类型): 设定数据类型：与强制转换不同  </p><ul><li>强制转换是对数据值复制的内容进行处理  </li><li>settype会改变变量本身</li></ul><h3 id="整数类型进制"><a href="#整数类型进制" class="headerlink" title="整数类型进制"></a>整数类型进制</h3><blockquote><p>在PHP中提供了四种类型的定义方式：十进制、二进制、八进制、十六进制<br><code>$a=120; //十进制</code><br><code>$a=0b120; //二进制</code><br><code>$a=0120; //八进制</code><br><code>$a=0x120; //十六进制</code>  </p></blockquote><h3 id="整数类型进制转换"><a href="#整数类型进制转换" class="headerlink" title="整数类型进制转换"></a>整数类型进制转换</h3><ul><li><code>decbin()</code>:10转2  </li><li><code>decoct()</code>:10转8  </li><li><code>dechex()</code>:10转16  </li><li><code>bindec()</code>:2转10</li></ul><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>整型超过自身存储的大小后会用浮点型存储  </p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h2><p>与其他语言几乎一致，补充一点‘全等于’：<code>===</code> 左边与右边相同(大小、数据类型)</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/02/hello-world/"/>
      <url>/2022/09/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
