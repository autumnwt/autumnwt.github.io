<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构之栈和队列</title>
      <link href="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/"/>
      <url>/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之栈和队列"><a href="#数据结构之栈和队列" class="headerlink" title="数据结构之栈和队列"></a>数据结构之栈和队列</h1><h2 id="栈和队列的定义"><a href="#栈和队列的定义" class="headerlink" title="栈和队列的定义"></a><strong>栈和队列的定义</strong></h2><p>栈和队列是两种常用的数据结构，是限定插入和删除只能在表的“端点”进行的线性表  </p><blockquote><p><strong>栈</strong>的操作具有后进先出的固有特性<br>如“数值转换”  “表达式求值”  “括号匹配检验”  “八皇后问题”  “函数调用”  “迷宫求解” 等等  </p></blockquote><blockquote><p><strong>队列</strong>的操作具有先进先出的特性<br>使得队列成为程序设计中解决类似排队问题的工具  </p></blockquote><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/1.jpg">  </p><h2 id="栈的定义和特点"><a href="#栈的定义和特点" class="headerlink" title="栈的定义和特点"></a><strong>栈的定义和特点</strong></h2><p>是一个特殊的线性表，限定仅在一端（通常是表尾）进行插入和删除操作的线性表  </p><p>又称为后进先出，简称LIFO结构  </p><blockquote><p>表尾（即an端）称为栈顶Top；表头（即a1端）称为栈底Base<br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/2.jpg"><br>插入元素到栈顶（表尾）的操作称为入栈；<br>从栈顶删除最后一个元素的操作称为出栈<br>压入=<code>PUSH(x)</code>  弹出=<code>POP(y)</code></p></blockquote><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/3.jpg">  </p><h2 id="队列的定义和特点"><a href="#队列的定义和特点" class="headerlink" title="队列的定义和特点"></a><strong>队列的定义和特点</strong></h2><p>在表一端插入（表尾），在另一端（表头）删除<br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/4.jpg">  </p><h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a><strong>案例引入</strong></h2><h3 id="案例1-进制转换"><a href="#案例1-进制转换" class="headerlink" title="案例1 进制转换"></a><strong>案例1</strong> 进制转换</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/5.jpg">  </p><h3 id="案例2-括号匹配的检验"><a href="#案例2-括号匹配的检验" class="headerlink" title="案例2 括号匹配的检验"></a><strong>案例2</strong> 括号匹配的检验</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/6.jpg">  </p><h3 id="案例3-表达式求值"><a href="#案例3-表达式求值" class="headerlink" title="案例3 表达式求值"></a><strong>案例3</strong> 表达式求值</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/7.jpg"><br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/8.jpg">  </p><h3 id="案例4-舞伴问题"><a href="#案例4-舞伴问题" class="headerlink" title="案例4 舞伴问题"></a><strong>案例4</strong> 舞伴问题</h3><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/9.jpg">  </p><h2 id="栈的抽象数据类型的类型定义"><a href="#栈的抽象数据类型的类型定义" class="headerlink" title="栈的抽象数据类型的类型定义"></a><strong>栈的抽象数据类型的类型定义</strong></h2><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT Stack {    数据对象：       D={ai|ai属于ElemSet,i=1,2,3,...n,n&gt;=0}    数据关系：       R1={&lt;ai-1,ai&gt;|ai-1，ai属于D，i=2，...,n}         约定an端为栈顶，a1端为栈底。      基本操作：初始化、进栈、出栈、取栈顶元素等}}ADT Stack <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>InitStack(&amp;S)：初始化操作，构造一个空栈S  </li><li>DestoryStack(&amp;S)：销毁栈操作   </li><li>StackEmpty(S)：判断S是否为空栈</li><li>StackLength(L):返回S的元素个数</li><li>GetTop(S,&amp;e):取栈顶元素</li><li>ClearStack(&amp;S):栈置空操作</li><li>Puah(&amp;S,e):插入元素e为新的栈顶元素</li><li>Pop(&amp;S,&amp;e):删除S的栈顶元素，并用e返回其值</li></ul><h2 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a><strong>顺序栈的表示和实现</strong></h2><p>存储方式：与一般线性表的顺序存储结构完全相同<br>利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，栈底一般在低地址端  </p><ul><li>top指针：指示栈顶元素在顺序栈中的位置  </li><li>base指针，指示栈底元素在顺序栈中的位置  <blockquote><p>但是，为了方便操作，通常top指示真正的栈顶元素之上的下表地址<br>另外，用stacksize表示栈可以使用的最大容量<br><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/10.jpg"></p></blockquote></li></ul><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/11.jpg"></p><p>使用数组作为顺序栈存储方式的特点：  </p><blockquote><p>简单方便单易产生溢出（数组大小固定）  </p></blockquote><p>上溢：栈已经满，又要压入元素<br>下溢：栈已经空，还要弹出元素  </p><blockquote><p>上溢是一种错误，而下溢一般认为是一种结束条件，即问题处理结束  </p></blockquote><h3 id="顺序栈的数据类型定义"><a href="#顺序栈的数据类型定义" class="headerlink" title="顺序栈的数据类型定义"></a><strong>顺序栈的数据类型定义</strong></h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 100typedef struct {    SElemType *base;//栈底指针    SElemType *top;//栈顶指针    int stacksize; //栈可用最大容量}SqStack;```  ![](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/12.jpg)  ### **算法1** 顺序栈的初始化 ```CStatus InitStack(SqStack &amp;S){  S.base=new SElemType[MAXSIZE];//或  //S.base=(SElemType*)malloc(MAXSIZE*sizeof(SElemType));    if(!S.base)exit (OVERFLOW);  S.top=S.base;  S.stacksize=MAXSIZE;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-顺序栈判断是否是空"><a href="#算法2-顺序栈判断是否是空" class="headerlink" title="算法2 顺序栈判断是否是空"></a><strong>算法2</strong> 顺序栈判断是否是空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status StackEmpty(SqStack S){  if(S.top==S.base)return TRUE;  else return FALSE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-求顺序栈长度"><a href="#算法3-求顺序栈长度" class="headerlink" title="算法3 求顺序栈长度"></a><strong>算法3</strong> 求顺序栈长度</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status StackLength(SqStack S){  return S.top-S.base；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法4-清空顺序栈"><a href="#算法4-清空顺序栈" class="headerlink" title="算法4 清空顺序栈"></a><strong>算法4</strong> 清空顺序栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ClearStack(SqStack S){   if(S.base)S.top=S.base;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-销毁顺序栈"><a href="#算法5-销毁顺序栈" class="headerlink" title="算法5 销毁顺序栈"></a><strong>算法5</strong> 销毁顺序栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DestroyStack(SqStack &amp;S){   if(S.base){    delete S.base;    S.stacksize=0;    S.base= S.top =NULL;   }   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-顺序栈的入栈"><a href="#算法6-顺序栈的入栈" class="headerlink" title="算法6 顺序栈的入栈"></a><strong>算法6</strong> 顺序栈的入栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Push(SqStack &amp;S,SElemType e){   if(S.top-S.base==S.stacksize)//栈满       return ERROR;   *S.top++=e;//*S.top=e;S.top++;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-顺序栈的出栈"><a href="#算法7-顺序栈的出栈" class="headerlink" title="算法7 顺序栈的出栈"></a><strong>算法7</strong> 顺序栈的出栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Pop(SqStack &amp;S,SElemType &amp;e){   if(S.top==S.base)//等价于if(StackEmpty(S))   return ERROR;    e=*--S.top;//--S.top;e=*S.top;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a><strong>链栈的表示和实现</strong></h2><p>链栈是运算受限的单链表，只能在链表头部进行操作 </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct StackNode{    SElemType data；    struct StackNode *next;}StackNode,*LinkStack;  LinkStack S;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/13.jpg">  </p><h3 id="算法1-链栈的初始化"><a href="#算法1-链栈的初始化" class="headerlink" title="算法1 链栈的初始化"></a><strong>算法1</strong> 链栈的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void InitStack(LinkStack &amp;S){    //构造一个空栈，栈顶指针置为空    S=NULL;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-链栈的初始化"><a href="#算法2-链栈的初始化" class="headerlink" title="算法2 链栈的初始化"></a><strong>算法2</strong> 链栈的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void InitStack(LinkStack &amp;S){    //构造一个空栈，栈顶指针置为空    S=NULL;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-判断链栈是否为空"><a href="#算法3-判断链栈是否为空" class="headerlink" title="算法3 判断链栈是否为空"></a><strong>算法3</strong> 判断链栈是否为空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void StackEmpty(LinkStack S){    if(S==NULL)return TRUE;    else return FALSE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法4-链栈的入栈"><a href="#算法4-链栈的入栈" class="headerlink" title="算法4 链栈的入栈"></a><strong>算法4</strong> 链栈的入栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Push(LinkStack &amp;S,SElemType e){    p=new StackNode;    p-&gt;data=e;    p-&gt;next=S;    S=p;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-链栈的出栈"><a href="#算法5-链栈的出栈" class="headerlink" title="算法5 链栈的出栈"></a><strong>算法5</strong> 链栈的出栈</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Pop(LinkStack &amp;S,SElemType &amp;e){    if(S==NULL)return ERROR;    e=S-&gt;data;    p=S;    S=S-&gt;next;    delete p;    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-取栈顶元素"><a href="#算法6-取栈顶元素" class="headerlink" title="算法6 取栈顶元素"></a><strong>算法6</strong> 取栈顶元素</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">SElemType GetTop(LinkStack S){    if(S!=NULL)    return S-&gt;data;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈和递归"><a href="#栈和递归" class="headerlink" title="栈和递归"></a><strong>栈和递归</strong></h2><p><img src="/2022/10/04/shu-ju-jie-gou-zhi-zhan-he-dui-lie/14.jpg"></p><blockquote><p>注：栈的应用与递归详见数据结构书中P48页始  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之线性表</title>
      <link href="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/"/>
      <url>/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之线性表"><a href="#数据结构之线性表" class="headerlink" title="数据结构之线性表"></a>数据结构之线性表</h1><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a><strong>知识回顾</strong></h2><p>数据结构  </p><ul><li>逻辑结构  <ul><li>线性结构  <ul><li>线性表  </li><li>栈（特殊线性表） </li><li>队列（特殊线性表）</li><li>字符串、数组、广义表</li></ul></li><li>非线性结构  <ul><li>树形结构  </li><li>图形结构</li></ul></li></ul></li><li>数据的存储结构  <ul><li>顺序存储  </li><li>链式存储</li></ul></li><li>数据的运算：检索、排序、插入…</li></ul><h2 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a><strong>线性表的定义和特点</strong></h2><p>线性表是具有相同特性的数据元素的一个有限序列  </p><blockquote><p>(a1,a2,…,ai-1,ai,ai+1,…an)  </p><p>a1:线性起点<br>ai-1:ai的直接前趋<br>ai+1:ai的直接后继<br>an:线性终点<br>n=0时称为空表（n是表长） </p></blockquote><p>同一线性表中的元素必定具有相同特性，数据元素之间的关系是线性关系  </p><h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a><strong>案例引入</strong></h2><p>案例一：一元多项式的运算：实现两个多项式的加、减、乘运算  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/1.jpg" alt="案例一">  </p><p>案例二：稀疏多项式的运算  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/2.jpg"><br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/3.jpg" alt="案例二">  </p><blockquote><p>Q:那么数组C多大合适呢？  </p><p>顺序存储结构存在的问题  </p><ul><li>存储空间分配不灵活  </li><li>运算的空间复杂度高</li></ul></blockquote><p>—&gt;选择链式存储结构<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/4.jpg" alt="链式存储方法">   </p><p>案例三：图书信息管理系统  </p><ul><li>将图书表抽象为线性表  </li><li>表中每本书抽象线性表中数据元素</li></ul><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/5.jpg" alt="两种方式">  </p><p>线性表中数据元素可以是<em>简单类型</em>，也可以是<em>复杂类型</em>  </p><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a><strong>线性表的类型定义</strong></h2><blockquote><p>抽象数据类型（ADT）</p><ul><li>数据对象</li><li>数据对象关系集合  </li><li>作用在数据对象上的基本操作</li></ul></blockquote><p>抽象数据类型线性表的定义如下：  </p><pre class="line-numbers language-ADT" data-language="ADT"><code class="language-ADT">ADT List{   数据对象：D={ai|ai属于Elemset，(i=1,2,3...n，n&gt;=0)}     数据关系：R={&lt;ai-1，ai&gt;|ai-1，ai属于D，(i=1,2,3...n)}   基本操作：   IntList(&amp;L);   DestoryList(&amp;L);   ListInsert(&amp;L,i,e);   ListDelete(&amp;L,i,&amp;e);   ...}ADT List<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>InitList(&amp;L):构造一个空的线性表L</li><li>DestoryList(&amp;L)：线性表已存在的条件下，销毁线性表  </li><li>ClwanList(&amp;L)：线性表已存在的条件下，清除线性表元素，置L为空表  </li><li>ListEmpty(L)：线性表已存在的条件下，若L为空表，返回TRUE，否则返回FALSE</li><li>ListLength(L):线性表已存在的条件下，返回L中元素个数</li><li>GetElem(L,I,&amp;e):线性表已存在的条件下，1&lt;=i&lt;=ListLength(L),用e返回线性表中第i个元素的值</li><li>LocateElem(L,e,compare()):线性表已存在的条件下，compare()是数据元素判定函数，返回L中第一个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0</li><li>PriorElem(L,cur_e,&amp;pre_e):线性表已存在的条件下，若cur_e是L的数据元素，且不是第一个，则用pre_e返回他的前趋，否则操作失败，pre_e无意义</li><li>NextElem(L,cur_e,&amp;next_e):线性表已存在的条件下，若cur_e是L的数据元素，且不是最后一个，则用next_e返回他的后继，否则操作失败，next_e无意义</li><li>ListInsert(&amp;L,i,e):线性表已存在的条件下，1&lt;=i&lt;=ListLength(L)+1，在L的第i个位置之前插入新的元素e，L的长度加1</li><li>ListDelete(&amp;L,i,&amp;e)：线性表已存在的条件下，1&lt;=i&lt;=ListLength(L)，删除L的第i个元素，并用e返回其值，L的长度-1 </li><li>ListTraverse(&amp;L,visited()):线性表已存在的条件下，依次对线性表中的每个元素调用遍历visited()</li></ul><p>以上提及的运算是逻辑结构上定义的运算，只要给出这些运算功能是“做什么”，至于“如何做”，只有待确定了存储结构之后才考虑</p><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a><strong>线性表的顺序表示和实现</strong></h2><p>顺序存储：把逻辑上相邻的数据元素储存在物理上相邻的存储单元中的存储结构  </p><blockquote><p>线性表中的第一个数据元素a1的存储位置，称作线性表的<strong>起始位置</strong>或<strong>基地址</strong>  </p></blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/6.jpg" alt="两种方式">   </p><p>假设线性表的每个元素需要占用k个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足:LOC(ai+1)=LOC(ai)+k ；同时LOC(ai)=LOC(ai)+(i-1)*k  </p><blockquote><p>顺序表元素-&gt;数组元素<br>用一维数组表示顺序表  </p></blockquote><p>线性表长度可变但数组长度不可动态定义<br>-&gt;用以变量表示顺序表的长度属性  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define LIST INIT SIZE 100 //线性表存储空间的初始分配量  typedef struct {    ElemType elem[LIST_INIT_SIZE];    int length; //当前长度}SqList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多项式的顺序结构储存结构类型定义</strong>  </p><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/7.jpg">  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 1000 //多项式可能达到的最大长度typedef struct {  //多项式非零项的定义  float p;  //系数  int e;  //指数}Polynomial;   typedef struct {    Polynomial *elem;  //储存空间的基地址  int length;  //多项式中当前项的个数}SqList;//多项式的顺序储存结构类型为SqList<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>图书表的顺序存储结构类型定义</strong><br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/8.jpg"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 1000 //图书表可能达到的最大长度typedef struct {  //图书信息定义  char no[20];  char name[50];  float price;}Book;   typedef struct {   Book *elem;  //储存空间的基地址  int length;  //图书表中当前图书个数}SqList;//图书表的顺序储存结构类型为SqList  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线性表的数据类型定义模板"><a href="#线性表的数据类型定义模板" class="headerlink" title="线性表的数据类型定义模板"></a><strong>线性表的数据类型定义模板</strong></h3><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/9.jpg"> </p><h2 id="类C语言有关操作"><a href="#类C语言有关操作" class="headerlink" title="类C语言有关操作"></a><strong>类C语言有关操作</strong></h2><p>数组静态分配：<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   ElemType data[MaxSize];    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>data:首元素地址</p></blockquote><p>数组动态分布<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   ElemType *data;    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>SqList L;<br>L.data=(Elem Type*)malloc(sizeof(Elem Type)*MaxSize);  </p></blockquote><p><code>malloc(m)</code>函数：开辟m字节长度的地址空间，并返回这段空间的首地址<br><code>sizeof(x)</code>运算：计算变量x的长度<br><code>free(p)</code>函数：释放指针p所指变量的存储空间，即彻底删除一个变量  </p><blockquote><p>需要加载头文件<code>&lt;stdlib.h&gt;</code>  </p></blockquote><p>补充：   </p><h3 id="C-的动态存储分配"><a href="#C-的动态存储分配" class="headerlink" title="C++的动态存储分配"></a><strong>C++的动态存储分配</strong></h3><p>new 类型名T(初始列表)<br>功能：申请用于存放T类型对象的内存空间，并依初值列表赋值以初值<br>结果值：  </p><ul><li>成功：T类型指针，指向新分配内存  </li><li>失败：0 （NULL）</li></ul><p><code>int *p1 = new int;</code><br>或 <code>int *p1 = new int（10）;</code><br>使用 <code>delete 指针P</code> 释放 </p><h2 id="线性表的顺序表示和实现-1"><a href="#线性表的顺序表示和实现-1" class="headerlink" title="线性表的顺序表示和实现"></a><strong>线性表的顺序表示和实现</strong></h2><p>线性表类型的构造（回顾）：<br> </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {   ElemType data[MaxSize];    int length;  }SqList;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>线性表变量L的定义以及成员读取：<br> <pre class="line-numbers language-C" data-language="C"><code class="language-C">SqList L;L.elem;//orSqList *L;L-&gt;elem;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>补充：操作算法中用到的预定义常量和类型<br> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/10.jpg"> <p></p><h3 id="算法1-线性表的初始化"><a href="#算法1-线性表的初始化" class="headerlink" title="算法1 线性表的初始化"></a><strong>算法1</strong> 线性表的初始化</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitList_Sq(SqList &amp;L){  L.elem=new ElemType[MAXSIZE];  if(!L.elem) exit(OVERFLOW);  L.length=0; //空表长度为0  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-线性表的销毁"><a href="#算法2-线性表的销毁" class="headerlink" title="算法2 线性表的销毁"></a><strong>算法2</strong> 线性表的销毁</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void DestroyList(SqList &amp;L){ if(L.elem)delete L.elem;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法3-线性表的清空"><a href="#算法3-线性表的清空" class="headerlink" title="算法3 线性表的清空"></a><strong>算法3</strong> 线性表的清空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">void CleanList(SqList &amp;L){ L.Length=0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法4-线性表的长度"><a href="#算法4-线性表的长度" class="headerlink" title="算法4 线性表的长度"></a><strong>算法4</strong> 线性表的长度</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int GetLength(SqList L){ return(L.Length);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法5-判断线性表是否为空"><a href="#算法5-判断线性表是否为空" class="headerlink" title="算法5 判断线性表是否为空"></a><strong>算法5</strong> 判断线性表是否为空</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int IsEmpty(SqList L){ if(L.Length==0)return 1; else return 0；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-顺序表的取值（取值i元素）"><a href="#算法6-顺序表的取值（取值i元素）" class="headerlink" title="算法6 顺序表的取值（取值i元素）"></a><strong>算法6</strong> 顺序表的取值（取值i元素）</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int GetElem(SqList L, ElemType &amp;e){ if(i&lt;1||i&gt;L.length)return ERROR; e=L.elem[i-1]; return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-顺序表的元素查找（顺序查找）"><a href="#算法7-顺序表的元素查找（顺序查找）" class="headerlink" title="算法7 顺序表的元素查找（顺序查找）"></a><strong>算法7</strong> 顺序表的元素查找（顺序查找）</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int LocateElem(SqList L, ElemType e){ for(i=0；i&lt;L.length;i++)   if(L.elem[i]==e) return i+1; return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/11.jpg">  </p><h3 id="算法8-顺序表的元素插入"><a href="#算法8-顺序表的元素插入" class="headerlink" title="算法8 顺序表的元素插入"></a><strong>算法8</strong> 顺序表的元素插入</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListInsert_Sq(SqList &amp;L,int i,Elem Type e){  if(i&lt;1||i&gt;L.length+1)return ERROR; //i值不合法  if(L.length==MAXSIZE)return ERROR; //当前存储空间已满  for(j=L.length-1;j&gt;=i-1;j--)   L.elem[j+1]=L.elem[j];   L.elem[i-1]=e;   L.length++; //表长+1   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/12.jpg">   </p><h3 id="算法9-顺序表的元素删除"><a href="#算法9-顺序表的元素删除" class="headerlink" title="算法9 顺序表的元素删除"></a><strong>算法9</strong> 顺序表的元素删除</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListDelete_Sq(SqList &amp;L,int i){  if(i&lt;1||i&gt;L.length+1)return ERROR; //i值不合法  for(j=i;j&lt;=L.length-1;j++)   L.elem[j-1]=L.elem[j];   L.length--; //表长-1   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/14.jpg">  </p><h2 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a><strong>线性表的链式表示和实现</strong></h2><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/15.jpg">  </p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a><strong>相关术语</strong></h3><ul><li>结点；数据元素的存储映像，由数据域和指针域两部分组成  </li><li>链表：n个结点由指针链组成一个链表</li></ul><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/16.jpg" alt="带头结点的单链表">   </p><p>单链表：有一个指针域<br>双链表：有两个指针域<br>循环链表：首尾相接  </p><p>头指针：指向链表第一个结点的指针<br>首元结点：存储第一个数据元素a1的结点<br>头结点：实在链表的首元结点之前附设的一个结点<br>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/17.jpg">  </p><p>  <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/18.jpg">  </p><blockquote><p><em>如何表示空表？</em><br>无头结点时，头指针为空时表示空表<br>有头结点时，当头结点的指针域为空时表示空表  </p></blockquote><blockquote><p><em>在链表中设置头结点有什么好处？</em><br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/19.jpg">  </p></blockquote><blockquote><p><em>头结点的数据域内装的是什么？</em><br>数据域可以为空，也可以存放表长等信息，但此结点不计入表长值  </p></blockquote><p>顺序表：随机存取<br>链表：顺序存取</p><p>单链表是由表头唯一确定的，因此单链表可以用<strong>头指针</strong>的名字来命名，若头指针名是L，则把链表称为表L</p><h3 id="链表结点的定义"><a href="#链表结点的定义" class="headerlink" title="链表结点的定义"></a><strong>链表结点的定义</strong></h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct Lnode{ ElemType data;  //结点的数据域 struct Lnode *next;  //结点的指针域  }Lnode,*LinkList;//LlinkList为指向结构体Lnode的指针类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>单链表L的定义：<br>定义链表L： <code>LinkList L;</code><br>定义结点指针p： <code>LNode *p;</code> 、<code>LinkList p;</code></p><p>例如，存储学生学号、姓名、成绩的单链表结点类型定义如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct student{ char num[8]; char name[8]; int score; struct student *next;  }Lnode,*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过为了统一链表的操作，通常这样定义：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct { char num[8]; char name[8]; int score; }ElemType;typedef struct Lnode{ ElemType data； struct Lnode *next;  }Lnode,*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法1-单链表的初始化"><a href="#算法1-单链表的初始化" class="headerlink" title="算法1 单链表的初始化"></a><strong>算法1</strong> 单链表的初始化</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitList L(LinkList &amp;L){   L=new LNode;  //或 L=(LinkList)malloc (sizeof(LNode));   L-&gt;next=NULL;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-判断链表是否为空"><a href="#算法2-判断链表是否为空" class="headerlink" title="算法2 判断链表是否为空"></a><strong>算法2</strong> 判断链表是否为空</h3><p>空表：链表中无元素，称为空链表(头指针和头结点仍然在)</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int ListEmpty (LinkList L){ if(L-&gt;next) //非空   return 0; else    return 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法3-单链表的销毁"><a href="#算法3-单链表的销毁" class="headerlink" title="算法3 单链表的销毁"></a><strong>算法3</strong> 单链表的销毁</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DestroyList_L(LinkList &amp;L){ Lnode *p; while(L){   p=L;   L=L-&gt;next;   delete p; }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法4-清空单链表"><a href="#算法4-清空单链表" class="headerlink" title="算法4 清空单链表"></a><strong>算法4</strong> 清空单链表</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ClearList(LinkList &amp;L){   Lnode *p，*q；   p=L-&gt;next;   while(p){     q=p-&gt;next;     delete p;     p=q;   }  L-&gt;next=NULL;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法5-单链表表长"><a href="#算法5-单链表表长" class="headerlink" title="算法5 单链表表长"></a><strong>算法5</strong> 单链表表长</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int ListLength_L(LinkList L){   LinkList p; //Lnode *p;    p=L-&gt;next; //p指向第一个结点     i=0;     while(p){       i++;       p=p-&gt;next;     }   return i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法6-取值"><a href="#算法6-取值" class="headerlink" title="算法6 取值"></a><strong>算法6</strong> 取值</h3><p> 取单链表中第i个元素内容  </p> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status GetElem L(LinkList L, int i,ElemType &amp;e){  p=L-&gt;next;  j=1;  while(p &amp;&amp; j&lt;i){    p=p-&gt;next; ++j;  }  if(!p||j&gt;i) return ERROR;    e=p-&gt;data;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-按值查找"><a href="#算法7-按值查找" class="headerlink" title="算法7 按值查找"></a><strong>算法7</strong> 按值查找</h3><p>根据指定数据获取该数据所在的位置(地址)</p> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Lnode *LocateElem_L(LinkList L,ElemType e){  P=L-&gt;next;  while(p&amp;&amp;p-&gt;data!=e)     p=p-&gt;next;  return p;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法7-变化-按值查找"><a href="#算法7-变化-按值查找" class="headerlink" title="算法7-变化 按值查找"></a><strong>算法7-变化</strong> 按值查找</h3><p>根据指定数据获取该数据所在的位置序号</p> <pre class="line-numbers language-C" data-language="C"><code class="language-C">int LocateElem_L(LinkList L,ElemType e){  P=L-&gt;next; j=1;  while(p&amp;&amp;p-&gt;data!=e)     {p=p-&gt;next;j++;}  if(p)return j;  else return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法8-插入-在第i个结点前插入值为e的新结点"><a href="#算法8-插入-在第i个结点前插入值为e的新结点" class="headerlink" title="算法8 插入-在第i个结点前插入值为e的新结点"></a><strong>算法8</strong> 插入-在第i个结点前插入值为e的新结点</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListInsert_L(LinkList &amp;L,int i,ElemType e){  P=L;j=0;  while(p&amp;&amp;j&lt;i-1)     {p=p-&gt;next;++j;}  if(p||j&gt;i-1)return ERROR;  s=new LNode; s-&gt;data=e;  s-&gt;next=p-&gt;next;  p-&gt;next=s;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法9-删除-删除第i个结点"><a href="#算法9-删除-删除第i个结点" class="headerlink" title="算法9 删除-删除第i个结点"></a><strong>算法9</strong> 删除-删除第i个结点</h3> <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e){  P=L;j=0;  while(p-&gt;next&amp;&amp;j&lt;i-1){p=p-&gt;next;++j;}       if(!p-&gt;next||j&gt;i-1)return ERROR;  q=p-&gt;next;  p-&gt;next=q-&gt;next;  e=q-&gt;data;  delete q;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>单链表各算法时间效率  </p><ul><li>查找：O(n)</li><li>插入和删除：一般情况下O(1),但如果从头查找，所消耗的时间复杂度为O(n)</li></ul></blockquote><h3 id="算法10-单链表的建立"><a href="#算法10-单链表的建立" class="headerlink" title="算法10 单链表的建立"></a><strong>算法10</strong> 单链表的建立</h3><p>头插法：元素插入到链表头部<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/20.jpg"> </p><p>首先，在内存中找到一个空间存放头结点  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/21.jpg"><br><code>L=new LNode;</code>或<code>L=(LinkList)malloc(sizeof(LNode));</code>  </p></blockquote><p>将头结点置空  </p><blockquote><p><code>L-&gt;next=NULL;</code></p></blockquote><p>依次插入其余结点，从最后一个结点开始  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/22.jpg"><br><code>p=new LNode;  p-&gt;data=an;</code> </p></blockquote><p>将L的next域赋值给p的next域，并将头结点L的next赋值为新结点P的地址  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/23.jpg"><br><code>p=next=L-&gt;next;  L-&gt;next=p;</code>  </p></blockquote><p>继续放置前一个结点</p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/24.jpg"><br><code>p=new LNode; p-&gt;data=an-1</code>  </p></blockquote><p>再接着做之前的步骤  </p><blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/25.jpg"><br><code>p=next=L-&gt;next;  L-&gt;next=p;</code><br>反复循环，直到所有元素都插入  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">//倒位序输入n个元素值void CreateList_H(LinkList &amp;L,int n){   L=new LNode;   L-&gt;next=NULL;   for(i=n;i&gt;0;--i){     p=new LNode;     scanf(&amp;p-&gt;data);     p-&gt;next=L-&gt;next;     L-&gt;next=p;   } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尾插法：元素插入在链表尾部  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">//正位序输入n个元素值void CreateList_H(LinkList &amp;L,int n){   L=new LNode;   L-&gt;next=NULL;   r=L;//尾指针r指向头结点   for(i=0;i&lt;n;++i){     p=new LNode;     scanf(&amp;p-&gt;data);     p-&gt;next=NULL;     r-&gt;next=p;     r=p;//r指向新的尾结点   } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a><strong>循环链表</strong></h2><p>是一种头尾相接的链表<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/26.jpg"><br>优点：从表中任意结点出发均可找到表中其他结点  </p><blockquote><p>循环列表没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断<code>p</code>或<code>p-&gt;next </code>是否为空，而是判断他们是否等于头指针  </p></blockquote><p>循环条件:  </p><table><thead><tr><th>单链表</th><th>单循环链表</th></tr></thead><tbody><tr><td>p!=NULL</td><td>p!=L</td></tr><tr><td>P-&gt;next!=NULL</td><td>p-&gt;NEXT!=1</td></tr></tbody></table><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/27.jpg"> </p><blockquote><p>循环链表若经常需要对首尾进行操作，则设置尾指针更为合适  </p></blockquote><h3 id="带尾指针循环链表的合并"><a href="#带尾指针循环链表的合并" class="headerlink" title="带尾指针循环链表的合并"></a><strong>带尾指针循环链表的合并</strong></h3><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/28.jpg"></p><blockquote><p>p存表头结点，Tb表头连接到Ta表尾，释放Tb表头结点，修改指针<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/29.jpg"><br><code>p=Ta-&gt;next;</code><br><code>Ta-&gt;next=Tb-&gt;next-&gt;next;</code><br><code>delete Tb-&gt;next;</code>   </p></blockquote><p>算法描述  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">LinkList Connect(LinkList Ta,LinkList Tb){   p=Ta-&gt;next;   Ta-&gt;next=Tb-&gt;next-&gt;next;   delete Tb-&gt;next;   Tb-&gt;next=p;   return Tb; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a><strong>双向链表</strong></h2><p> 双向链表的结点结构<br> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/30.jpg">   </p><h3 id="双向链表的结构定义"><a href="#双向链表的结构定义" class="headerlink" title="双向链表的结构定义"></a><strong>双向链表的结构定义</strong></h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct DuLNode{  Elemtype data;  struct DuLNode *prior, *next;}DuLNode,*DuLinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/31.jpg">   </p><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a><strong>双向循环链表</strong></h3><p>-让头结点的前驱指针指向链表的最后一个结点<br>-让最后一个结点的后继指向头结点<br> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/32.jpg"> </p><h3 id="算法1-双向链表的插入"><a href="#算法1-双向链表的插入" class="headerlink" title="算法1 双向链表的插入"></a><strong>算法1</strong> 双向链表的插入</h3><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/33.jpg">   </p><blockquote><p><code>s-&gt;prior=p-&gt;prior;</code><br><code>p-&gt;prior-&gt;next=s;</code><br><code>s-&gt;next=p;</code><br><code>p-&gt;prior=s;</code>  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">void LinkInsert_DuL(DuLinkList &amp;L, int i,ElemType e){   if(!(p=GetElemP_DuL(L,i)))return ERROR;   s=new DuLNode;   s-&gt;data=e;   s-&gt;prior=p-&gt;prior;   p-&gt;prior-&gt;next=s;   s-&gt;next=p;   p-&gt;prior=s;   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法2-双向链表的删除"><a href="#算法2-双向链表的删除" class="headerlink" title="算法2 双向链表的删除"></a><strong>算法2</strong> 双向链表的删除</h3><p> <img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/34.jpg"></p><blockquote><p><code>p-&gt;prior-&gt;next=p-&gt;next;</code><br><code>p-&gt;next-&gt;prior=p-&gt;prior;</code>  </p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">void LinkInsert_DuL(DuLinkList &amp;L, int i,ElemType e){   if(!(p=GetElemP_DuL(L,i)))return ERROR;   e=p-&gt;data;   p-&gt;prior-&gt;next=p-&gt;next;   p-&gt;next-&gt;prior=p-&gt;prior;   free(p);   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单链表、循环链表和双向链表的时间效率比较"><a href="#单链表、循环链表和双向链表的时间效率比较" class="headerlink" title="单链表、循环链表和双向链表的时间效率比较"></a><strong>单链表、循环链表和双向链表的时间效率比较</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/35.jpg">  </p><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a><strong>顺序表和链表的比较</strong></h2><p>链式存储结构的优点：</p><blockquote><p>结点空间可以动态申请和释放<br>删除和插入时不需要移动数据元素  </p></blockquote><p>链式存储结构的缺点：</p><blockquote><p>存储密度小，每个结点的指针域需额外占用存储空间<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/36.jpg"><br>非随机存取结构，对任意结点的操作都要从头指针依指针链查找到该结点，增加了算法复杂度  </p></blockquote><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/37.jpg">  </p><h2 id="案例1：一元多项式的运算"><a href="#案例1：一元多项式的运算" class="headerlink" title="案例1：一元多项式的运算"></a><strong>案例1：一元多项式的运算</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/38.jpg">  </p><h2 id="案例2：稀疏多项式的运算"><a href="#案例2：稀疏多项式的运算" class="headerlink" title="案例2：稀疏多项式的运算"></a><strong>案例2：稀疏多项式的运算</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/39.jpg">  </p><p>结构建立：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct PNode{    float coef;  //系数    int expn;    //指数    struct PNode *next; //指针域  }PNode,*Polynomial;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/40.jpg"></p><p>多项式创建：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void CreatePolyn(Polynomial &amp;P, int n){   P=new PNode;   P-&gt;next=NULL;   for(i=1;i&lt;=n;i++){    s=new PNode;    cin&gt;&gt;s-&gt;coef&gt;&gt;s-&gt;expn;    pre=P;    q=P-&gt;next;    while(q&amp;&amp;q-&gt;expn&lt;s-&gt;expn){      pre=q; q=q-&gt;next;    }    s-&gt;next=q;    pre-&gt;next=s;   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多项式相加：<br><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/41.jpg">  </p><h2 id="案例3：图书信息管理系统"><a href="#案例3：图书信息管理系统" class="headerlink" title="案例3：图书信息管理系统"></a><strong>案例3：图书信息管理系统</strong></h2><p><img src="/2022/09/11/shu-ju-jie-gou-zhi-xian-xing-biao/42.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础简记ch.1</title>
      <link href="/2022/09/07/php-ji-chu-jian-ji-ch.1/"/>
      <url>/2022/09/07/php-ji-chu-jian-ji-ch.1/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP基础简记ch-1"><a href="#PHP基础简记ch-1" class="headerlink" title="PHP基础简记ch.1"></a>PHP基础简记ch.1</h1><h2 id="PHP标记"><a href="#PHP标记" class="headerlink" title="PHP标记"></a><strong>PHP标记</strong></h2><p> 1.脚本标记   </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;script language="php"&gt;  echo 'hello world';&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 2.标准标记  </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  echo 'hello world';?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="PHP注释"><a href="#PHP注释" class="headerlink" title="PHP注释"></a><strong>PHP注释</strong></h2><ul><li>行注释 <code>//</code>、<code>#</code>  </li><li>块注释 <code>/* */</code></li></ul><h2 id="语句分隔符"><a href="#语句分隔符" class="headerlink" title="语句分隔符"></a><strong>语句分隔符</strong></h2><p>PHP中，代码是以行为单位，系统需要通过判断行的结束，该结束通常都是一个符号：分号 <code>;</code> (英文状态下的)</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  //定义变量  $var1;  $var2 = 1;//定义同时赋值  echo $var2;//通过var2变量名字找到储存内容1，然后输出    //删除变量，使用unset（变量名字）  unset($var2)?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>提前定义的变量，储存许多需要用的数据（预定义变量都是数组）  </p><ul><li>$_GET：获取所有表单以get方式提交的数据</li><li>$_POST: POST提交的数据都会保存在此次</li><li>$_REQUEST: GET和POST提交的都会保存</li><li>$_SERVER: 服务器信息</li><li>$_SESSION: session会话数据</li></ul><h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><p>如果一个变量保存的值刚好是另一个变量的名字，则可以：  </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  //可变变量  $a = 'b';  $b = 'bb';  echo $$a;  //输出结果为bb?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h3><p>将一个变量赋值给另一个变量  </p><ul><li>值传递  </li><li>引用传递</li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  $a = 1;  $b = $a; //值传递    $b = 2;  echo $a,$b;  //输出结果1,2  $a = 1;  $b = &amp;$a; //引用传递    $b = 2;  echo $a,$b;  //输出结果2,2?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h2><p>常量一旦定义，通常数据不可改变</p><ul><li>使用定义常量的函数 <code>define( , )</code>  </li><li>5.3后才有的：const 常量名 = 值</li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  define('PI',3.14) ;  const PII =3 ;?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>常量不需要使用<code>$</code>符号，一旦使用会被认为是变量<br>常量的名字组成由字母、数字和下划线组成，不能以数字开头<br>常量的名字通常以大写字母为主<br>define 和 const 定义的常亮有区别，在于权限的区别，如：   </p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  define('-_-','smile') ;  //正确  const -_- ='smile' ; //错误?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如需访问常量，则需使用另外一个访问常量的函数：<code>echo constant('常量名')</code>  </p><h3 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h3><p>系统常量： 系统帮助用户定义的常量，用户可以直接使用<br>常用的几个系统常量：  </p><ul><li>PHP_VERSION  </li><li>PHP_INT_SIZE  </li><li>PHP_INT_MAX</li></ul><p>在PHP中还有一些特殊的常量，他们由双下划线开始+常量名+双下划线结束，这种常量称之为系统魔术常量，魔术常量的值通常会跟着环境变化，但是用户改变不了，如：  </p><ul><li><code>__DIR__</code>:被执行脚本在电脑的绝对路径  </li><li><code>__FILE__</code>:被执行脚本在电脑的绝对路径（带文件名）  </li><li><code>__LINE__</code>:当前所属行数的绝对路径  </li><li><code>__NAMESPACE__</code>:当前所属命名空间  </li><li><code>__CLASS__</code>:当前所属类  </li><li><code>__METHOD__</code>:当前所属方法</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>在PHP中得的是存储的数据本身的类型，而不是变量的类型，PHP是一种弱类型语言，本身并没有类型  </p><h3 id="PHP的八种数据类型"><a href="#PHP的八种数据类型" class="headerlink" title="PHP的八种数据类型"></a>PHP的八种数据类型</h3><p>在PHP中将数据分为三大类八小类  </p><ul><li>基本数据类型<ul><li>整型：int ，四个字节储存  </li><li>浮点型：float/double ，八个字节储存</li><li>字符串型：string  </li><li>布尔类型：bool</li></ul></li><li>复合数据类型<ul><li>对象：object ，存放对象  </li><li>数组：array ，存储多个数据（一次性）</li></ul></li><li>特殊数据类型<ul><li>资源：resource ，存放资源数据</li><li>空类型：NULL</li></ul></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>需要指定数据类型，需要外部数据  </p><ul><li>自动转换：系统根据需求自己判定，效率偏低  </li><li>强制转换：人为转换，在变量前加一个括号，在里面写入对应类型</li></ul><p>在转换过程中，用的比较多的为转布尔类型和转数值类型，关于转布尔的说明：<br><img src="/2022/09/07/php-ji-chu-jian-ji-ch.1/about_bool.jpg" alt="布尔的相关说明">  </p><p>字符串转数值的说明  </p><ul><li>布尔true为1， false为0  </li><li>字符串转数值：<ul><li>以字母开头的字符串永远为0</li><li>以数字开头的字符串，取到碰到字符串为止（不会出现多个小数点）</li></ul></li></ul><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php  $a = 'abc1.1.1';  $b = '1.1.1abc'; //创建数据  echo $a + $b;  //自动转换  //算数+运算，系统先转换成数值类型（整型和浮点型）  //结果为1.1    echo (float)$a,(foloat)$b; //输出结果01.1?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h3><p>通过一组类型判断函数，来判断变量，最终返回这个变量所保存的数据类型（如果相同返回true）：以is_开头后面跟类型名字的函数: is_xxx(变量名)</p><p>bool类型不能用echo来查看，可使用<code>var_dump</code>结构来查看  </p><p>还有一组函数可以来获取积极设定数据的类型 gettype(变量名)：获取类型，得到的是该类型对应的字符串</p><p>settype(变量名，类型): 设定数据类型：与强制转换不同  </p><ul><li>强制转换是对数据值复制的内容进行处理  </li><li>settype会改变变量本身</li></ul><h3 id="整数类型进制"><a href="#整数类型进制" class="headerlink" title="整数类型进制"></a>整数类型进制</h3><blockquote><p>在PHP中提供了四种类型的定义方式：十进制、二进制、八进制、十六进制<br><code>$a=120; //十进制</code><br><code>$a=0b120; //二进制</code><br><code>$a=0120; //八进制</code><br><code>$a=0x120; //十六进制</code>  </p></blockquote><h3 id="整数类型进制转换"><a href="#整数类型进制转换" class="headerlink" title="整数类型进制转换"></a>整数类型进制转换</h3><ul><li><code>decbin()</code>:10转2  </li><li><code>decoct()</code>:10转8  </li><li><code>dechex()</code>:10转16  </li><li><code>bindec()</code>:2转10</li></ul><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>整型超过自身存储的大小后会用浮点型存储  </p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h2><p>与其他语言几乎一致，补充一点‘全等于’：<code>===</code> 左边与右边相同(大小、数据类型)</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/02/hello-world/"/>
      <url>/2022/09/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
